<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Asciidoctor 2.0.10">
    <title>Testing</title>
    <style>
        @import 'css/spring.css';
        .listingblock .switch {
            border-style: none;
            display: inline-block;This chapter covers Spring’s
            position: relative;
            bottom: -3px;
        }

        .listingblock .switch--item {
            padding: 10px;
            background-color: #e6e1dc;
            color: #282c34;
            display: inline-block;
            cursor: pointer;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }

        .listingblock .switch--item:not(:first-child) {
            border-style: none;
        }

        .listingblock .switch--item.selected {
            background-color: #282c34;
            color: #e6e1dc;
        }

        .listingblock pre.highlightjs {
            padding: 0;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
        .hidden {
            display: none;
        }

        .switch {
            border-width: 1px 1px 0 1px;
            border-style: solid;
            border-color: #7a2518;
            display: inline-block;
        }

        .switch--item {
            padding: 10px;
            background-color: #ffffff;
            color: #7a2518;
            display: inline-block;
            cursor: pointer;
        }

        .switch--item:not(:first-child) {
            border-width: 0 0 0 1px;
            border-style: solid;
            border-color: #7a2518;
        }

        .switch--item.selected {
            background-color: #7a2519;
            color: #ffffff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
    <script type="text/javascript">
        function addBlockSwitches() {
            $('.primary').each(function() {
                primary = $(this);
                createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
                primary.children('.title').remove();
            });
            $('.secondary').each(function(idx, node) {
                secondary = $(node);
                primary = findPrimary(secondary);
                switchItem = createSwitchItem(secondary, primary.children('.switch'));
                switchItem.content.addClass('hidden');
                findPrimary(secondary).append(switchItem.content);
                secondary.remove();
            });
        }

        function createBlockSwitch(primary) {
            blockSwitch = $('<div class="switch"></div>');
            primary.prepend(blockSwitch);
            return blockSwitch;
        }

        function findPrimary(secondary) {
            candidate = secondary.prev();
            while (!candidate.is('.primary')) {
                candidate = candidate.prev();
            }
            return candidate;
        }

        function createSwitchItem(block, blockSwitch) {
            blockName = block.children('.title').text();
            content = block.children('.content').first().append(block.next('.colist'));
            item = $('<div class="switch--item">' + blockName + '</div>');
            blockSwitch.append(item);
            return {
                'item': item,
                'content': content
            };
        }

        function globalSwitch() {
            $('.switch--item').each(function() {
                var blockId = blockIdForSwitchItem($(this));
                $(this).off('click');
                $(this).on('click', function() {
                    selectedText = $(this).text()
                    window.localStorage.setItem(blockId, selectedText);
                    $(".switch--item").filter(function() {
                        return blockIdForSwitchItem($(this)) === blockId;
                    }).filter(function() {
                        return $(this).text() === selectedText;
                    }).each(function() {
                        select($(this))
                    });
                });
                if ($(this).text() === window.localStorage.getItem(blockId)) {
                    select($(this))
                }
            });
        }

        function blockIdForSwitchItem(item) {
            idComponents = []
            idComponents.push(item.text().toLowerCase());
            item.siblings(".switch--item").each(function(index, sibling) {
                idComponents.push($(sibling).text().toLowerCase());
            });
            return idComponents.sort().join("-")
        }

        function select(selected) {
            selected.addClass('selected');
            selected.siblings().removeClass('selected');
            selectedContent = selected.parent().siblings(".content").eq(selected.index())
            selectedContent.removeClass('hidden');
            selectedContent.siblings().addClass('hidden');
        }

        $(addBlockSwitches);
        $(globalSwitch);
    </script>
</head>

<body id="testing" class="book toc2 toc-left">
    <div id="header">
        <h1>Testing</h1>
        <div class="details">
            <span id="revnumber">version 5.3.8</span>
        </div>
        <div id="toc" class="toc2">
            <div id="toctitle">Table of Contents</div>
            <ul class="sectlevel1">
                <li><a href="#testing-introduction">1. Introduction to Spring Testing</a></li>
                <li><a href="#unit-testing">2. Unit Testing</a>
                    <ul class="sectlevel2">
                        <li><a href="#mock-objects">2.1. Mock Objects</a>
                            <ul class="sectlevel3">
                                <li><a href="#mock-objects-env">2.1.1. Environment</a></li>
                                <li><a href="#mock-objects-jndi">2.1.2. JNDI</a></li>
                                <li><a href="#mock-objects-servlet">2.1.3. Servlet API</a></li>
                                <li><a href="#mock-objects-web-reactive">2.1.4. Spring Web Reactive</a></li>
                            </ul>
                        </li>
                        <li><a href="#unit-testing-support-classes">2.2. Unit Testing Support Classes</a>
                            <ul class="sectlevel3">
                                <li><a href="#unit-testing-utilities">2.2.1. General Testing Utilities</a></li>
                                <li><a href="#unit-testing-spring-mvc">2.2.2. Spring MVC Testing Utilities</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#integration-testing">3. Integration Testing</a>
                    <ul class="sectlevel2">
                        <li><a href="#integration-testing-overview">3.1. Overview</a></li>
                        <li><a href="#integration-testing-goals">3.2. Goals of Integration Testing</a>
                            <ul class="sectlevel3">
                                <li><a href="#testing-ctx-management">3.2.1. Context Management and Caching</a></li>
                                <li><a href="#testing-fixture-di">3.2.2. Dependency Injection of Test Fixtures</a></li>
                                <li><a href="#testing-tx">3.2.3. Transaction Management</a></li>
                                <li><a href="#testing-support-classes">3.2.4. Support Classes for Integration Testing</a></li>
                            </ul>
                        </li>
                        <li><a href="#integration-testing-support-jdbc">3.3. JDBC Testing Support</a></li>
                        <li><a href="#integration-testing-annotations">3.4. Annotations</a>
                            <ul class="sectlevel3">
                                <li><a href="#integration-testing-annotations-spring">3.4.1. Spring Testing Annotations</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></li>
                                        <li><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></li>
                                        <li><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></li>
                                        <li><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></li>
                                        <li><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></li>
                                        <li><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></li>
                                        <li><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></li>
                                        <li><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></li>
                                        <li><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></li>
                                        <li><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></li>
                                        <li><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></li>
                                        <li><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></li>
                                        <li><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></li>
                                        <li><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></li>
                                        <li><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></li>
                                        <li><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></li>
                                        <li><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></li>
                                        <li><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></li>
                                    </ul>
                                </li>
                                <li><a href="#integration-testing-annotations-standard">3.4.2. Standard Annotation Support</a></li>
                                <li><a href="#integration-testing-annotations-junit4">3.4.3. Spring JUnit 4 Testing Annotations</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></li>
                                    </ul>
                                </li>
                                <li><a href="#integration-testing-annotations-junit-jupiter">3.4.4. Spring JUnit Jupiter Testing Annotations</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></li>
                                        <li><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></li>
                                        <li><a href="#integration-testing-annotations-nestedtestconfiguration"><code>@NestedTestConfiguration</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></li>
                                        <li><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></li>
                                    </ul>
                                </li>
                                <li><a href="#integration-testing-annotations-meta">3.4.5. Meta-Annotation Support for Testing</a></li>
                            </ul>
                        </li>
                        <li><a href="#testcontext-framework">3.5. Spring TestContext Framework</a>
                            <ul class="sectlevel3">
                                <li><a href="#testcontext-key-abstractions">3.5.1. Key Abstractions</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext"><code>TestContext</code></a></li>
                                        <li><a href="#testcontextmanager"><code>TestContextManager</code></a></li>
                                        <li><a href="#testexecutionlistener"><code>TestExecutionListener</code></a></li>
                                        <li><a href="#context-loaders">Context Loaders</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-bootstrapping">3.5.2. Bootstrapping the TestContext Framework</a></li>
                                <li><a href="#testcontext-tel-config">3.5.3. <code>TestExecutionListener</code> Configuration</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-tel-config-registering-tels">Registering <code>TestExecutionListener</code> Implementations</a></li>
                                        <li><a href="#testcontext-tel-config-automatic-discovery">Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</a></li>
                                        <li><a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a></li>
                                        <li><a href="#testcontext-tel-config-merging">Merging <code>TestExecutionListener</code> Implementations</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-application-events">3.5.4. Application Events</a></li>
                                <li><a href="#testcontext-test-execution-events">3.5.5. Test Execution Events</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-test-execution-events-exception-handling">Exception Handling</a></li>
                                        <li><a href="#testcontext-test-execution-events-async">Asynchronous Listeners</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-ctx-management">3.5.6. Context Management</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></li>
                                        <li><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></li>
                                        <li><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></li>
                                        <li><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></li>
                                        <li><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></li>
                                        <li><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></li>
                                        <li><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></li>
                                        <li><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></li>
                                        <li><a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></li>
                                        <li><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></li>
                                        <li><a href="#testcontext-ctx-management-caching">Context Caching</a></li>
                                        <li><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-fixture-di">3.5.7. Dependency Injection of Test Fixtures</a></li>
                                <li><a href="#testcontext-web-scoped-beans">3.5.8. Testing Request- and Session-scoped Beans</a></li>
                                <li><a href="#testcontext-tx">3.5.9. Transaction Management</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-tx-test-managed-transactions">Test-managed Transactions</a></li>
                                        <li><a href="#testcontext-tx-enabling-transactions">Enabling and Disabling Transactions</a></li>
                                        <li><a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a></li>
                                        <li><a href="#testcontext-tx-programmatic-tx-mgt">Programmatic Transaction Management</a></li>
                                        <li><a href="#testcontext-tx-before-and-after-tx">Running Code Outside of a Transaction</a></li>
                                        <li><a href="#testcontext-tx-mgr-config">Configuring a Transaction Manager</a></li>
                                        <li><a href="#testcontext-tx-annotation-demo">Demonstration of All Transaction-related Annotations</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-executing-sql">3.5.10. Executing SQL Scripts</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-executing-sql-programmatically">Executing SQL scripts programmatically</a></li>
                                        <li><a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a></li>
                                    </ul>
                                </li>
                                <li><a href="#testcontext-parallel-test-execution">3.5.11. Parallel Test Execution</a></li>
                                <li><a href="#testcontext-support-classes">3.5.12. TestContext Framework Support Classes</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#testcontext-junit4-runner">Spring JUnit 4 Runner</a></li>
                                        <li><a href="#testcontext-junit4-rules">Spring JUnit 4 Rules</a></li>
                                        <li><a href="#testcontext-support-classes-junit4">JUnit 4 Support Classes</a></li>
                                        <li><a href="#testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</a></li>
                                        <li><a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a></li>
                                        <li><a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a></li>
                                        <li><a href="#testcontext-support-classes-testng">TestNG Support Classes</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#webtestclient">3.6. WebTestClient</a>
                            <ul class="sectlevel3">
                                <li><a href="#webtestclient-setup">3.6.1. Setup</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#webtestclient-controller-config">Bind to Controller</a></li>
                                        <li><a href="#webtestclient-context-config">Bind to <code>ApplicationContext</code></a></li>
                                        <li><a href="#webtestclient-fn-config">Bind to Router Function</a></li>
                                        <li><a href="#webtestclient-server-config">Bind to Server</a></li>
                                        <li><a href="#webtestclient-client-config">Client Config</a></li>
                                    </ul>
                                </li>
                                <li><a href="#webtestclient-tests">3.6.2. Writing Tests</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#webtestclient-no-content">No Content</a></li>
                                        <li><a href="#webtestclient-json">JSON Content</a></li>
                                        <li><a href="#webtestclient-stream">Streaming Responses</a></li>
                                        <li><a href="#webtestclient-mockmvc">MockMvc Assertions</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#spring-mvc-test-framework">3.7. MockMvc</a>
                            <ul class="sectlevel3">
                                <li><a href="#spring-mvc-test-server">3.7.1. Overview</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#spring-mvc-test-server-static-imports">Static Imports</a></li>
                                        <li><a href="#spring-mvc-test-server-setup-options">Setup Choices</a></li>
                                        <li><a href="#spring-mvc-test-server-setup-steps">Setup Features</a></li>
                                        <li><a href="#spring-mvc-test-server-performing-requests">Performing Requests</a></li>
                                        <li><a href="#spring-mvc-test-server-defining-expectations">Defining Expectations</a></li>
                                        <li><a href="#spring-mvc-test-async-requests">Async Requests</a></li>
                                        <li><a href="#spring-mvc-test-vs-streaming-response">Streaming Responses</a></li>
                                        <li><a href="#spring-mvc-test-server-filters">Filter Registrations</a></li>
                                        <li><a href="#spring-mvc-test-vs-end-to-end-integration-tests">MockMvc vs End-to-End Tests</a></li>
                                        <li><a href="#spring-mvc-test-server-resources">Further Examples</a></li>
                                    </ul>
                                </li>
                                <li><a href="#spring-mvc-test-server-htmlunit">3.7.2. HtmlUnit Integration</a>
                                    <ul class="sectlevel4">
                                        <li><a href="#spring-mvc-test-server-htmlunit-why">Why HtmlUnit Integration?</a></li>
                                        <li><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a></li>
                                        <li><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a></li>
                                        <li><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#spring-mvc-test-client">3.8. Testing Client Applications</a>
                            <ul class="sectlevel3">
                                <li><a href="#spring-mvc-test-client-static-imports">3.8.1. Static Imports</a></li>
                                <li><a href="#spring-mvc-test-client-resources">3.8.2. Further Examples of Client-side REST Tests</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#testing-resources">4. Further Resources</a></li>
            </ul>
        </div>
    </div>
    <div id="content">
        <div id="preamble">
            <div class="sectionbody">
                <div class="paragraph">
                    <p>This chapter covers Spring&#8217;s support for integration testing and best practices for unit testing. The Spring team advocates test-driven development (TDD). The Spring team has found that the correct use of inversion of control
                        (IoC) certainly does make both unit and integration testing easier (in that the presence of setter methods and appropriate constructors on classes makes them easier to wire together in a test without having to set up service locator
                        registries and similar structures).</br>
                        <span class="translate">
                        本章将介绍Spring对集成测试的支持以及单元测试的最佳实践。Spring团队提倡测试驱动开发(TDD)。
                        Spring的团队发现,正确使用控制反转(IoC)的确是简化单元测试和集成测试(setter方法和适当的构造函数类的存在使他们更容易连接在一起测试,
                        而无需建立服务定位器注册中心和类似的结构)。
                        </span>
                </div>
            </div>
        </div>
        <div class="sect1">
            <h2 id="testing-introduction"><a class="anchor" href="#testing-introduction"></a>1. Introduction to Spring Testing</h2>
            <span class="translate">1.Spring Test 介绍</span>
            <div class="sectionbody">
                <div class="paragraph">
                    <p>Testing is an integral part of enterprise software development. This chapter focuses on the value added by the IoC principle to <a href="#unit-testing">unit testing</a> and on the benefits of the Spring Framework&#8217;s support for
                        <a href="#integration-testing">integration testing</a>. (A thorough treatment of testing in the enterprise is beyond the scope of this reference manual.)</br>
                        <span class="translate">测试是企业软件开发不可或缺的一部分。本章重点讨论IoC原则为单元测试带来的价值，以及Spring框架对集成测试的支持所带来的好处。(对企业中测试的彻底处理超出了本参考手册的范围。)</span>
                    </p>
                </div>
            </div>
        </div>
        <div class="sect1">
            <h2 id="unit-testing"><a class="anchor" href="#unit-testing"></a>2. Unit Testing</h2>
             <span class="translate">2. 单元测试</span>
            <div class="sectionbody">
                <div class="paragraph">
                    <p>Dependency injection should make your code less dependent on the container than it would be with traditional Java EE development. The POJOs that make up your application should be testable in JUnit or TestNG tests, with objects instantiated
                        by using the <code>new</code> operator, without Spring or any other container. You can use <a href="#mock-objects">mock objects</a> (in conjunction with other valuable testing techniques) to test your code in isolation. If you
                        follow the architecture recommendations for Spring, the resulting clean layering and componentization of your codebase facilitate easier unit testing. For example, you can test service layer objects by stubbing or mocking DAO or
                        repository interfaces, without needing to access persistent data while running unit tests.</br>
                         <span class="translate">
                        与传统Java EE开发相比，依赖项注入应该使您的代码更少地依赖于容器。组成应用程序的pojo应该在JUnit或TestNG测试中进行测试，使用new操作符实例化对象，而不使用Spring或任何其他容器。
                        您可以使用模拟对象(与其他有价值的测试技术一起)单独测试您的代码。
                        如果您遵循Spring的架构建议，那么代码基的干净分层和组件化将使单元测试变得更容易。
                        例如，您可以通过存根或模拟DAO或存储库接口来测试服务层对象，而不需要在运行单元测试时访问持久数据。
                        </span>
                    </p>
                </div>
                <div class="paragraph">
                    <p>True unit tests typically run extremely quickly, as there is no runtime infrastructure to set up. Emphasizing true unit tests as part of your development methodology can boost your productivity. You may not need this section of the
                        testing chapter to help you write effective unit tests for your IoC-based applications. For certain unit testing scenarios, however, the Spring Framework provides mock objects and testing support classes, which are described in
                        this chapter.</br>
                        <span class="translate">真正的单元测试通常运行得非常快，因为不需要设置运行时基础结构。强调真正的单元测试作为开发方法的一部分可以提高您的生产力。
                        您可能不需要测试章节的这一节来帮助您为基于ioc的应用程序编写有效的单元测试。
                        然而，对于某些单元测试场景，Spring框架提供了模拟对象和测试支持类，这些将在本章中描述。</span>
                    </p>
                </div>
                <div class="sect2">
                    <h3 id="mock-objects"><a class="anchor" href="#mock-objects"></a>2.1. Mock Objects</h3>
                    <span>2.1 模拟对象</span>
                    <div class="paragraph">
                        <p>Spring includes a number of packages dedicated to mocking:</br>
                           <span class="translate"> Spring包含了许多用于模拟的包:</span>
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p><a href="#mock-objects-env">Environment</a></p>
                            </li>
                            <li>
                                <p><a href="#mock-objects-jndi">JNDI</a></p>
                            </li>
                            <li>
                                <p><a href="#mock-objects-servlet">Servlet API</a></p>
                            </li>
                            <li>
                                <p><a href="#mock-objects-web-reactive">Spring Web Reactive</a></p>
                            </li>
                        </ul>
                    </div>
                    <div class="sect3">
                        <h4 id="mock-objects-env"><a class="anchor" href="#mock-objects-env"></a>2.1.1. Environment</h4>
                        <span>2.1.1 环境</span>
                        <div class="paragraph">
                            <p>The <code>org.springframework.mock.env</code> package contains mock implementations of the
                                <code>Environment</code> and <code>PropertySource</code> abstractions (see
                                <a href="core.html#beans-definition-profiles">Bean Definition Profiles</a> and <a href="core.html#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a>).
                                <code>MockEnvironment</code> and <code>MockPropertySource</code> are useful for developing out-of-container tests for code that depends on environment-specific properties.</br>
                                <span class="translate">
                                org.springframework.mock.env包包含了环境和propertsource抽象的模拟实现(参见Bean定义概要文件和propertsource抽象)。
                                MockEnvironment和mockpropertsource对于为依赖于特定于环境的属性的代码开发容器外测试非常有用。
                                </span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="mock-objects-jndi"><a class="anchor" href="#mock-objects-jndi"></a>2.1.2. JNDI</h4>
                        <span>2.1.2 命名目录服务(Java Naming and Directory Interface)</span>
                        <div class="paragraph">
                            <p>
                                The <code>org.springframework.mock.jndi</code> package contains a partial implementation of the JNDI SPI, which you can use to set up a simple JNDI environment for test suites or stand-alone applications. If, for example, JDBC
                                <code>DataSource</code> instances get bound to the same JNDI names in test code as they do in a Java EE container, you can reuse both application code and configuration in testing scenarios without modification.</br>
                                <span class="translate">
                                org.springframework.mock.jndi 包包含 JNDI SPI 的部分实现，您可以使用它为测试套件或独立应用程序设置简单的 JNDI 环境。
                                例如，如果 JDBC DataSource 实例在测试代码中绑定到与它们在 Java EE 容器中相同的 JNDI 名称，则您可以在测试场景中重用应用程序代码和配置而无需修改。
                                </span>
                            </p>
                        </div>
                        <div class="admonitionblock warning">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-warning" title="Warning"></i>
                                    </td>
                                    <td class="content">
                                        The mock JNDI support in the <code>org.springframework.mock.jndi</code> package is officially deprecated as of Spring Framework 5.2 in favor of complete solutions from third parties such as <a href="https://github.com/h-thurow/Simple-JNDI">Simple-JNDI</a>.</br>
                                        <span class="translate">org.springframework.mock.jndi包中的模拟JNDI支持从Spring Framework 5.2开始正式弃用，取而代之的是来自第三方(如Simple-JNDI)的完整解决方案。</span>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="mock-objects-servlet"><a class="anchor" href="#mock-objects-servlet"></a>2.1.3. Servlet API</h4>
                        <div class="paragraph">
                            <p>The <code>org.springframework.mock.web</code> package contains a comprehensive set of Servlet API mock objects that are useful for testing web contexts, controllers, and filters. These mock objects are targeted at usage with
                                Spring&#8217;s Web MVC framework and are generally more convenient to use than dynamic mock objects (such as <a href="http://easymock.org/">EasyMock</a>) or alternative Servlet API mock objects (such as <a href="http://www.mockobjects.com">MockObjects</a>).</br>
                                <span class="translate">
                                web包包含了一组完整的Servlet API模拟对象，这些对象对于测试web上下文、控制器和过滤器非常有用。
                                这些模拟对象针对Spring的Web MVC框架的使用，通常比动态模拟对象(如EasyMock)或替代Servlet API模拟对象(如MockObjects)更方便使用。
                                </span>
                            </p>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        Since Spring Framework 5.0, the mock objects in <code>org.springframework.mock.web</code> are based on the Servlet 4.0 API.</br>
                                        <span class="translate">从Spring Framework 5.0开始，org.springframework.mock.web中的模拟对象都是基于Servlet 4.0 API的。</span>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>
                                The Spring MVC Test framework builds on the mock Servlet API objects to provide an integration testing framework for Spring MVC.
                                See <a href="#spring-mvc-test-framework">MockMvc</a>.</br>
                                <span class="translate">Spring MVC测试框架构建在模拟Servlet API对象上，为Spring MVC提供集成测试框架。看到MockMvc。</span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="mock-objects-web-reactive"><a class="anchor" href="#mock-objects-web-reactive"></a>2.1.4. Spring Web Reactive</h4>
                        <div class="paragraph">
                            <p>The <code>org.springframework.mock.http.server.reactive</code> package contains mock implementations of <code>ServerHttpRequest</code> and <code>ServerHttpResponse</code> for use in WebFlux applications. The
                                <code>org.springframework.mock.web.server</code> package contains a mock <code>ServerWebExchange</code> that depends on those mock request and response objects.</br>
                               <span class="translate"> <code>org.springframework.mock.web.server</code>包包含了ServerHttpRequest和ServerHttpResponse的模拟实现，用于WebFlux应用程序。
                                server包包含一个模拟ServerWebExchange，它依赖于那些模拟请求和响应对象。</span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                Both <code>MockServerHttpRequest</code> and <code>MockServerHttpResponse</code> extend from the same abstract base classes as server-specific
                                implementations and share behavior with them. For example, a mock request is immutable once created,
                                but you can use the <code>mutate()</code> method from <code>ServerHttpRequest</code> to create a modified instance.</br>
                                <span class="translate">
                                MockServerHttpRequest和MockServerHttpResponse都继承了与特定于服务器的实现相同的抽象基类，并与它们共享行为。
                                例如，mock请求创建后是不可变的，但是可以使用ServerHttpRequest中的mutate()方法创建修改后的实例。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                In order for the mock response to properly implement the write contract and return a write completion handle (that is, <code>Mono&lt;Void&gt;</code>),
                                it by default uses a <code>Flux</code> with <code>cache().then()</code>, which buffers the data and makes it available for assertions in tests.
                                Applications can set a custom write function (for example, to test an infinite stream).</br>
                                <span class="translate">
                                为了让模拟响应正确地实现写契约并返回一个写完成句柄(即<code>Mono&lt;Void&gt;</code>)，它默认使用带有cache().then()的Flux，它缓冲数据并使其可用于测试中的断言。
                                应用程序可以设置自定义写函数(例如，测试无限流)。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>The <a href="#webtestclient">WebTestClient</a> builds on the mock request and response to provide support for testing WebFlux applications without an HTTP server.
                             The client can also be used for end-to-end tests with a running server.</br>
                             <span class="translate">
                             WebTestClient构建在模拟请求和响应的基础上，为在没有HTTP服务器的情况下测试WebFlux应用程序提供支持。客户端还可以用于使用正在运行的服务器进行端到端测试。
                             </span>
                             </p>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="unit-testing-support-classes"><a class="anchor" href="#unit-testing-support-classes"></a>2.2. Unit Testing Support Classes</h3>
                    <span>2.2. 单元测试支持类</span>
                    <div class="paragraph">
                        <p>Spring includes a number of classes that can help with unit testing. They fall into two categories:</br>
                            <span class="translate">
                            Spring包含许多可以帮助进行单元测试的类。它们分为两类:
                            </span>
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p><a href="#unit-testing-utilities">General Testing Utilities[一般的测试工具]</a></p>
                            </li>
                            <li>
                                <p><a href="#unit-testing-spring-mvc">Spring MVC Testing Utilities[Spring MVC测试工具]</a></p>
                            </li>
                        </ul>
                    </div>
                    <div class="sect3">
                        <h4 id="unit-testing-utilities"><a class="anchor" href="#unit-testing-utilities"></a>2.2.1. General Testing Utilities</h4>
                        <span class="translate">2.2.1 一般的测试工具</span>
                        <div class="paragraph">
                            <p>The <code>org.springframework.test.util</code> package contains several general purpose utilities for use in unit and integration testing.</br>
                                <span class="translate">
                                    <code>org.springframework.test.util</code> 包包含几个通用的实用程序，用于单元和集成测试。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p><code>ReflectionTestUtils</code> is a collection of reflection-based utility methods. You can use these methods in testing scenarios where you need to change the value of a constant, set a non-<code>public</code> field, invoke
                                a non-<code>public</code> setter method, or invoke a non-<code>public</code> configuration or lifecycle callback method when testing application code for use cases such as the following:</br>
                                <span class="translate">
                                ReflectionTestUtils是一组基于反射的实用工具方法。你可以在测试场景中使用这些方法，当你需要更改一个常量的值，设置一个非公共字段，调用一个非公共setter方法，
                                或调用一个非公共配置或生命周期回调方法时，测试应用程序代码的用例如下:
                                </span>
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>ORM frameworks (such as JPA and Hibernate) that condone <code>private</code> or <code>protected</code> field access as opposed to <code>public</code> setter methods for properties in a domain entity.</br>
                                        <span class="translate">
                                            ORM框架(如JPA和Hibernate)允许私有或受保护的字段访问，而不是对域实体中的属性使用公共setter方法。
                                        </span>
                                    </p>
                                </li>
                                <li>
                                    <p>Spring&#8217;s support for annotations (such as <code>@Autowired</code>, <code>@Inject</code>, and <code>@Resource</code>), that provide dependency injection for <code>private</code> or <code>protected</code> fields,
                                        setter methods, and configuration methods.</br>
                                        <span class="translate">
                                        Spring对注释(如@Autowired、@Inject和@Resource)的支持，这些注释为私有或受保护的字段、setter方法和配置方法提供依赖注入。
                                        </span>
                                    </p>
                                </li>
                                <li>
                                    <p>Use of annotations such as <code>@PostConstruct</code> and <code>@PreDestroy</code> for lifecycle callback methods.</br>
                                        <span class="translate">
                                        在生命周期回调方法中使用@PostConstruct和@PreDestroy这样的注释。
                                        </span>
                                    </p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p><a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/util/AopTestUtils.html"><code>AopTestUtils</code></a> is a collection of AOP-related utility methods. You can use these methods
                                to obtain a reference to the underlying target object hidden behind one or more Spring proxies. For example, if you have configured a bean as a dynamic mock by using a library such as EasyMock or Mockito, and the mock is
                                wrapped in a Spring proxy, you may need direct access to the underlying mock to configure expectations on it and perform verifications. For Spring&#8217;s core AOP utilities, see <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/aop/support/AopUtils.html"><code>AopUtils</code></a>                                and
                                <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html"><code>AopProxyUtils</code></a>.</br>
                                <span class="translate">
                                AopTestUtils是一组与aop相关的实用程序方法。您可以使用这些方法获取隐藏在一个或多个Spring代理之后的底层目标对象的引用。
                                例如，如果您使用EasyMock或Mockito等库将一个bean配置为动态模拟，并且该模拟被封装在Spring代理中，那么您可能需要直接访问底层模拟，以配置对它的期望并执行验证。
                                关于Spring的核心AOP实用程序，请参阅AopUtils和AopProxyUtils。
                                </span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="unit-testing-spring-mvc"><a class="anchor" href="#unit-testing-spring-mvc"></a>2.2.2. Spring MVC Testing Utilities</h4>
                        <span>Spring MVC测试工具</span>
                        <div class="paragraph">
                            <p>The <code>org.springframework.test.web</code> package contains
                                <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html"><code>ModelAndViewAssert</code></a>, which you can use in combination with JUnit, TestNG, or
                                any other testing framework for unit tests that deal with Spring MVC <code>ModelAndView</code> objects.</br>
                                <span class="translate">
                                org.springframework.test.web包包含ModelAndViewAssert，您可以将其与JUnit、TestNG或任何其他测试框架结合使用，用于处理Spring MVC ModelAndView对象的单元测试。
                                </span>
                            </p>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        <div class="title">Unit testing Spring MVC Controllers</br>单元测试Spring MVC控制器</div>
                                        To unit test your Spring MVC <code>Controller</code> classes as POJOs, use <code>ModelAndViewAssert</code> combined with <code>MockHttpServletRequest</code>, <code>MockHttpSession</code>, and so on from Spring&#8217;s
                                        <a href="#mock-objects-servlet">Servlet API mocks</a>. For thorough integration testing of your Spring MVC and REST <code>Controller</code> classes in conjunction with your <code>WebApplicationContext</code> configuration
                                        for Spring MVC, use the
                                        <a href="#spring-mvc-test-framework">Spring MVC Test Framework</a> instead.</br>
                                        <span class="translate">
                                        要以pojo的形式对Spring MVC控制器类进行单元测试，可以使用ModelAndViewAssert结合MockHttpServletRequest、MockHttpSession等Spring的Servlet API模拟。
                                        为了将Spring MVC和REST Controller类与Spring MVC的WebApplicationContext配置进行彻底的集成测试，可以使用Spring MVC测试框架。
                                        </span>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="sect1">
            <h2 id="integration-testing"><a class="anchor" href="#integration-testing"></a>3. Integration Testing</h2>
            <span>3.集成测试</span>
            <div class="sectionbody">
                <div class="paragraph">
                    <p>This section (most of the rest of this chapter) covers integration testing for Spring applications. It includes the following topics:</br>
                        <span class="translate">
                        本节(本章剩余部分的大部分)介绍了Spring应用程序的集成测试。它包括以下主题:
                        </span>
                    </p>
                </div>
                <div class="ulist">
                    <ul>
                        <li>
                            <p><a href="#integration-testing-overview">Overview<span class="translate">[概述]</sapn></a></p>
                        </li>
                        <li>
                            <p><a href="#integration-testing-goals">Goals of Integration Testing<span class="translate">[集成测试的目标]</span></a></p>
                        </li>
                        <li>
                            <p><a href="#integration-testing-support-jdbc">JDBC Testing Support[]</a></p>
                        </li>
                        <li>
                            <p><a href="#integration-testing-annotations">Annotations<span class="translate">[注解]</span></a></p>
                        </li>
                        <li>
                            <p><a href="#testcontext-framework">Spring TestContext Framework[]</a></p>
                        </li>
                        <li>
                            <p><a href="#spring-mvc-test-framework">MockMvc</a></p>
                        </li>
                    </ul>
                </div>
                <div class="sect2">
                    <h3 id="integration-testing-overview"><a class="anchor" href="#integration-testing-overview"></a>3.1. Overview</h3>
                    <div class="paragraph">
                        <p>It is important to be able to perform some integration testing without requiring deployment to your application server or connecting to other enterprise infrastructure. Doing so lets you test things such as:</br>
                            <span class="translate">
                            能够在不需要部署到应用服务器或连接到其他企业基础设施的情况下执行一些集成测试是很重要的。这样做可以让你测试以下内容:
                            </span>
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p>The correct wiring of your Spring IoC container contexts.</br>
                                    Spring IoC容器上下文的正确连接。
                                </p>
                            </li>
                            <li>
                                <p>Data access using JDBC or an ORM tool. This can include such things as the correctness of SQL statements, Hibernate queries, JPA entity mappings, and so forth.</br>
                                    <span class="translate">
                                    使用JDBC或ORM工具进行数据访问。这可以包括SQL语句的正确性、Hibernate查询、JPA实体映射等等。
                                    </span>
                                </p>
                            </li>
                        </ul>
                    </div>
                    <div class="paragraph">
                        <p>
                            The Spring Framework provides first-class support for integration testing in the
                            <code>spring-test</code> module. The name of the actual JAR file might include the release version and might also be in the long <code>org.springframework.test</code> form, depending on where you get it from (see the <a href="core.html#dependency-management">section on Dependency Management</a>                            for an explanation). This library includes the <code>org.springframework.test</code> package, which contains valuable classes for integration testing with a Spring container. This testing does not rely on an application server
                            or other deployment environment. Such tests are slower to run than unit tests but much faster than the equivalent Selenium tests or remote tests that rely on deployment to an application server.</br>
                            <span class="translate">
                            Spring框架为Spring测试模块中的集成测试提供了一流的支持。
                            实际JAR文件的名称可能包括发布版本，也可能是长的org.springframework.test表单，这取决于您从哪里获得它(有关解释，请参阅依赖管理一节)。
                            这个库包括org.springframework.test包，其中包含用于与Spring容器集成测试的有价值的类。此测试不依赖于应用服务器或其他部署环境。这类测试运行起来比单元测试慢，
                            但比等价的Selenium测试或依赖于部署到应用服务器的远程测试快得多。
                            </span>
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>Unit and integration testing support is provided in the form of the annotation-driven
                            <a href="#testcontext-framework">Spring TestContext Framework</a>. The TestContext framework is agnostic of the actual testing framework in use, which allows instrumentation of tests in various environments, including JUnit,
                            TestNG, and others.</br>
                            <span class="translate">
                            单元和集成测试支持以注解驱动的Spring TestContext框架的形式提供。TestContext框架与正在使用的实际测试框架无关，它允许在各种环境中检测测试，包括JUnit、TestNG和其他环境。
                            </span>
                        </p>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="integration-testing-goals"><a class="anchor" href="#integration-testing-goals"></a>3.2. Goals of Integration Testing</h3>
                    <div class="paragraph">
                        <p>Spring&#8217;s integration testing support has the following primary goals:</br>
                            <span class="translate">
                            Spring的集成测试支持有以下主要目标:
                            </span>
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p>To manage <a href="#testing-ctx-management">Spring IoC container caching</a> between tests.</br>
                                    <span class="translate">
                                    管理测试之间的Spring IoC容器缓存。
                                    </span>
                                </p>
                            </li>
                            <li>
                                <p>To provide <a href="#testing-fixture-di">Dependency Injection of test fixture instances</a>.</br>
                                    <span class="translate">
                                    提供测试fixture实例的依赖项注入。
                                    </span>
                                </p>
                            </li>
                            <li>
                                <p>To provide <a href="#testing-tx">transaction management</a> appropriate to integration testing.</br>
                                    <span class="translate">
                                    提供适合于集成测试的事务管理。
                                    </span>
                                </p>
                            </li>
                            <li>
                                <p>To supply <a href="#testing-support-classes">Spring-specific base classes</a> that assist developers in writing integration tests.</br>
                                    <span class="translate">
                                    提供特定于spring的基类，以帮助开发人员编写集成测试。
                                    </span>
                                </p>
                            </li>
                        </ul>
                    </div>
                    <div class="paragraph">
                        <p>The next few sections describe each goal and provide links to implementation and configuration details.</br>
                            <span class="translate">
                            接下来的几个小节将描述每个目标，并提供指向实现和配置细节的链接。
                            </span>
                        </p>
                    </div>
                    <div class="sect3">
                        <h4 id="testing-ctx-management"><a class="anchor" href="#testing-ctx-management"></a>3.2.1. Context Management and Caching</h4>
                        <span>3.2.1. 上下文管理和缓存</span>
                        <div class="paragraph">
                            <p>
                                The Spring TestContext Framework provides consistent loading of Spring
                                <code>ApplicationContext</code> instances and <code>WebApplicationContext</code> instances as well as caching of those contexts. Support for the caching of loaded contexts is important, because startup time can become an
                                issue&#8201;&#8212;&#8201;not because of the overhead of Spring itself, but because the objects instantiated by the Spring container take time to instantiate. For example, a project with 50 to 100 Hibernate mapping files
                                might take 10 to 20 seconds to load the mapping files, and incurring that cost before running every test in every test fixture leads to slower overall test runs that reduce developer productivity.</br>
                                <span class="translate">
                                Spring TestContext框架提供了Spring ApplicationContext实例和WebApplicationContext实例的一致加载，以及这些上下文的缓存。
                                对已加载上下文的缓存的支持很重要，因为启动时间可能会成为一个问题——不是因为Spring本身的开销，而是因为Spring容器实例化的对象需要时间来实例化。
                                例如，一个有50到100个Hibernate映射文件的项目可能需要10到20秒来加载映射文件，并且在每个测试fixture中运行每个测试之前产生这个成本，这会导致整体测试运行变慢，从而降低开发人员的生产力。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                Test classes typically declare either an array of resource locations for XML or Groovy configuration metadata&#8201;&#8212;&#8201;often in the classpath&#8201;&#8212;&#8201;or an array of component classes that is used to configure
                                the application. These locations or classes are the same as or similar to those specified in <code>web.xml</code> or other configuration files for production deployments.</br>
                                <span class="translate">
                                测试类通常为XML或Groovy配置元数据(通常在类路径中)声明一组资源位置，或者为用于配置应用程序的组件类声明一组。这些位置或类与web.xml或其他用于生产部署的配置文件中指定的位置或类相同或类似。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                By default, once loaded, the configured <code>ApplicationContext</code> is reused for each test. Thus, the setup cost is incurred only once per test suite, and subsequent test execution is much faster. In this context, the
                                term &#8220;test suite&#8221; means all tests run in the same JVM&#8201;&#8212;&#8201;for example, all tests run from an Ant, Maven, or Gradle build for a given project or module. In the unlikely case that a test corrupts
                                the application context and requires reloading (for example, by modifying a bean definition or the state of an application object) the TestContext framework can be configured to reload the configuration and rebuild the
                                application context before executing the next test.</br>
                                <span class="translate">
                                默认情况下，一旦加载，配置的ApplicationContext将被每个测试重用。因此，每个测试套件只产生一次设置成本，并且后续的测试执行要快得多。
                                在这种情况下，术语“测试套件”意味着所有的测试运行在相同的JVM中——例如，所有的测试运行在一个给定项目或模块的Ant、Maven或Gradle构建中。
                                在测试破坏应用程序上下文并需要重新加载(例如，通过修改bean定义或应用程序对象的状态)的不太可能的情况下，
                                可以配置TestContext框架来重新加载配置并在执行下一个测试之前重新构建应用程序上下文。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                See <a href="#testcontext-ctx-management">Context Management</a> and <a href="#testcontext-ctx-management-caching">Context Caching</a> with the TestContext framework.</br>
                                <span class="translate">
                                请参阅TestContext框架的上下文管理和上下文缓存。
                                </span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testing-fixture-di"><a class="anchor" href="#testing-fixture-di"></a>3.2.2. Dependency Injection of Test Fixtures</h4>
                        <span class="translate">3.2.2. 测试既定的依赖注入</span>
                        <div class="paragraph">
                            <p>
                                When the TestContext framework loads your application context, it can optionally configure instances of your test classes by using Dependency Injection. This provides a convenient mechanism for setting up test fixtures by using
                                preconfigured beans from your application context. A strong benefit here is that you can reuse application contexts across various testing scenarios (for example, for configuring Spring-managed object graphs, transactional
                                proxies, <code>DataSource</code> instances, and others), thus avoiding the need to duplicate complex test fixture setup for individual test cases.</br>
                                <span class="translate">
                                当TestContext框架加载你的应用程序上下文时，它可以选择使用依赖注入配置你的测试类的实例。这提供了一种方便的机制，通过使用应用程序上下文中的预配置bean来设置测试fixture。
                                这里的一个强大好处是，您可以跨各种测试场景重用应用程序上下文(例如，用于配置spring管理的对象图、事务代理、数据源实例等)，从而避免为单个测试用例复制复杂的测试fixture设置。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                As an example, consider a scenario where we have a class (<code>HibernateTitleRepository</code>) that implements data access logic for a <code>Title</code> domain entity. We want to write integration tests that test the following
                                areas:</br>
                                <span class="translate">
                                例如，考虑这样一个场景:我们有一个类(HibernateTitleRepository)，它为Title域实体实现数据访问逻辑。我们想要编写测试以下领域的集成测试:
                                </span>
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>
                                        The Spring configuration: Basically, is everything related to the configuration of the
                                        <code>HibernateTitleRepository</code> bean correct and present?</br>
                                        <span class="translate">
                                        Spring配置:基本上，所有与HibernateTitleRepository bean配置相关的内容都正确且存在吗?
                                        </span>
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        The Hibernate mapping file configuration: Is everything mapped correctly and are the correct lazy-loading settings in place?
                                        Hibernate映射文件配置:所有映射是否正确，延迟加载设置是否正确?
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        The logic of the <code>HibernateTitleRepository</code>: Does the configured instance of this class perform as anticipated?</br>
                                        <span class="translate">
                                        HibernateTitleRepository的逻辑:这个类的配置实例是否按照预期执行?
                                        </span>
                                    </p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>See dependency injection of test fixtures with the
                                <a href="#testcontext-fixture-di">TestContext framework</a>.</br>
                                <span class="translate">
                                请参阅TestContext框架中的测试fixture依赖注入。
                                </span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testing-tx"><a class="anchor" href="#testing-tx"></a>3.2.3. Transaction Management</h4>
                        <span>3.2.3. 事务管理</span>
                        <div class="paragraph">
                            <p>
                                One common issue in tests that access a real database is their effect on the state of the persistence store. Even when you use a development database, changes to the state may affect future tests. Also, many operations&#8201;&#8212;&#8201;such
                                as inserting or modifying persistent data&#8201;&#8212;&#8201;cannot be performed (or verified) outside of a transaction.</br>
                                <span class="translate">
                                访问真实数据库的测试中的一个常见问题是它们对持久化存储状态的影响。
                                即使使用开发数据库，对状态的更改也可能影响未来的测试。此外，许多操作(如插入或修改持久数据)不能在事务之外执行(或验证)。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                The TestContext framework addresses this issue. By default, the framework creates and rolls back a transaction for each test. You can write code that can assume the existence of a transaction. If you call transactionally proxied
                                objects in your tests, they behave correctly, according to their configured transactional semantics. In addition, if a test method deletes the contents of selected tables while running within the transaction managed for
                                the test, the transaction rolls back by default, and the database returns to its state prior to execution of the test. Transactional support is provided to a test by using a <code>PlatformTransactionManager</code> bean
                                defined in the test&#8217;s application context.</br>
                                <span class="translate">
                                TestContext框架解决了这个问题。默认情况下，框架为每个测试创建并回滚一个事务。您可以编写假定存在事务的代码。
                                如果在测试中调用事务代理对象，则根据其配置的事务语义，它们的行为是正确的。此外，如果测试方法在为测试管理的事务中运行时删除所选表的内容，则事务默认回滚，数据库返回到执行测试之前的状态。
                                事务性支持是通过使用在测试的应用程序上下文中定义的PlatformTransactionManager bean提供给测试的。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                If you want a transaction to commit (unusual, but occasionally useful when you want a particular test to populate or modify the database), you can tell the TestContext framework to cause the transaction to commit instead of
                                roll back by using the
                                <a href="#integration-testing-annotations"><code>@Commit</code></a> annotation.</br>
                                <span class="translate">
                                如果您想要提交一个事务(不常见，但是当您想要一个特定的测试来填充或修改数据库时，偶尔有用)，您可以通过使用@Commit注释告诉TestContext框架来提交事务，而不是回滚事务。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                See transaction management with the <a href="#testcontext-tx">TestContext framework</a>.</br>
                                <span class="translate">
                                请参阅TestContext框架的事务管理。
                                </span>
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testing-support-classes"><a class="anchor" href="#testing-support-classes"></a>3.2.4. Support Classes for Integration Testing</h4>
                        <span class="translate">3.2.4. 支持集成测试类</span>
                        <div class="paragraph">
                            <p>The Spring TestContext Framework provides several <code>abstract</code> support classes that simplify the writing of integration tests. These base test classes provide well-defined hooks into the testing framework as well as
                                convenient instance variables and methods, which let you access:</br>
                                <span class="translate">
                                Spring TestContext框架提供了几个抽象支持类，它们简化了集成测试的编写。这些基本测试类提供了定义良好的挂钩到测试框架，以及方便的实例变量和方法，让你访问:
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>The <code>ApplicationContext</code>, for performing explicit bean lookups or testing the state of the context as a whole.</br>
                                        <span class="translate">
                                        ApplicationContext，用于执行显式的bean查找或测试整个上下文的状态。
                                    </p>
                                </li>
                                <li>
                                    <p>A <code>JdbcTemplate</code>, for executing SQL statements to query the database. You can use such queries to confirm database state both before and after execution of database-related application code, and Spring ensures
                                        that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.</br>
                                        <span class="translate">
                                        一个JdbcTemplate，用于执行查询数据库的SQL语句。您可以使用这些查询在执行与数据库相关的应用程序代码之前和之后确认数据库状态，Spring确保这些查询在与应用程序代码相同的事务范围内运行。当与ORM工具一起使用时，一定要避免误报。
                                    </p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>In addition, you may want to create your own custom, application-wide superclass with instance variables and methods specific to your project.</br>
                                <span class="translate">
                                此外，您可能希望使用特定于项目的实例变量和方法创建自己的自定义应用程序级超类。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>See support classes for the <a href="#testcontext-support-classes">TestContext framework</a>.</br>
                                <span class="translate">
                                参见TestContext框架的支持类。
                            </p>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="integration-testing-support-jdbc"><a class="anchor" href="#integration-testing-support-jdbc"></a>3.3. JDBC Testing Support</h3>
                    <div class="paragraph">
                        <p>The <code>org.springframework.test.jdbc</code> package contains <code>JdbcTestUtils</code>, which is a collection of JDBC-related utility functions intended to simplify standard database testing scenarios. Specifically, <code>JdbcTestUtils</code> provides the following static utility methods.</br>
                            <span class="translate">
                            <code>org.springframework.test.jdbc</code> 包包含JdbcTestUtils，它是jdbc相关的实用程序函数的集合，旨在简化标准数据库测试场景。具体来说，JdbcTestUtils提供了以下静态实用方法。
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p><code>countRowsInTable(..)</code>: Counts the number of rows in the given table.</br>
                                    <span class="translate">
                                    countRowsInTable(..):统计给定表中的行数。
                                </p>
                            </li>
                            <li>
                                <p><code>countRowsInTableWhere(..)</code>: Counts the number of rows in the given table by using the provided <code>WHERE</code> clause.</br>
                                    <span class="translate">
                                    countRowsInTableWhere(..):使用提供的WHERE子句计算给定表中的行数。
                                </p>
                            </li>
                            <li>
                                <p><code>deleteFromTables(..)</code>: Deletes all rows from the specified tables.</br>
                                    <span class="translate">
                                    deleteFromTables(..):删除指定表中的所有行。
                                </p>
                            </li>
                            <li>
                                <p><code>deleteFromTableWhere(..)</code>: Deletes rows from the given table by using the provided
                                    <code>WHERE</code> clause.</br>
                                    <span class="translate">
                                    deleteFromTableWhere(..):使用提供的WHERE子句删除给定表中的行。
                                </p>
                            </li>
                            <li>
                                <p><code>dropTables(..)</code>: Drops the specified tables.</br>
                                    <span class="translate">
                                    dropTables(..):删除指定的表。
                                </p>
                            </li>
                        </ul>
                    </div>
                    <div class="admonitionblock tip">
                        <table>
                            <tr>
                                <td class="icon">
                                    <i class="fa icon-tip" title="Tip"></i>
                                </td>
                                <td class="content">
                                    <div class="paragraph">
                                        <p><a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> and <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>                                            provide convenience methods that delegate to the aforementioned methods in
                                            <code>JdbcTestUtils</code>.</br>
                                            AbstractTransactionalJUnit4SpringContextTests 和 AbstractTransactionalTestNGSpringContextTests 提供了方便的方法，这些方法在JdbcTestUtils中委托给上述方法。
                                        </p>
                                    </div>
                                    <div class="paragraph">
                                        <p>
                                            The <code>spring-jdbc</code> module provides support for configuring and launching an embedded database, which you can use in integration tests that interact with a database. For details, see <a href="data-access.html#jdbc-embedded-database-support">Embedded Database
                                            Support</a> and <a href="data-access.html#jdbc-embedded-database-dao-testing">Testing Data Access Logic with an Embedded Database</a>.</br>
                                            <span class="translate">
                                            spring-jdbc模块提供了对配置和启动嵌入式数据库的支持，您可以在与数据库交互的集成测试中使用它。有关详细信息，请参见嵌入式数据库支持和用嵌入式数据库测试数据访问逻辑。
                                        </p>
                                    </div>
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="integration-testing-annotations"><a class="anchor" href="#integration-testing-annotations"></a>3.4. Annotations</h3>
                    <div class="paragraph">
                        <p>This section covers annotations that you can use when you test Spring applications. It includes the following topics:</br>
                            <span class="translate">
                            本节介绍在测试Spring应用程序时可以使用的注释。它包括以下主题:
                        </p>
                    </div>
                    <div class="ulist">
                        <ul>
                            <li>
                                <p><a href="#integration-testing-annotations-spring">Spring Testing Annotations</a></p>
                            </li>
                            <li>
                                <p><a href="#integration-testing-annotations-standard">Standard Annotation Support<span class="translate">[标准注释支持]</span></a></p>
                            </li>
                            <li>
                                <p><a href="#integration-testing-annotations-junit4">Spring JUnit 4 Testing Annotations</a></p>
                            </li>
                            <li>
                                <p><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a></p>
                            </li>
                            <li>
                                <p><a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing<span class="translate">[对测试的元注释支持]</span></a></p>
                            </li>
                        </ul>
                    </div>
                    <div class="sect3">
                        <h4 id="integration-testing-annotations-spring"><a class="anchor" href="#integration-testing-annotations-spring"></a>3.4.1. Spring Testing Annotations</h4>
                        <div class="paragraph">
                            <p>
                                The Spring Framework provides the following set of Spring-specific annotations that you can use
                                in your unit and integration tests in conjunction with the TestContext framework. See the corresponding javadoc for further information,
                                including default attribute values, attribute aliases, and other details.</br>
                                <span class="translate">
                                Spring框架提供了以下一组特定于Spring的注释，您可以在单元测试和集成测试中与TestContext框架一起使用这些注释。
                                有关更多信息，请参阅相应的javadoc，包括默认属性值、属性别名和其他详细信息。
                                </span>
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>Spring&#8217;s testing annotations include the following:</br>
                                <span class="translate">Spring的测试注释包括以下内容:</psan>
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-bootstrapwith"><a class="anchor" href="#spring-testing-annotation-bootstrapwith"></a><code>@BootstrapWith</code></h5>
                            <div class="paragraph">
                                <p><code>@BootstrapWith</code> is a class-level annotation that you can use to configure how the Spring TestContext Framework is bootstrapped. Specifically, you can use <code>@BootstrapWith</code> to specify a custom <code>TestContextBootstrapper</code>.
                                    See the section on
                                    <a href="#testcontext-bootstrapping">bootstrapping the TestContext framework</a> for further details.</br>
                                    <span class="translate">
                                    @BootstrapWith是一个类级注释，你可以用它来配置Spring TestContext框架是如何引导的。具体来说，你可以使用@BootstrapWith来指定一个自定义的TestContextBootstrapper。有关更多细节，请参见关于引导TestContext框架的一节。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-contextconfiguration"><a class="anchor" href="#spring-testing-annotation-contextconfiguration"></a><code>@ContextConfiguration</code></h5>
                            <div class="paragraph">
                                <p><code>@ContextConfiguration</code> defines class-level metadata that is used to determine how to load and configure an <code>ApplicationContext</code> for integration tests. Specifically,
                                    <code>@ContextConfiguration</code> declares the application context resource <code>locations</code> or the component <code>classes</code> used to load the context.</br>
                                    <span class="translate">
                                    @ContextConfiguration定义了类级元数据，用于确定如何为集成测试加载和配置ApplicationContext。具体来说，@ContextConfiguration声明应用程序上下文资源位置或用于加载上下文的组件类。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Resource locations are typically XML configuration files or Groovy scripts located in the classpath, while component classes are typically <code>@Configuration</code> classes. However, resource locations can also refer
                                    to files and scripts in the file system, and component classes can be <code>@Component</code> classes, <code>@Service</code> classes, and so on. See
                                    <a href="#testcontext-ctx-management-javaconfig-component-classes">Component Classes</a> for further details.</br>
                                    <span class="translate">
                                    资源位置通常是位于类路径中的XML配置文件或Groovy脚本，而组件类通常是@Configuration类。但是，资源位置也可以引用文件系统中的文件和脚本，组件类可以是@Component类、@Service类等等。更多细节请参见组件类。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows a <code>@ContextConfiguration</code> annotation that refers to an XML file:</br>
                                    <span class="translate">
                                    下面的例子显示了一个引用XML文件的@ContextConfiguration注释:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Referring to an XML file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Referring to an XML file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows a <code>@ContextConfiguration</code> annotation that refers to a class:</br>
                                    <span class="translate">
                                    下面的例子显示了一个引用类的@ContextConfiguration注释:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(classes = TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Referring to a class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(classes = [TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Referring to a class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>As an alternative or in addition to declaring resource locations or component classes, you can use <code>@ContextConfiguration</code> to declare <code>ApplicationContextInitializer</code> classes. The following example
                                    shows such a case:</br>
                                    <span class="translate">
                                    除了声明资源位置或组件类之外，还可以使用@ContextConfiguration声明ApplicationContextInitializer类。下面的例子展示了这种情况:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(initializers = CustomContextIntializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(initializers = [CustomContextIntializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Declaring an initializer class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can optionally use <code>@ContextConfiguration</code> to declare the <code>ContextLoader</code> strategy as well. Note, however, that you typically do not need to explicitly configure the loader, since the default loader
                                    supports <code>initializers</code> and either resource <code>locations</code> or component <code>classes</code>.</br>
                                    <span class="translate">
                                    你也可以选择使用@ContextConfiguration来声明ContextLoader策略。但是，请注意，您通常不需要显式地配置加载器，因为默认加载器支持初始化器、资源位置或组件类。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example uses both a location and a loader:</br>
                                    <span class="translate">
                                    下面的例子同时使用了location和loader:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuring both a location and a custom loader.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration("/test-context.xml", loader = CustomContextLoader::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuring both a location and a custom loader.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <code>@ContextConfiguration</code> provides support for inheriting resource locations or configuration classes as well as context initializers that are declared by superclasses or enclosing classes.</br>
<span class="translate">@ContextConfiguration支持继承资源位置或配置类，以及父类或封闭类声明的上下文初始化器。</span>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>See <a href="#testcontext-ctx-management">Context Management</a>,
                                    <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>, and the <code>@ContextConfiguration</code> javadocs for further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-webappconfiguration"><a class="anchor" href="#spring-testing-annotation-webappconfiguration"></a>
                                <code>@WebAppConfiguration</code>
                            </h5>
                            <div class="paragraph">
                                <p><code>@WebAppConfiguration</code> is a class-level annotation that you can use to declare that the
                                    <code>ApplicationContext</code> loaded for an integration test should be a <code>WebApplicationContext</code>. The mere presence of <code>@WebAppConfiguration</code> on a test class ensures that a
                                    <code>WebApplicationContext</code> is loaded for the test, using the default value of
                                    <code>"file:src/main/webapp"</code> for the path to the root of the web application (that is, the resource base path). The resource base path is used behind the scenes to create a
                                    <code>MockServletContext</code>, which serves as the <code>ServletContext</code> for the test&#8217;s
                                    <code>WebApplicationContext</code>.</br>
                                    <span class="translate">
                                    @WebAppConfiguration是一个类级注释，你可以用它来声明为集成测试加载的ApplicationContext应该是WebApplicationContext。
                                    在测试类中仅使用@WebAppConfiguration就可以确保为测试加载WebApplicationContext，
                                    使用“file:src/main/webapp”的默认值作为web应用程序的根路径(即资源基路径)。资源基路径在后台用于创建MockServletContext，它作为测试的WebApplicationContext的ServletContext。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to use the <code>@WebAppConfiguration</code> annotation:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>The <code>@WebAppConfiguration</code> annotation.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    To override the default, you can specify a different base resource path by using the implicit <code>value</code> attribute. Both <code>classpath:</code> and <code>file:</code> resource prefixes are supported. If no resource
                                    prefix is supplied, the path is assumed to be a file system resource. The following example shows how to specify a classpath resource:</br>
                                    <span class="translate">
                                    要覆盖默认值，可以使用隐式value属性指定不同的基本资源路径。支持类路径:和文件:资源前缀。如果没有提供资源前缀，则假定该路径是文件系统资源。下面的例子展示了如何指定一个类路径资源:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying a classpath resource.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying a classpath resource.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Note that <code>@WebAppConfiguration</code> must be used in conjunction with
                                    <code>@ContextConfiguration</code>, either within a single test class or within a test class hierarchy. See the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a> javadoc for further details.
                                    <span class="translate">
                                    注意，@WebAppConfiguration必须与@ContextConfiguration一起使用，无论是在单个测试类中还是在测试类层次结构中。更多细节请参见@WebAppConfiguration javadoc。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-contexthierarchy"><a class="anchor" href="#spring-testing-annotation-contexthierarchy"></a>
                                <code>@ContextHierarchy</code>
                            </h5>
                            <div class="paragraph">
                                <p>
                                    <code>@ContextHierarchy</code> is a class-level annotation that is used to define a hierarchy of
                                    <code>ApplicationContext</code> instances for integration tests. <code>@ContextHierarchy</code> should be declared with a list of one or more <code>@ContextConfiguration</code> instances, each of which defines a level
                                    in the context hierarchy. The following examples demonstrate the use of
                                    <code>@ContextHierarchy</code> within a single test class (<code>@ContextHierarchy</code> can also be used within a test class hierarchy):</br>
                                    <span class="translate">
                                    @ContextHierarchy是一个类级注释，用于定义集成测试的ApplicationContext实例的层次结构。
                                    @ContextHierarchy应该用一个或多个@ContextConfiguration实例的列表来声明，每个实例都定义了上下文层次结构中的一个级别。
                                    下面的例子演示了在单个测试类中使用@ContextHierarchy (@ContextHierarchy也可以在测试类层次结构中使用):
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
class ContextHierarchyTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@WebAppConfiguration
@ContextHierarchy(
        ContextConfiguration(classes = [AppConfig::class]),
        ContextConfiguration(classes = [WebConfig::class]))
class WebIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy,
                                    you must explicitly name that level by supplying the same value to the <code>name</code> attribute
                                    in <code>@ContextConfiguration</code> at each corresponding level in the class hierarchy.
                                    See <a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a> and the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/ContextHierarchy.html">
                                    <code>@ContextHierarchy</code></a> javadoc for further examples.</br>
                                    <span class="translate">
                                    如果您需要在测试类层次结构中合并或覆盖上下文层次结构的给定级别的配置，您必须通过在类层次结构中每个相应级别上为@ContextConfiguration中的name属性提供相同的值来显式地命名该级别。
                                    更多示例请参见上下文层次结构和@ContextHierarchy javadoc。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-activeprofiles"><a class="anchor" href="#spring-testing-annotation-activeprofiles"></a><code>@ActiveProfiles</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@ActiveProfiles</code> is a class-level annotation that is used to declare which bean definition profiles should be active when loading an <code>ApplicationContext</code> for an integration test.</br>
                                    <span class="translate">
                                    @ActiveProfiles是一个类级注释，用于声明在为集成测试加载ApplicationContext时应该激活哪个bean定义概要文件。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example indicates that the <code>dev</code> profile should be active:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Indicate that the <code>dev</code> profile should be active.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Indicate that the <code>dev</code> profile should be active.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The following example indicates that both the <code>dev</code> and the <code>integration</code> profiles should be active:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Indicate that the <code>dev</code> and <code>integration</code> profiles should be active.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@ActiveProfiles(["dev", "integration"]) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Indicate that the <code>dev</code> and <code>integration</code> profiles should be active.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <code>@ActiveProfiles</code> provides support for inheriting active bean definition profiles declared by superclasses and enclosing classes by default. You can also resolve active bean definition profiles programmatically
                                            by implementing a custom
                                            <a href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code>ActiveProfilesResolver</code></a> and registering it by using the <code>resolver</code> attribute of <code>@ActiveProfiles</code>.<br>
<span class="translate">@ActiveProfiles默认情况下支持继承父类和封闭类声明的活动bean定义配置文件。您还可以通过实现自定义ActiveProfilesResolver并使用@ActiveProfiles的resolver属性注册它来程序化解析活动bean定义概要文件。</span>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>See <a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a>,
                                    <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>, and the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/ActiveProfiles.html"><code>@ActiveProfiles</code></a> javadoc for examples and further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-testpropertysource"><a class="anchor" href="#spring-testing-annotation-testpropertysource"></a>
                                <code>@TestPropertySource</code>
                            </h5>
                            <div class="paragraph">
                                <p>
                                    <code>@TestPropertySource</code> is a class-level annotation that you can use to configure the locations of properties files and inlined properties to be added to the set of
                                    <code>PropertySources</code> in the <code>Environment</code> for an <code>ApplicationContext</code> loaded for an integration test.</br>
                                    <span class="translate">
                                    @TestPropertySource是一个类级注释，您可以使用它来配置属性文件和内联属性的位置，这些属性将被添加到为集成测试加载的ApplicationContext的propertysource集中。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example demonstrates how to declare a properties file from the classpath:</br>
                                    <span class="translate">
                                    下面的例子演示了如何声明内联属性:
                                    </span>
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Get properties from <code>test.properties</code> in the root of the classpath.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Get properties from <code>test.properties</code> in the root of the classpath.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The following example demonstrates how to declare inlined properties:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Declare <code>timezone</code> and <code>port</code> properties.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Declare <code>timezone</code> and <code>port</code> properties.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>See <a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a> for examples and further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-dynamicpropertysource"><a class="anchor" href="#spring-testing-annotation-dynamicpropertysource"></a><code>@DynamicPropertySource</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@DynamicPropertySource</code> is a method-level annotation that you can use to register
                                    <em>dynamic</em> properties to be added to the set of <code>PropertySources</code> in the <code>Environment</code> for an <code>ApplicationContext</code> loaded for an integration test. Dynamic properties are useful
                                    when you do not know the value of the properties upfront – for example, if the properties are managed by an external resource such as for a container managed by the
                                    <a href="https://www.testcontainers.org/">Testcontainers</a> project.</br>
                                    <span class="translate">
                                    @DynamicPropertySource是一个方法级注释，您可以使用它来注册动态属性，将其添加到为集成测试加载的ApplicationContext的propertysource集中。
                                    当您事先不知道属性的值时，动态属性非常有用——例如，如果属性是由外部资源管理的，例如由Testcontainers项目管理的容器。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example demonstrates how to register a dynamic property:</br>
                                    <span class="translate">
                                    下面的例子演示了如何注册一个动态属性:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
class MyIntegrationTests {

    static MyExternalServer server = // ...

    @DynamicPropertySource <i class="conum" data-value="1"></i><b>(1)</b>
    static void dynamicProperties(DynamicPropertyRegistry registry) { <i class="conum" data-value="2"></i><b>(2)</b>
        registry.add("server.port", server::getPort); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // tests ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Annotate a <code>static</code> method with <code>@DynamicPropertySource</code>.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Accept a <code>DynamicPropertyRegistry</code> as an argument.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Register a dynamic <code>server.port</code> property to be retrieved lazily from the server.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
class MyIntegrationTests {

    companion object {

        @JvmStatic
        val server: MyExternalServer = // ...

        @DynamicPropertySource <i class="conum" data-value="1"></i><b>(1)</b>
        @JvmStatic
        fun dynamicProperties(registry: DynamicPropertyRegistry) { <i class="conum" data-value="2"></i><b>(2)</b>
            registry.add("server.port", server::getPort) <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }

    // tests ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Annotate a <code>static</code> method with <code>@DynamicPropertySource</code>.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Accept a <code>DynamicPropertyRegistry</code> as an argument.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Register a dynamic <code>server.port</code> property to be retrieved lazily from the server.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>See <a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a> for further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-dirtiescontext"><a class="anchor" href="#spring-testing-annotation-dirtiescontext"></a><code>@DirtiesContext</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@DirtiesContext</code> indicates that the underlying Spring <code>ApplicationContext</code> has been dirtied during the execution of a test (that is, the test modified or corrupted it in some manner&#8201;&#8212;&#8201;for
                                    example, by changing the state of a singleton bean) and should be closed. When an application context is marked as dirty, it is removed from the testing framework&#8217;s cache and closed. As a consequence, the underlying
                                    Spring container is rebuilt for any subsequent test that requires a context with the same configuration metadata.</br>
                                    <span class="translate">
                                    @DirtiesContext表示底层的Spring ApplicationContext在测试执行期间被污染了(也就是说，测试以某种方式修改或破坏了它——例如，通过改变单例bean的状态)，应该被关闭。
                                    当应用程序上下文被标记为dirty时，它将从测试框架的缓存中删除并关闭。因此，底层Spring容器将为需要具有相同配置元数据的上下文的任何后续测试重新构建。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can use <code>@DirtiesContext</code> as both a class-level and a method-level annotation within the same class or class hierarchy. In such scenarios, the <code>ApplicationContext</code> is marked as dirty before or
                                    after any such annotated method as well as before or after the current test class, depending on the configured <code>methodMode</code> and <code>classMode</code>.</br>
                                    <span class="translate">
                                    您可以使用@DirtiesContext作为同一类或类层次结构中的类级和方法级注释。
                                    在这种情况下，ApplicationContext被标记为dirty，在任何这样的注释方法之前或之后，以及在当前测试类之前或之后，这取决于配置的methodMode和classMode。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following examples explain when the context would be dirtied for various configuration scenarios:</br>
                                    <span class="translate">
                                    下面的例子解释了在不同的配置场景下什么时候会被污染:
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>Before the current test class, when declared on a class with class mode set to
                                            <code>BEFORE_CLASS</code>.</br>
                                            <span class="translate">
                                            在类模式设置为BEFORE_CLASS的类上声明时，在当前测试类之前。
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before the current test class.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before the current test class.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                    <li>
                                        <p>
                                            After the current test class, when declared on a class with class mode set
                                            to <code>AFTER_CLASS</code> (i.e., the default class mode).</br>
                                            <span class="translate">
                                            在当前测试类之后，在类模式设置为AFTER_CLASS(即默认的类模式)的类上声明。
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after the current test class.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after the current test class.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                    <li>
                                        <p>
                                            Before each test method in the current test class, when declared on a class with class mode set to <code>BEFORE_EACH_TEST_METHOD.</code></br>
                                            <span class="translate">
                                            在类模式设置为的类上声明时，在当前测试类中的每个测试方法之前
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before each test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before each test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                    <li>
                                        <p>
                                            After each test method in the current test class, when declared on a class with class mode set to <code>AFTER_EACH_TEST_METHOD.</code></br>
                                            <span class="translate">
                                            当在类模式设置为AFTER_EACH_TEST_METHOD的类上声明当前测试类中的每个测试方法后。
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after each test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after each test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                    <li>
                                        <p>Before the current test, when declared on a method with the method mode set to
                                            <code>BEFORE_METHOD</code>.</br>
                                            <span class="translate">
                                            在当前测试之前，在方法模式设置为BEFORE_METHOD的方法上声明。
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before the current test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context before the current test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                    <li>
                                        <p>
                                            After the current test, when declared on a method with the method mode set to
                                            <code>AFTER_METHOD</code> (i.e., the default method mode).</br>
                                            <span class="translate">
                                            在当前测试之后，当方法模式设置为AFTER_METHOD(即默认的方法模式)时，在方法上声明。
                                        </p>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after the current test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Dirty the context after the current test method.</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If you use <code>@DirtiesContext</code> in a test whose context is configured as part of a context hierarchy with <code>@ContextHierarchy</code>, you can use the <code>hierarchyMode</code> flag to control how the context
                                    cache is cleared. By default, an exhaustive algorithm is used to clear the context cache, including not only the current level but also all other context hierarchies that share an ancestor context common to the current
                                    test. All <code>ApplicationContext</code> instances that reside in a sub-hierarchy of the common ancestor context are removed from the context cache and closed. If the exhaustive algorithm is overkill for a particular use case,
                                    you can specify the simpler current level algorithm, as the following example shows.</br>
                                    <span class="translate">
                                    如果你在一个测试中使用@DirtiesContext，它的上下文被配置为@ContextHierarchy的上下文层次结构的一部分，你可以使用hierarchyMode标志来控制上下文缓存是如何被清除的。
                                    默认情况下，将使用穷举算法来清除上下文缓存，不仅包括当前级别，还包括共享与当前测试共用的祖先上下文的所有其他上下文层次结构。
                                    所有驻留在公共祖先上下文的子层次结构中的ApplicationContext实例将从上下文缓存中删除并关闭。如果穷举算法对于特定用例来说过于复杂，那么可以指定更简单的当前级别算法，如下面的示例所示。
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    void test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Use the current-level algorithm.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
open class BaseTests {
    // class body...
}

class ExtendedTests : BaseTests() {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    fun test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Use the current-level algorithm.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    For further details regarding the <code>EXHAUSTIVE</code> and <code>CURRENT_LEVEL</code> algorithms, see the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html"><code>DirtiesContext.HierarchyMode</code></a> javadoc.</br>
                                    <span class="translate">关于穷举和CURRENT_LEVEL算法的更多细节，请参阅DirtiesContext。HierarchyMode javadoc。</span>
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-testexecutionlisteners"><a class="anchor" href="#spring-testing-annotation-testexecutionlisteners"></a><code>@TestExecutionListeners</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@TestExecutionListeners</code> defines class-level metadata for configuring the
                                    <code>TestExecutionListener</code> implementations that should be registered with the
                                    <code>TestContextManager</code>. Typically, <code>@TestExecutionListeners</code> is used in conjunction with
                                    <code>@ContextConfiguration</code>.</br>
                                    <span class="translate">
                                    @TestExecutionListener定义了类级元数据，用于配置TestExecutionListener实现，这些实现应该注册到TestContextManager中。
                                    通常，@ testexecutionlistener与@ContextConfiguration一起使用。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to register two <code>TestExecutionListener</code> implementations:</br>
                                    <span class="translate">
                                    下面的例子展示了如何注册两个TestExecutionListener实现:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Register two <code>TestExecutionListener</code> implementations.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Register two <code>TestExecutionListener</code> implementations.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    By default, <code>@TestExecutionListeners</code> provides support for inheriting listeners from superclasses or enclosing classes. See
                                    <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a> and the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code> javadoc</a> for an example and further details.</br>
                                    <span class="translate">
                                    默认情况下，@TestExecutionListeners提供了从超类或封闭类继承侦听器的支持。参见@嵌套测试类配置和@ testexecutionlistener javadoc获得示例和更多细节。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-recordapplicationevents"><a class="anchor" href="#spring-testing-annotation-recordapplicationevents"></a><code>@RecordApplicationEvents</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@RecordApplicationEvents</code> is a class-level annotation that is used to instruct the
                                    <em>Spring TestContext Framework</em> to record all application events that are published in the
                                    <code>ApplicationContext</code> during the execution of a single test.</br>
                                    <span class="translate">
                                    @RecordApplicationEvents是一个类级注释，用于指示Spring TestContext框架记录在单个测试执行期间发布在ApplicationContext中的所有应用程序事件。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The recorded events can be accessed via the <code>ApplicationEvents</code> API within tests.</br>
                                    <span class="translate">
                                    记录的事件可以通过测试中的ApplicationEvents API访问。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>See <a href="#testcontext-application-events">Application Events</a> and the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/event/RecordApplicationEvents.html">
                                    <code>@RecordApplicationEvents</code> javadoc</a> for an example and further details.</br>
                                    <span class="translate">
                                    请参阅应用程序事件和@RecordApplicationEvents javadoc以获得示例和进一步的详细信息。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-commit"><a class="anchor" href="#spring-testing-annotation-commit"></a><code>@Commit</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@Commit</code> indicates that the transaction for a transactional test method should be committed after the test method has completed. You can use <code>@Commit</code> as a direct replacement for <code>@Rollback(false)</code>                                    to more explicitly convey the intent of the code. Analogous to <code>@Rollback</code>, <code>@Commit</code> can also be declared as a class-level or method-level annotation.</br>
                                    <span class="translate">
                                    @Commit表示事务测试方法的事务应该在测试方法完成后提交。您可以使用@Commit作为@Rollback(false)的直接替代，以更明确地传达代码的意图。与@Rollback类似，@Commit也可以声明为类级或方法级注释。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to use the <code>@Commit</code> annotation:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@Commit注释:
                                </p>

                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Commit the result of the test to the database.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Commit the result of the test to the database.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-rollback"><a class="anchor" href="#spring-testing-annotation-rollback"></a><code>@Rollback</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@Rollback</code> indicates whether the transaction for a transactional test method should be rolled back after the test method has completed. If <code>true</code>, the transaction is rolled back. Otherwise, the transaction
                                    is committed (see also
                                    <a href="#spring-testing-annotation-commit"><code>@Commit</code></a>). Rollback for integration tests in the Spring TestContext Framework defaults to <code>true</code> even if <code>@Rollback</code> is not explicitly
                                    declared.</br>
                                    <span class="translate">
                                    @Rollback指示在测试方法完成后，是否应该回滚事务测试方法的事务。如果为true，则回滚事务。
                                    否则，事务将被提交(参见@Commit)。即使没有显式地声明@Rollback, Spring TestContext框架中集成测试的回滚也默认为true。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    When declared as a class-level annotation, <code>@Rollback</code> defines the default rollback semantics for
                                    all test methods within the test class hierarchy. When declared as a method-level annotation, <code>@Rollback</code>
                                    defines rollback semantics for the specific test method, potentially overriding class-level <code>@Rollback</code> or <code>@Commit</code> semantics.</br>
                                    <span class="translate">
                                    当声明为类级注释时，@Rollback为测试类层次结构中的所有测试方法定义了默认的回滚语义。当声明为方法级注释时，
                                    @Rollback定义了特定测试方法的回滚语义，可能覆盖类级的@Rollback或@Commit语义。
                                    </span>
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example causes a test method&#8217;s result to not be rolled back (that is, the result is committed to the database):</br>
                                    <span class="translate">
                                    下面的例子导致测试方法的结果不被回滚(也就是说，结果被提交到数据库):
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Do not roll back the result.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Do not roll back the result.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-beforetransaction"><a class="anchor" href="#spring-testing-annotation-beforetransaction"></a><code>@BeforeTransaction</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@BeforeTransaction</code> indicates that the annotated <code>void</code> method should be run before a transaction is started, for test methods that have been configured to run within a transaction by using Spring&#8217;s
                                    <code>@Transactional</code> annotation. <code>@BeforeTransaction</code> methods are not required to be <code>public</code> and may be declared on Java 8-based interface default methods.</br>
                                    <span class="translate">
                                    @BeforeTransaction表示在事务启动之前应该运行带注释的void方法，因为测试方法通过使用Spring的@Transactional注释被配置为在事务中运行。@BeforeTransaction方法不需要是公共的，可以在基于Java 8接口的默认方法上声明。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to use the <code>@BeforeTransaction</code> annotation:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@BeforeTransaction注释:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void beforeTransaction() {
    // logic to be run before a transaction is started
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this method before a transaction.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun beforeTransaction() {
    // logic to be run before a transaction is started
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this method before a transaction.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-aftertransaction"><a class="anchor" href="#spring-testing-annotation-aftertransaction"></a><code>@AfterTransaction</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@AfterTransaction</code> indicates that the annotated <code>void</code> method should be run after a transaction is ended, for test methods that have been configured to run within a transaction by using Spring&#8217;s
                                    <code>@Transactional</code> annotation. <code>@AfterTransaction</code> methods are not required to be <code>public</code> and may be declared on Java 8-based interface default methods.</br>
                                    <span class="translate">
                                    @AfterTransaction表示在事务结束后应该运行带注释的void方法，用于使用Spring的@Transactional注释在事务中运行的测试方法。@AfterTransaction方法不需要是公共的，可以在基于Java 8接口的默认方法上声明。
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void afterTransaction() {
    // logic to be run after a transaction has ended
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this method after a transaction.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun afterTransaction() {
    // logic to be run after a transaction has ended
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this method after a transaction.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-sql"><a class="anchor" href="#spring-testing-annotation-sql"></a><code>@Sql</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@Sql</code> is used to annotate a test class or test method to configure SQL scripts to be run against a given database during integration tests. The following example shows how to use it:</br>
                                     <span class="translate">
                                     @Sql用于注释测试类或测试方法，以配置在集成测试期间针对给定数据库运行的SQL脚本。下面的例子展示了如何使用它:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) <i class="conum" data-value="1"></i><b>(1)</b>
void userTest() {
    // run code that relies on the test schema and test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run two scripts for this test.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@Sql("/test-schema.sql", "/test-user-data.sql") <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // run code that relies on the test schema and test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run two scripts for this test.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    See <a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a> for further details.</br>
                                    <span class="translate">
                                    有关详细信息，请参见使用@Sql声明式执行SQL脚本。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-sqlconfig"><a class="anchor" href="#spring-testing-annotation-sqlconfig"></a><code>@SqlConfig</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@SqlConfig</code> defines metadata that is used to determine how to parse and run SQL scripts configured with the <code>@Sql</code> annotation. The following example shows how to use it:</br>
                                    <span class="translate">
                                    @SqlConfig定义元数据，用于确定如何解析和运行使用@Sql注释配置的SQL脚本。下面的例子展示了如何使用它:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") <i class="conum" data-value="1"></i><b>(1)</b>
)
void userTest() {
    // run code that relies on the test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the comment prefix and the separator in SQL scripts.</br><span class="translate">在SQL脚本中设置注释前缀和分隔符。</br></td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@Sql("/test-user-data.sql", config = SqlConfig(commentPrefix = "`", separator = "@@")) <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // run code that relies on the test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the comment prefix and the separator in SQL scripts.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-sqlmergemode"><a class="anchor" href="#spring-testing-annotation-sqlmergemode"></a><code>@SqlMergeMode</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@SqlMergeMode</code> is used to annotate a test class or test method to configure whether method-level <code>@Sql</code> declarations are merged with class-level <code>@Sql</code> declarations. If
                                    <code>@SqlMergeMode</code> is not declared on a test class or test method, the <code>OVERRIDE</code> merge mode will be used by default. With the <code>OVERRIDE</code> mode, method-level <code>@Sql</code> declarations
                                    will effectively override class-level <code>@Sql</code> declarations.</br>
                                    <span class="translate">
                                    @SqlMergeMode用于注释测试类或测试方法，以配置方法级@Sql声明是否与类级@Sql声明合并。如果没有在测试类或测试方法上声明@SqlMergeMode，则默认情况下将使用OVERRIDE合并模式。
                                    使用OVERRIDE模式，方法级的@Sql声明将有效地覆盖类级的@Sql声明。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>Note that a method-level <code>@SqlMergeMode</code> declaration overrides a class-level declaration.</br>
                                    <span class="translate">
                                    注意，方法级的@SqlMergeMode声明覆盖了类级声明。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example shows how to use <code>@SqlMergeMode</code> at the class level.</br>
                                    <span class="translate">
                                    下面的示例展示了如何在类级别上使用@SqlMergeMode。
                                </p>

                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for all test methods in the class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    fun standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for all test methods in the class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example shows how to use <code>@SqlMergeMode</code> at the method level.</br>
                                    <span class="translate">
                                    下面的示例展示了如何在方法级别使用@SqlMergeMode。
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for a specific test method.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    fun standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for a specific test method.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-testing-annotation-sqlgroup"><a class="anchor" href="#spring-testing-annotation-sqlgroup"></a><code>@SqlGroup</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@SqlGroup</code> is a container annotation that aggregates several <code>@Sql</code> annotations. You can use <code>@SqlGroup</code> natively to declare several nested <code>@Sql</code> annotations, or you can use
                                    it in conjunction with Java 8&#8217;s support for repeatable annotations, where <code>@Sql</code> can be declared several times on the same class or method, implicitly generating this container annotation. The following
                                    example shows how to declare an SQL group:</br>
                                    <span class="translate">
                                    @SqlGroup是一个容器注释，它聚集了多个@Sql注释。
                                    您可以原生地使用@SqlGroup来声明几个嵌套的@Sql注释，或者您可以将它与Java 8对可重复注释的支持结合使用，在Java 8中，可以在同一类或方法上多次声明@Sql，从而隐式地生成这个容器注释。
                                    下面的例子展示了如何声明一个SQL组:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@SqlGroup({ <i class="conum" data-value="1"></i><b>(1)</b>
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Declare a group of SQL scripts.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup( <i class="conum" data-value="1"></i><b>(1)</b>
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // run code that uses the test schema and test data
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Declare a group of SQL scripts.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="integration-testing-annotations-standard"><a class="anchor" href="#integration-testing-annotations-standard"></a>
                            3.4.2. Standard Annotation Support
                        </h4>
                        <span>3.4.2. 标准注释支持</span>
                        <div class="paragraph">
                            <p>
                                The following annotations are supported with standard semantics for all configurations of the Spring TestContext Framework. Note that these annotations are not specific to tests and can be used anywhere in the Spring Framework.</br>
                                <span class="translate">
                                Spring TestContext框架的所有配置都支持以下注释的标准语义。请注意，这些注释不是特定于测试的，可以在Spring框架的任何地方使用。
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>@Autowired</code></p>
                                </li>
                                <li>
                                    <p><code>@Qualifier</code></p>
                                </li>
                                <li>
                                    <p><code>@Value</code></p>
                                </li>
                                <li>
                                    <p><code>@Resource</code> (javax.annotation) if JSR-250 is present</p>
                                </li>
                                <li>
                                    <p><code>@ManagedBean</code> (javax.annotation) if JSR-250 is present</p>
                                </li>
                                <li>
                                    <p><code>@Inject</code> (javax.inject) if JSR-330 is present</p>
                                </li>
                                <li>
                                    <p><code>@Named</code> (javax.inject) if JSR-330 is present</p>
                                </li>
                                <li>
                                    <p><code>@PersistenceContext</code> (javax.persistence) if JPA is present</p>
                                </li>
                                <li>
                                    <p><code>@PersistenceUnit</code> (javax.persistence) if JPA is present</p>
                                </li>
                                <li>
                                    <p><code>@Required</code></p>
                                </li>
                                <li>
                                    <p><code>@Transactional</code> (org.springframework.transaction.annotation)
                                        <em>with <a href="#testcontext-tx-attribute-support">limited attribute support</a></em></p>
                                </li>
                            </ul>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        <div class="title">JSR-250 Lifecycle Annotations</div>
                                        <div class="paragraph">
                                            <p>
                                                In the Spring TestContext Framework, you can use <code>@PostConstruct</code> and <code>@PreDestroy</code> with standard semantics on any application components configured in the <code>ApplicationContext</code>.
                                                However, these lifecycle annotations have limited usage within an actual test class.</br>
                                                <span class="translate">
                                                在Spring TestContext框架中，你可以在ApplicationContext中配置的任何应用组件上使用带有标准语义的@PostConstruct和@PreDestroy。然而，这些生命周期注释在实际的测试类中使用有限。
                                            </p>
                                        </div>
                                        <div class="paragraph">
                                            <p>
                                                If a method within a test class is annotated with <code>@PostConstruct</code>, that method runs before any before methods of the underlying test framework (for example, methods annotated with JUnit Jupiter&#8217;s
                                                <code>@BeforeEach</code>), and that applies for every test method in the test class. On the other hand, if a method within a test class is annotated with
                                                <code>@PreDestroy</code>, that method never runs. Therefore, within a test class, we recommend that you use test lifecycle callbacks from the underlying test framework instead of
                                                <code>@PostConstruct</code> and <code>@PreDestroy</code>.</br>
                                                <span class="translate">
                                                如果测试类中的一个方法注释了@PostConstruct，那么该方法运行在底层测试框架的任何before方法之前(例如，用JUnit Jupiter的@BeforeEach注释的方法)，并且该方法适用于测试类中的每个测试方法。
                                                另一方面，如果测试类中的一个方法被注释为@PreDestroy，那么这个方法永远不会运行。
                                                因此，在一个测试类中，我们建议您使用来自底层测试框架的测试生命周期回调，而不是@PostConstruct和@PreDestroy。
                                            </p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="integration-testing-annotations-junit4"><a class="anchor" href="#integration-testing-annotations-junit4"></a>3.4.3. Spring JUnit 4 Testing Annotations</h4>
                        <div class="paragraph">
                            <p>The following annotations are supported only when used in conjunction with the
                                <a href="#testcontext-junit4-runner">SpringRunner</a>,
                                <a href="#testcontext-junit4-rules">Spring&#8217;s JUnit 4 rules</a>,
                                or <a href="#testcontext-support-classes-junit4">Spring&#8217;s JUnit 4 support classes</a>:<br>
                                <span class="translate">
                                只有在与
                                 <a href="#testcontext-junit4-runner">SpringRunner</a>,
                                 <a href="#testcontext-junit4-rules">Spring&#8217;s JUnit 4 rules</a>,或
                                 <a href="#testcontext-support-classes-junit4">Spring&#8217;s JUnit 4 support classes</a>
                                 一起使用时，才支持以下注释:
                                 </span>
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit4-ifprofilevalue"><a class="anchor" href="#integration-testing-annotations-junit4-ifprofilevalue"></a><code>@IfProfileValue</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@IfProfileValue</code> indicates that the annotated test is enabled for a specific testing environment.
                                    If the configured <code>ProfileValueSource</code> returns a matching <code>value</code> for the provided <code>name</code>,
                                    the test is enabled. Otherwise, the test is disabled and, effectively, ignored.</br>
                                    <span class="translate">
                                    @IfProfileValue表示为特定的测试环境启用了注释测试。如果配置的ProfileValueSource为提供的名称返回匹配的值，则启用测试。否则，测试将被禁用，并且被忽略。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can apply <code>@IfProfileValue</code> at the class level, the method level, or both. Class-level usage of <code>@IfProfileValue</code> takes precedence over method-level usage for any methods within that class or its
                                    subclasses. Specifically, a test is enabled if it is enabled both at the class level and at the method level. The absence of <code>@IfProfileValue</code> means the test is implicitly enabled. This is analogous to the
                                    semantics of JUnit 4&#8217;s
                                    <code>@Ignore</code> annotation, except that the presence of <code>@Ignore</code> always disables a test.</br>
                                    <span class="translate">
                                    您可以在类级别、方法级别或两者都应用@IfProfileValue。对于该类或其子类中的任何方法，类级别@IfProfileValue的使用优先于方法级别的使用。
                                    具体来说，如果一个测试在类级别和方法级别都被启用，那么它就被启用。没有@IfProfileValue意味着测试是隐式启用的。
                                    这类似于JUnit 4的@Ignore注释的语义，只是@Ignore的存在总是禁用测试。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example shows a test that has an <code>@IfProfileValue</code> annotation:</br>
                                    <span class="translate">
                                    下面的例子展示了一个带有@IfProfileValue注释的测试:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this test only when the Java vendor is "Oracle Corporation".</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this test only when the Java vendor is "Oracle Corporation".</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Alternatively, you can configure <code>@IfProfileValue</code> with a list of <code>values</code> (with <code>OR</code> semantics)
                                    to achieve TestNG-like support for test groups in a JUnit 4 environment. Consider the following example:</br>
                                    <span class="translate">
                                    或者，您可以使用一组值(带有OR语义)配置@IfProfileValue，以在JUnit 4环境中实现对测试组的类似testng的支持。考虑以下例子:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this test for unit tests and integration tests.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@IfProfileValue(name="test-groups", values=["unit-tests", "integration-tests"]) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Run this test for unit tests and integration tests.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit4-profilevaluesourceconfiguration"><a class="anchor" href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"></a><code>@ProfileValueSourceConfiguration</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@ProfileValueSourceConfiguration</code> is a class-level annotation that specifies what type of <code>ProfileValueSource</code> to use when retrieving profile values configured through the
                                    <code>@IfProfileValue</code> annotation. If <code>@ProfileValueSourceConfiguration</code> is not declared for a test, <code>SystemProfileValueSource</code> is used by default. The following example shows how to use
                                    <code>@ProfileValueSourceConfiguration</code>:</br>
                                    <span class="translate">
                                    @ProfileValueSourceConfiguration是一个类级注释，它指定在检索通过@IfProfileValue注释配置的概要值时使用何种类型的ProfileValueSource。
                                    如果没有为测试声明@ profilevaluesourceconconfiguration，则默认使用SystemProfileValueSource。
                                    下面的例子展示了如何使用@ profilevaluesourcecconfigurconfiguration:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ProfileValueSourceConfiguration(CustomProfileValueSource.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Use a custom profile value source.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ProfileValueSourceConfiguration(CustomProfileValueSource::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Use a custom profile value source.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit4-timed"><a class="anchor" href="#integration-testing-annotations-junit4-timed"></a><code>@Timed</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@Timed</code> indicates that the annotated test method must finish execution in a specified time period (in milliseconds). If the text execution time exceeds the specified time period, the test fails.</br>
                                    <span class="translate">
                                    @Timed表示带注释的测试方法必须在指定的时间段内(以毫秒为单位)完成执行。如果文本执行时间超过指定的时间范围，则测试失败。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The time period includes running the test method itself, any repetitions of the test (see
                                    <code>@Repeat</code>), as well as any setting up or tearing down of the test fixture. The following example shows how to use it:</br>
                                    <span class="translate">
                                    时间周期包括运行测试方法本身，测试的任何重复(参见@Repeat)，以及测试夹具的任何设置或拆卸。下面的例子展示了如何使用它:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
public void testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to run
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the time period for the test to one second.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
fun testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to run
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Set the time period for the test to one second.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Spring&#8217;s <code>@Timed</code> annotation has different semantics than JUnit 4&#8217;s <code>@Test(timeout=&#8230;&#8203;)</code> support. Specifically, due to the manner in which JUnit 4 handles test execution timeouts
                                    (that is, by executing the test method in a separate <code>Thread</code>), <code>@Test(timeout=&#8230;&#8203;)</code> preemptively fails the test if the test takes too long. Spring&#8217;s <code>@Timed</code>, on the
                                    other hand, does not preemptively fail the test but rather waits for the test to complete before failing.</br>
                                    <span class="translate">
                                    Spring的@Timed注释与JUnit 4的@Test(timeout=…)支持有不同的语义。
                                    具体来说，由于JUnit 4处理测试执行超时的方式(即，通过在一个单独的线程中执行测试方法)，如果测试花费的时间太长，@Test(timeout=…)会先发制人地使测试失败。
                                    另一方面，Spring的@Timed并没有先发制人地使测试失败，而是在失败之前等待测试完成。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit4-repeat"><a class="anchor" href="#integration-testing-annotations-junit4-repeat"></a><code>@Repeat</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@Repeat</code> indicates that the annotated test method must be run repeatedly. The number of times that the test method is to be run is specified in the annotation.</br>
                                    <span class="translate">
                                    @Repeat表示必须重复运行带注释的测试方法。测试方法要运行的次数在注释中指定。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The scope of execution to be repeated includes execution of the test method itself as well as any setting up or tearing down of the test fixture.
                                    The following example shows how to use the <code>@Repeat</code> annotation:</br>
                                    <span class="translate">
                                    要重复的执行范围包括测试方法本身的执行以及测试夹具的任何设置或拆卸。下面的例子展示了如何使用@Repeat注释:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessRepeatedly() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Repeat this test ten times.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessRepeatedly() {
    // ...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Repeat this test ten times.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="integration-testing-annotations-junit-jupiter"><a class="anchor" href="#integration-testing-annotations-junit-jupiter"></a>3.4.4. Spring JUnit Jupiter Testing Annotations</h4>
                        <div class="paragraph">
                            <p>
                                The following annotations are supported when used in conjunction with the
                                <a href="#testcontext-junit-jupiter-extension"><code>SpringExtension</code></a> and JUnit Jupiter (that is, the programming model in JUnit 5):</br>
                                <span class="translate">
                                当与SpringExtension和JUnit Jupiter(即JUnit 5中的编程模型)一起使用时，支持以下注释:
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-nestedtestconfiguration"><code>@NestedTestConfiguration</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit-jupiter-springjunitconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitconfig"></a><code>@SpringJUnitConfig</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@SpringJUnitConfig</code> is a composed annotation that combines
                                    <code>@ExtendWith(SpringExtension.class)</code> from JUnit Jupiter with <code>@ContextConfiguration</code> from the Spring TestContext Framework. It can be used at the class level as a drop-in replacement for <code>@ContextConfiguration</code>.
                                    With regard to configuration options, the only difference between <code>@ContextConfiguration</code> and <code>@SpringJUnitConfig</code> is that component classes may be declared with the <code>value</code> attribute
                                    in <code>@SpringJUnitConfig</code>.</br>
                                    <span class="translate">
                                    @SpringJUnitConfig是一个组合注释，它结合了JUnit Jupiter中的@ExtendWith(SpringExtension.class)和Spring TestContext Framework中的@ContextConfiguration。
                                    它可以在类级别上用作@ContextConfiguration的替代。关于配置选项，@ContextConfiguration和@SpringJUnitConfig之间的唯一区别是组件类可以用@SpringJUnitConfig中的value属性来声明。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to use the <code>@SpringJUnitConfig</code> annotation to specify a configuration class:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@SpringJUnitConfig注释来指定一个配置类:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to use the <code>@SpringJUnitConfig</code> annotation to specify the location of a configuration file:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@SpringJUnitConfig注释来指定配置文件的位置:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the location of a configuration file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the location of a configuration file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    See <a href="#testcontext-ctx-management">Context Management</a> as well as the javadoc for
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html">
                                    <code>@SpringJUnitConfig</code></a> and <code>@ContextConfiguration</code> for further details.</br>
                                    <span class="translate">
                                    请参阅上下文管理以及@SpringJUnitConfig和@ContextConfiguration的javadoc以了解更多细节。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit-jupiter-springjunitwebconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"></a><code>@SpringJUnitWebConfig</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@SpringJUnitWebConfig</code> is a composed annotation that combines
                                    <code>@ExtendWith(SpringExtension.class)</code> from JUnit Jupiter with <code>@ContextConfiguration</code> and
                                    <code>@WebAppConfiguration</code> from the Spring TestContext Framework. You can use it at the class level as a drop-in replacement for <code>@ContextConfiguration</code> and <code>@WebAppConfiguration</code>. With
                                    regard to configuration options, the only difference between <code>@ContextConfiguration</code> and <code>@SpringJUnitWebConfig</code> is that you can declare component classes by using the
                                    <code>value</code> attribute in <code>@SpringJUnitWebConfig</code>. In addition, you can override the <code>value</code> attribute from <code>@WebAppConfiguration</code> only by using the <code>resourcePath</code> attribute
                                    in <code>@SpringJUnitWebConfig</code>.</br>
                                    <span class="translate">
                                    @SpringJUnitWebConfig是一个组合注解，它结合了JUnit Jupiter中的@ExtendWith(SpringExtension.class)和
                                    Spring TestContext Framework中的@ContextConfiguration和@WebAppConfiguration。
                                    您可以在类级别使用它作为@ContextConfiguration和@WebAppConfiguration的替代。
                                    关于配置选项，@ContextConfiguration和@SpringJUnitWebConfig之间的唯一区别是，你可以通过使用@SpringJUnitWebConfig中的value属性来声明组件类。
                                    此外，您只能通过使用@SpringJUnitWebConfig中的resourcePath属性来覆盖@WebAppConfiguration中的value属性。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example shows how to use the <code>@SpringJUnitWebConfig</code> annotation to specify a configuration class:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@SpringJUnitWebConfig注释来指定一个配置类:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following example shows how to use the <code>@SpringJUnitWebConfig</code> annotation to specify the location of a configuration file:</br>
                                    <span class="translate">
                                    下面的例子展示了如何使用@SpringJUnitWebConfig注释来指定配置文件的位置:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the location of a configuration file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the location of a configuration file.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    See <a href="#testcontext-ctx-management">Context Management</a> as well as the javadoc for
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html"><code>@SpringJUnitWebConfig</code></a>,
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><code>@ContextConfiguration</code></a>, and
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a> for further details.</br>
                                    <span class="translate">
                                    请参阅上下文管理以及@SpringJUnitWebConfig、@ContextConfiguration和@WebAppConfiguration的javadoc以了解更多细节。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-testconstructor"><a class="anchor" href="#integration-testing-annotations-testconstructor"></a><code>@TestConstructor</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@TestConstructor</code> is a type-level annotation that is used to configure how the parameters of a test class constructor are autowired from components in the test&#8217;s
                                    <code>ApplicationContext</code>.</br>
                                    <span class="translate">
                                    @TestConstructor是一个类型级的注释，用于配置如何从测试的ApplicationContext中的组件自动连接测试类构造函数的参数。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If <code>@TestConstructor</code> is not present or meta-present on a test class, the default <em>test constructor autowire mode</em>
                                    will be used. See the tip below for details on how to change the default mode. Note, however, that a local declaration
                                    of <code>@Autowired</code> on a constructor takes precedence over both <code>@TestConstructor</code> and the default mode.</br>
                                    <span class="translate">
                                    如果@TestConstructor在测试类中不存在或元存在，将使用默认的测试构造函数自动装配模式。有关如何更改默认模式的详细信息，请参阅下面的提示。
                                    但是请注意，构造函数上的@Autowired的局部声明优先于@TestConstructor和默认模式。
                                </p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Changing the default test constructor autowire mode<br><span class="translate">更改默认测试构造函数自动装配模式</span></div>
                                            <div class="paragraph">
                                                <p>
                                                    The default <em>test constructor autowire mode</em> can be changed by setting the
                                                    <code>spring.test.constructor.autowire.mode</code> JVM system property to <code>all</code>. Alternatively, the default mode may be set via the
                                                    <a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism.</br>
                                                    <span class="translate">
                                                    通过将spring.test.constructor.autowire.mode JVM系统属性设置为all，可以更改默认的测试构造函数自动装配模式。或者，默认模式可以通过SpringProperties机制来设置。
                                                </p>
                                            </div>
                                            <div class="paragraph">
                                                <p>
                                                    As of Spring Framework 5.3, the default mode may also be configured as a
                                                    <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params">JUnit Platform configuration parameter</a>.</br>
                                                    <span class="translate">
                                                    从Spring Framework 5.3开始，默认模式也可以配置为JUnit平台的配置参数。
                                                </p>
                                            </div>
                                            <div class="paragraph">
                                                <p>
                                                    If the <code>spring.test.constructor.autowire.mode</code> property is not set, test class constructors will not be automatically autowired.</br>
                                                    <span class="translate">
                                                    如果没有设置spring.test.constructor.autowire.mode属性，测试类构造函数将不会自动自动连接。
                                                </p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            As of Spring Framework 5.2, <code>@TestConstructor</code> is only supported in conjunction with the <code>SpringExtension</code> for use with JUnit Jupiter. Note that the <code>SpringExtension</code> is often
                                            automatically registered for you – for example, when using annotations such as
                                            <code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> or various test-related annotations from Spring Boot Test.</br>
                                            <span class="translate">
                                            从Spring Framework 5.2开始，@TestConstructor只支持与SpringExtension一起使用。
                                            请注意，SpringExtension通常会自动为你注册——例如，当使用@SpringJUnitConfig和@SpringJUnitWebConfig这样的注解或Spring Boot Test中各种与测试相关的注解时。
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-nestedtestconfiguration"><a class="anchor" href="#integration-testing-annotations-nestedtestconfiguration"></a><code>@NestedTestConfiguration</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@NestedTestConfiguration</code> is a type-level annotation that is used to configure how Spring test configuration annotations are processed within enclosing class hierarchies for inner test classes.</br>
                                    <span class="translate">
                                    @NestedTestConfiguration是一个类型级注释，用于配置如何在内部测试类的封闭类层次结构中处理Spring测试配置注释。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If <code>@NestedTestConfiguration</code> is not present or meta-present on a test class, in its super type hierarchy,
                                    or in its enclosing class hierarchy, the default <em>enclosing configuration inheritance mode</em> will be used.
                                    See the tip below for details on how to change the default mode.</br>
                                    <span class="translate">
                                    如果@NestedTestConfiguration没有出现在测试类中，也没有出现在它的超类型层次结构中，或者在它的外围类层次结构中，将使用默认的外围配置继承模式。
                                    有关如何更改默认模式的详细信息，请参阅下面的提示。
                                </p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Changing the default enclosing configuration inheritance mode<br> 更改默认的封闭配置继承模式</div>
                                            <div class="paragraph">
                                                <p>
                                                    The default <em>enclosing configuration inheritance mode</em> is <code>INHERIT</code>, but it can be changed by setting the <code>spring.test.enclosing.configuration</code> JVM system property to
                                                    <code>OVERRIDE</code>. Alternatively, the default mode may be set via the
                                                    <a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism.</br>
                                                    <span class="translate">
                                                    默认的封装配置继承模式是INHERIT，但是可以通过将spring.test. enclosure .configuration JVM系统属性设置为OVERRIDE来更改它。
                                                    或者，默认模式可以通过SpringProperties机制来设置。
                                                </p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The <a href="#testcontext-framework">Spring TestContext Framework</a> honors <code>@NestedTestConfiguration</code> semantics for the following annotations.</br>
                                    <span class="translate">
                                    Spring TestContext Framework 对以下注释采用@NestedTestConfiguration语义。
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#testcontext-tx"><code>@Transactional</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
                                    </li>
                                    <li>
                                        <p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            The use of <code>@NestedTestConfiguration</code> typically only makes sense in conjunction with <code>@Nested</code> test classes in JUnit Jupiter; however, there may be other testing frameworks with support
                                            for Spring and nested test classes that make use of this annotation.</br>
                                            <span class="translate">
                                            @NestedTestConfiguration的使用通常只在JUnit Jupiter中与@嵌套测试类结合时才有意义;但是，可能有其他支持Spring的测试框架和使用此注释的嵌套测试类。
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>
                                    See <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a> for an example and further details.</br>
                                    <span class="translate">
                                    请参阅@Nested测试类配置以获得示例和进一步的详细信息。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit-jupiter-enabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-enabledif"></a><code>@EnabledIf</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@EnabledIf</code> is used to signal that the annotated JUnit Jupiter test class or test method is enabled and should be run if the supplied <code>expression</code> evaluates to <code>true</code>. Specifically, if
                                    the expression evaluates to <code>Boolean.TRUE</code> or a <code>String</code> equal to <code>true</code> (ignoring case), the test is enabled. When applied at the class level, all test methods within that class are
                                    automatically enabled by default as well.</br>
                                    <span class="translate">
                                    @EnabledIf用于表示已启用带注释的JUnit Jupiter测试类或测试方法，如果提供的表达式计算结果为true，则应运行该测试类或测试方法。
                                    具体来说，如果表达式的计算结果是布尔值。TRUE或String等于TRUE(忽略大小写)，测试被启用。
                                    当应用于类级别时，该类中的所有测试方法默认情况下也会自动启用。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>Expressions can be any of the following:</br>表达式可以是以下任意一个:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>
                                            <a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. For example: <code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></br>
                                            <span class="translate">
                                            Spring Expression (SpEL)语言表达式, For example: <code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></br>
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>. For example: <code>@EnabledIf("${smoke.tests.enabled}")</code></br>
                                            <span class="translate">
                                            Spring环境中可用属性的占位符. 例如： <code>@EnabledIf("${smoke.tests.enabled}")</code>
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Text literal. For example: <code>@EnabledIf("true")</code></br>
                                            <span class="translate">
                                            文本文字。例如: <code>@EnabledIf("true")</code>
                                        </p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since <code>@EnabledIf("false")</code> is equivalent to <code>@Disabled</code> and <code>@EnabledIf("true")</code> is logically meaningless.</br>
                                    <span class="translate">
                                    然而，请注意，不是动态解析属性占位符的结果的文本文本是没有实际价值的，因为@EnabledIf(“false”)等同于@Disabled，而@EnabledIf(“true”)在逻辑上是没有意义的。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can use <code>@EnabledIf</code> as a meta-annotation to create custom composed annotations. For example, you can create a custom <code>@EnabledOnMac</code> annotation as follows:</br>
                                    <span class="translate">
                                    您可以使用@EnabledIf作为元注释来创建自定义组合注释。例如，您可以创建自定义@EnabledOnMac注释，如下所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@EnabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Enabled on Mac OS"
)
annotation class EnabledOnMac {}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="integration-testing-annotations-junit-jupiter-disabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-disabledif"></a><code>@DisabledIf</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>@DisabledIf</code> is used to signal that the annotated JUnit Jupiter test class or test method is disabled and should not be run if the supplied <code>expression</code> evaluates to
                                    <code>true</code>. Specifically, if the expression evaluates to <code>Boolean.TRUE</code> or a <code>String</code> equal to <code>true</code> (ignoring case), the test is disabled. When applied at the class level, all
                                    test methods within that class are automatically disabled as well.</br>
                                    <span class="translate">
                                    @DisabledIf用于表示已禁用带注释的JUnit Jupiter测试类或测试方法，如果提供的表达式计算结果为true，则不应运行。
                                    具体来说，如果表达式的计算结果是布尔值。TRUE或String等于TRUE(忽略大小写)，测试将被禁用。当应用于类级别时，该类中的所有测试方法也会自动禁用。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>Expressions can be any of the following:</br>表达式可以是以下任意一个:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>
                                            <a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. For example:
                                            <code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></br>
                                            <span class="translate">
                                              Spring Expression (SpEL)语言表达式. 例如:
                                            <code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code>
                                            </span>
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>. For example: <code>@DisabledIf("${smoke.tests.disabled}")</code></br>
                                            <span class="translate">
                                            Spring环境中可用属性的占位符. 例如： <code>@DisabledIf("${smoke.tests.disabled}")</code>
                                            </span>
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Text literal. For example: <code>@DisabledIf("true")</code></br>
                                            <span class="translate">
                                            文本文字。例如:  <code>@DisabledIf("true")</code>
                                        </p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since <code>@DisabledIf("true")</code> is equivalent to <code>@Disabled</code> and <code>@DisabledIf("false")</code>  is logically meaningless.</br>
                                    <span class="translate">
                                    但是，请注意，不是动态解析属性占位符的结果的文本文本是没有实际价值的，因为@DisabledIf(“true”)等同于@Disabled，而@DisabledIf(“false”)在逻辑上是没有意义的。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can use <code>@DisabledIf</code> as a meta-annotation to create custom composed annotations. For example, you can create a custom <code>@DisabledOnMac</code> annotation as follows:</br>
                                    <span class="translate">
                                    您可以使用@DisabledIf作为元注释来创建自定义组合注释。例如，可以创建自定义@DisabledOnMac注释，如下所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@DisabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Disabled on Mac OS"
)
annotation class DisabledOnMac {}</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="integration-testing-annotations-meta"><a class="anchor" href="#integration-testing-annotations-meta"></a>3.4.5. Meta-Annotation Support for Testing</h4>
                        <span>元注解对测试的支持</span>
                        <div class="paragraph">
                            <p>
                                You can use most test-related annotations as
                                <a href="core.html#beans-meta-annotations">meta-annotations</a> to create custom composed annotations and reduce configuration duplication across a test suite.</br>
                                <span class="translate">
                                您可以将大多数与测试相关的注释作为元注释来创建自定义组合的注释，并减少测试套件中的配置重复。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                You can use each of the following as a meta-annotation in conjunction with the
                                <a href="#testcontext-framework">TestContext framework</a>.</br>
                                <span class="translate">
                                您可以使用下面的每一个作为与TestContext框架相结合的元注释。
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>@BootstrapWith</code></p>
                                </li>
                                <li>
                                    <p><code>@ContextConfiguration</code></p>
                                </li>
                                <li>
                                    <p><code>@ContextHierarchy</code></p>
                                </li>
                                <li>
                                    <p><code>@ActiveProfiles</code></p>
                                </li>
                                <li>
                                    <p><code>@TestPropertySource</code></p>
                                </li>
                                <li>
                                    <p><code>@DirtiesContext</code></p>
                                </li>
                                <li>
                                    <p><code>@WebAppConfiguration</code></p>
                                </li>
                                <li>
                                    <p><code>@TestExecutionListeners</code></p>
                                </li>
                                <li>
                                    <p><code>@Transactional</code></p>
                                </li>
                                <li>
                                    <p><code>@BeforeTransaction</code></p>
                                </li>
                                <li>
                                    <p><code>@AfterTransaction</code></p>
                                </li>
                                <li>
                                    <p><code>@Commit</code></p>
                                </li>
                                <li>
                                    <p><code>@Rollback</code></p>
                                </li>
                                <li>
                                    <p><code>@Sql</code></p>
                                </li>
                                <li>
                                    <p><code>@SqlConfig</code></p>
                                </li>
                                <li>
                                    <p><code>@SqlMergeMode</code></p>
                                </li>
                                <li>
                                    <p><code>@SqlGroup</code></p>
                                </li>
                                <li>
                                    <p><code>@Repeat</code> <em>(only supported on JUnit 4)</em></p>
                                </li>
                                <li>
                                    <p><code>@Timed</code> <em>(only supported on JUnit 4)</em></p>
                                </li>
                                <li>
                                    <p><code>@IfProfileValue</code> <em>(only supported on JUnit 4)</em></p>
                                </li>
                                <li>
                                    <p><code>@ProfileValueSourceConfiguration</code> <em>(only supported on JUnit 4)</em></p>
                                </li>
                                <li>
                                    <p><code>@SpringJUnitConfig</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                                <li>
                                    <p><code>@SpringJUnitWebConfig</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                                <li>
                                    <p><code>@TestConstructor</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                                <li>
                                    <p><code>@NestedTestConfiguration</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                                <li>
                                    <p><code>@EnabledIf</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                                <li>
                                    <p><code>@DisabledIf</code> <em>(only supported on JUnit Jupiter)</em></p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>Consider the following example:</br><span class="translate">考虑以下例子:</span></p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                If we discover that we are repeating the preceding configuration across our JUnit 4-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration
                                for Spring, as follows:</br>
                                <span class="translate">
                                如果我们发现我们在基于JUnit 4的测试套件中重复了前面的配置，我们可以通过引入一个自定义的组合注释来减少重复，该注释集中了Spring的通用测试配置，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                Then we can use our custom <code>@TransactionalDevTestConfig</code> annotation to simplify the configuration of individual JUnit 4 based test classes, as follows:</br>
                                <span class="translate">
                                然后，我们可以使用自定义的@TransactionalDevTestConfig注释来简化基于JUnit 4的测试类的配置，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class OrderRepositoryTests

@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class UserRepositoryTests</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                If we write tests that use JUnit Jupiter, we can reduce code duplication even further, since annotations in JUnit 5 can also be used as meta-annotations. Consider the following example:</br>
                                <span class="translate">
                                如果我们编写使用JUnit Jupiter的测试，就可以进一步减少代码重复，因为JUnit 5中的注释也可以用作元注释。考虑以下例子:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                If we discover that we are repeating the preceding configuration across our JUnit Jupiter-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration
                                for Spring and JUnit Jupiter, as follows:</br>
                                <span class="translate">
                                如果我们发现我们在基于JUnit Jupiter的测试套件中重复了前面的配置，我们可以通过引入一个自定义的组合注释来减少重复，该注释集中了Spring和JUnit Jupiter的通用测试配置，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                Then we can use our custom <code>@TransactionalDevTestConfig</code> annotation to simplify the configuration of individual JUnit Jupiter based test classes, as follows:</br>
                                <span class="translate">
                                然后，我们可以使用自定义的@TransactionalDevTestConfig注释来简化单个JUnit Jupiter测试类的配置，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                Since JUnit Jupiter supports the use of <code>@Test</code>, <code>@RepeatedTest</code>, <code>ParameterizedTest</code>, and others as meta-annotations, you can also create custom composed annotations at the test method level.
                                For example, if we wish to create a composed annotation that combines the <code>@Test</code> and <code>@Tag</code> annotations from JUnit Jupiter with the <code>@Transactional</code> annotation from Spring, we could create
                                an <code>@TransactionalIntegrationTest</code> annotation, as follows:</br>
                                <span class="translate">
                                因为JUnit Jupiter支持使用@Test、@RepeatedTest、ParameterizedTest和其他作为元注释，所以您也可以在测试方法级别创建自定义组合注释。
                                例如，如果我们希望创建一个组合注释，将来自JUnit Jupiter的@Test和@Tag注释与来自Spring的@Transactional注释结合起来，我们可以创建一个@TransactionalIntegrationTest注释，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
annotation class TransactionalIntegrationTest { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                Then we can use our custom <code>@TransactionalIntegrationTest</code> annotation to simplify the configuration of individual JUnit Jupiter based test methods, as follows:</br>
                                <span class="translate">
                                然后我们可以使用自定义的@TransactionalIntegrationTest注释来简化单个基于JUnit Jupiter的测试方法的配置，如下所示:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TransactionalIntegrationTest
fun saveOrder() { }

@TransactionalIntegrationTest
fun deleteOrder() { }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>
                                For further details, see the <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a> wiki page.</br>
                                <span class="translate">
                                有关详细信息，请参见Spring注释编程模型wiki页面。

                            </p>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="testcontext-framework"><a class="anchor" href="#testcontext-framework"></a>3.5. Spring TestContext Framework</h3>
                    <div class="paragraph">
                        <p>
                            The Spring TestContext Framework (located in the <code>org.springframework.test.context</code> package) provides generic,
                            annotation-driven unit and integration testing support that is agnostic of the testing framework in use.
                            The TestContext framework also places a great deal of importance on convention over configuration,
                            with reasonable defaults that you can override through annotation-based configuration.</br>
                            <span class="translate">
                            Spring TestContext Framework(位于org.springframework.test.context包中)提供了通用的、注释驱动的单元和集成测试支持，与正在使用的测试框架无关。
                            TestContext框架还非常重视约定而不是配置，通过基于注释的配置可以覆盖合理的缺省值。
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>
                            In addition to generic testing infrastructure, the TestContext framework provides explicit support for JUnit 4, JUnit Jupiter (AKA JUnit 5), and TestNG. For JUnit 4 and TestNG, Spring provides <code>abstract</code> support classes.
                            Furthermore, Spring provides a custom JUnit <code>Runner</code> and custom JUnit <code>Rules</code> for JUnit 4 and a custom <code>Extension</code> for JUnit Jupiter that let you write so-called POJO test classes. POJO test
                            classes are not required to extend a particular class hierarchy, such as the <code>abstract</code> support classes.</br>
                            <span class="translate">
                            除了通用的测试基础设施之外，TestContext框架还提供了对JUnit 4、JUnit Jupiter (AKA JUnit 5)和TestNG的显式支持。
                            对于JUnit 4和TestNG, Spring提供了抽象支持类。此外，Spring还提供了一个自定义JUnit Runner和JUnit 4的自定义JUnit规则，以及一个JUnit Jupiter的自定义扩展，可以让您编写所谓的POJO测试类。
                            POJO测试类不需要扩展特定的类层次结构，比如抽象支持类。
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>
                            The following section provides an overview of the internals of the TestContext framework.
                             If you are interested only in using the framework and are not interested in extending it with your own custom listeners or custom loaders,
                            feel free to go directly to the configuration (<a href="#testcontext-ctx-management">context management</a>,
                            <a href="#testcontext-fixture-di">dependency injection</a>, <a href="#testcontext-tx">transaction management</a>),
                            <a href="#testcontext-support-classes">support classes</a>, and
                            <a href="#integration-testing-annotations">annotation support</a> sections.</br>
                            <span class="translate">
                            下面的部分提供了TestContext framework 内部的概述。
                            如果您只对使用框架感兴趣，而对使用您自己的自定义侦听器或自定义加载器扩展它不感兴趣，可以直接进入配置(上下文管理、依赖注入、事务管理)、支持类和注释支持部分。
                        </p>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-key-abstractions"><a class="anchor" href="#testcontext-key-abstractions"></a>3.5.1. Key Abstractions</h4>
                        <span class="translate">3.5.1. 关键抽象</span>
                        <div class="paragraph">
                            <p>
                                The core of the framework consists of the <code>TestContextManager</code> class and the
                                <code>TestContext</code>, <code>TestExecutionListener</code>, and <code>SmartContextLoader</code> interfaces. A
                                <code>TestContextManager</code> is created for each test class (for example, for the execution of all test methods within a single test class in JUnit Jupiter).
                                The <code>TestContextManager</code>, in turn, manages a <code>TestContext</code> that holds the context of the current test. The
                                <code>TestContextManager</code> also updates the state of the <code>TestContext</code> as the test progresses and delegates to
                                <code>TestExecutionListener</code> implementations, which instrument the actual test execution
                                by providing dependency injection, managing transactions, and so on. A
                                <code>SmartContextLoader</code> is responsible for loading an <code>ApplicationContext</code> for a given test class.
                                 See the <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a>                                and the Spring test suite for further information and examples of various implementations.</br>
                                 <span class="translate">
                                该框架的核心包括TestContextManager类和TestContext、TestExecutionListener和SmartContextLoader接口。
                                为每个测试类创建一个TestContextManager(例如，为在JUnit Jupiter中的单个测试类中执行所有测试方法)。
                                反过来，TestContextManager管理一个保存当前测试上下文的TestContext。
                                TestContextManager还在测试进行时更新TestContext的状态，并委托给TestExecutionListener实现，这些实现通过提供依赖注入、管理事务等等来检测实际的测试执行。
                                SmartContextLoader负责为给定的测试类加载ApplicationContext。有关各种实现的更多信息和示例，请参阅javadoc和Spring测试套件。
                                </span>
                                </p>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext"><a class="anchor" href="#testcontext"></a><code>TestContext</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>TestContext</code> encapsulates the context in which a test is run (agnostic of the actual testing framework in use) and provides context management and caching support for the test instance for which it is responsible.
                                    The <code>TestContext</code> also delegates to a
                                    <code>SmartContextLoader</code> to load an <code>ApplicationContext</code> if requested.</br>
                                    <span class="translate">
                                    TestContext封装了运行测试的上下文(与实际使用的测试框架无关)，并为它所负责的测试实例提供了上下文管理和缓存支持。
                                    TestContext也委托给SmartContextLoader来加载ApplicationContext。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontextmanager"><a class="anchor" href="#testcontextmanager"></a><code>TestContextManager</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>TestContextManager</code> is the main entry point into the Spring TestContext Framework and is responsible for managing a single <code>TestContext</code> and signaling events to each registered
                                    <code>TestExecutionListener</code> at well-defined test execution points:</br>
                                    <span class="translate">
                                    TestContextManager是Spring TestContext框架的主要入口点，负责管理单个TestContext，并在定义良好的测试执行点向每个注册的TestExecutionListener发送事件信号:
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>
                                            Prior to any &#8220;before class&#8221; or &#8220;before all&#8221; methods of a particular testing framework.</br>
                                            <span class="translate">
                                            在特定测试框架的任何“在类之前”或“在所有方法之前”。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Test instance post-processing.</br>
                                            <span class="translate">
                                            后处理测试实例。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Prior to any &#8220;before&#8221; or &#8220;before each&#8221; methods of a particular testing framework.</br>
                                            <span class="translate">
                                            在特定测试框架的任何“之前”或“在每个”方法之前。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Immediately before execution of the test method but after test setup.</br>
                                            <span class="translate">
                                            在测试方法执行之前，但在测试设置之后。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Immediately after execution of the test method but before test tear down.</br>
                                            <span class="translate">
                                            在测试方法执行之后，但在测试结束之前。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            After any &#8220;after&#8221; or &#8220;after each&#8221; methods of a particular testing framework.</br>
                                            <span class="translate">
                                            在特定测试框架的任何“之后”或“每个”方法之后。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            After any &#8220;after class&#8221; or &#8220;after all&#8221; methods of a particular testing framework.</br>
                                            <span class="translate">
                                            在特定测试框架的任何“课后”或“终究”方法之后。
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testexecutionlistener"><a class="anchor" href="#testexecutionlistener"></a><code>TestExecutionListener</code></h5>
                            <div class="paragraph">
                                <p>
                                    <code>TestExecutionListener</code> defines the API for reacting to test-execution events published by the <code>TestContextManager</code> with which the listener is registered. See <a href="#testcontext-tel-config"><code>TestExecutionListener</code> Configuration</a>.</br>
                                    <span class="translate">
                                    TestExecutionListener定义了一个API，用于响应TestContextManager发布的测试执行事件，侦听器是与TestContextManager一起注册的。看到TestExecutionListener配置。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="context-loaders"><a class="anchor" href="#context-loaders"></a>Context Loaders</h5>
                            <span>上下文加载器</span>
                            <div class="paragraph">
                                <p>
                                    <code>ContextLoader</code> is a strategy interface for loading an <code>ApplicationContext</code> for an integration test managed by the Spring TestContext Framework. You should implement
                                    <code>SmartContextLoader</code> instead of this interface to provide support for component classes, active bean definition profiles, test property sources, context hierarchies, and
                                    <code>WebApplicationContext</code> support.</br>
                                    <span class="translate">
                                    ContextLoader是一个策略接口，用于为Spring TestContext框架管理的集成测试加载ApplicationContext。
                                    你应该实现SmartContextLoader而不是这个接口来提供对组件类、活动bean定义配置文件、测试属性源、上下文层次结构和WebApplicationContext支持的支持。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    <code>SmartContextLoader</code> is an extension of the <code>ContextLoader</code> interface that supersedes the original minimal <code>ContextLoader</code> SPI. Specifically, a <code>SmartContextLoader</code> can choose
                                    to process resource locations, component classes, or context initializers. Furthermore, a
                                    <code>SmartContextLoader</code> can set active bean definition profiles and test property sources in the context that it loads.</br>
                                    <span class="translate">
                                    SmartContextLoader是ContextLoader接口的扩展，它取代了原来最小的ContextLoader SPI。
                                    具体来说，SmartContextLoader可以选择处理资源位置、组件类或上下文初始化器。
                                    此外，SmartContextLoader可以在它加载的上下文中设置活动bean定义概要文件和测试属性源。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>Spring provides the following implementations:</br><span class="translate">Spring提供了以下实现:</span></p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>
                                            <code>DelegatingSmartContextLoader</code>: One of two default loaders, it delegates internally to an <code>AnnotationConfigContextLoader</code>, a <code>GenericXmlContextLoader</code>, or a
                                            <code>GenericGroovyXmlContextLoader</code>, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. Groovy support is enabled
                                            only if Groovy is on the classpath.</br>
                                            <span class="translate">
                                            DelegatingSmartContextLoader:两个默认加载器之一,它代表内部AnnotationConfigContextLoader, GenericXmlContextLoader,或GenericGroovyXmlContextLoader,
                                            根据测试类声明的配置或在默认位置的存在或默认配置类。只有当Groovy在类路径上时，才会启用Groovy支持。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>WebDelegatingSmartContextLoader</code>: One of two default loaders, it delegates internally to an <code>AnnotationConfigWebContextLoader</code>,
                                            a <code>GenericXmlWebContextLoader</code>, or a <code>GenericGroovyXmlWebContextLoader</code>,
                                            depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes.
                                            A web <code>ContextLoader</code> is used only if <code>@WebAppConfiguration</code> is present on the test class. Groovy support is enabled only if Groovy is on the classpath.</br>
                                            <span class="translate">
                                            WebDelegatingSmartContextLoader:两个默认加载器之一,它代表内部AnnotationConfigWebContextLoader,
                                            GenericXmlWebContextLoader,或GenericGroovyXmlWebContextLoader,根据测试类声明的配置或在默认位置的存在或默认配置类。
                                            只有当@WebAppConfiguration在测试类中存在时，才会使用web ContextLoader。只有当Groovy在类路径上时，才会启用Groovy支持。
                                            </span>
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>AnnotationConfigContextLoader</code>: Loads a standard <code>ApplicationContext</code> from component classes.</br>
                                            <span class="translate">
                                            AnnotationConfigContextLoader:从组件类加载一个标准的ApplicationContext。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>AnnotationConfigWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from component classes.</br>
                                            <span class="translate">
                                            AnnotationConfigWebContextLoader:从组件类中加载WebApplicationContext。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>GenericGroovyXmlContextLoader</code>: Loads a standard <code>ApplicationContext</code> from resource locations that are either Groovy scripts or XML configuration files.</br>
                                            <span class="translate">
                                            GenericGroovyXmlContextLoader:从Groovy脚本或XML配置文件的资源位置加载一个标准的ApplicationContext。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>GenericGroovyXmlWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from resource locations that are either Groovy scripts or XML configuration files.</br>
                                            <span class="translate">
                                            GenericGroovyXmlWebContextLoader:从资源位置(Groovy脚本或XML配置文件)加载WebApplicationContext。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>GenericXmlContextLoader</code>: Loads a standard <code>ApplicationContext</code> from XML resource locations.</br>
                                            <span class="translate">
                                            GenericXmlContextLoader:从XML资源位置加载标准的ApplicationContext。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            <code>GenericXmlWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from XML resource locations.</br>
                                            <span class="translate">
                                            GenericXmlWebContextLoader:从XML资源位置加载WebApplicationContext。
                                        </p>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-bootstrapping"><a class="anchor" href="#testcontext-bootstrapping"></a>3.5.2. Bootstrapping the TestContext Framework</h4>
                        <span class="translate">3.5.2. Bootstrapping the TestContext Framework</span>
                        <div class="paragraph">
                            <p>
                                The default configuration for the internals of the Spring TestContext Framework is sufficient for all common use cases. However, there are times when a development team or third party framework would like to change the default
                                <code>ContextLoader</code>, implement a custom <code>TestContext</code> or <code>ContextCache</code>, augment the default sets of
                                <code>ContextCustomizerFactory</code> and <code>TestExecutionListener</code> implementations, and so on. For such low-level control over how the TestContext framework operates, Spring provides a bootstrapping strategy.</br>
                                <span class="translate">
                                Spring TestContext框架内部的默认配置对所有常见用例都足够了。然而，有时开发团队或第三方框架想要改变默认的ContextLoader，实现一个自定义的TestContext或ContextCache，
                                增加ContextCustomizerFactory和TestExecutionListener实现的默认集合，等等。对于这种对TestContext框架如何操作的低级控制，Spring提供了一个引导策略。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                <code>TestContextBootstrapper</code> defines the SPI for bootstrapping the TestContext framework. A
                                <code>TestContextBootstrapper</code> is used by the <code>TestContextManager</code> to load the
                                <code>TestExecutionListener</code> implementations for the current test and to build the
                                <code>TestContext</code> that it manages. You can configure a custom bootstrapping strategy for a test class (or test class hierarchy) by using <code>@BootstrapWith</code>, either directly or as a meta-annotation. If a
                                bootstrapper is not explicitly configured by using
                                <code>@BootstrapWith</code>, either the <code>DefaultTestContextBootstrapper</code> or the
                                <code>WebTestContextBootstrapper</code> is used, depending on the presence of <code>@WebAppConfiguration</code>.</br>
                                <span class="translate">
                                TestContextBootstrapper定义了用于引导TestContext框架的SPI。
                                TestContextBootstrapper被TestContextManager用来加载当前测试的TestExecutionListener实现，并构建它所管理的TestContext。
                                您可以使用@BootstrapWith为测试类(或测试类层次结构)配置自定义引导策略，可以直接使用，也可以作为元注释使用。
                                如果引导程序没有使用@BootstrapWith显式配置，则使用DefaultTestContextBootstrapper或WebTestContextBootstrapper，这取决于@WebAppConfiguration是否存在。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                Since the <code>TestContextBootstrapper</code> SPI is likely to change in the future (to accommodate new requirements), we strongly encourage implementers not to implement this interface directly but rather to extend <code>AbstractTestContextBootstrapper</code>  or one of its concrete subclasses instead.
                                <span class="translate">
                                因为TestContextBootstrapper SPI将来可能会发生变化(以适应新的需求)，我们强烈鼓励实现者不要直接实现这个接口，而是扩展AbstractTestContextBootstrapper或它的具体子类之一。
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-tel-config"><a class="anchor" href="#testcontext-tel-config"></a>3.5.3. <code>TestExecutionListener</code> Configuration</h4>
                        <div class="paragraph">
                            <p>Spring provides the following <code>TestExecutionListener</code> implementations that are registered by default, exactly in the following order:</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>ServletTestExecutionListener</code>: Configures Servlet API mocks for a
                                        <code>WebApplicationContext</code>.</p>
                                </li>
                                <li>
                                    <p><code>DirtiesContextBeforeModesTestExecutionListener</code>: Handles the <code>@DirtiesContext</code> annotation for &#8220;before&#8221; modes.</p>
                                </li>
                                <li>
                                    <p><code>ApplicationEventsTestExecutionListener</code>: Provides support for
                                        <a href="#testcontext-application-events"><code>ApplicationEvents</code></a>.</p>
                                </li>
                                <li>
                                    <p><code>DependencyInjectionTestExecutionListener</code>: Provides dependency injection for the test instance.
                                    </p>
                                </li>
                                <li>
                                    <p><code>DirtiesContextTestExecutionListener</code>: Handles the <code>@DirtiesContext</code> annotation for &#8220;after&#8221; modes.</p>
                                </li>
                                <li>
                                    <p><code>TransactionalTestExecutionListener</code>: Provides transactional test execution with default rollback semantics.</p>
                                </li>
                                <li>
                                    <p><code>SqlScriptsTestExecutionListener</code>: Runs SQL scripts configured by using the <code>@Sql</code> annotation.
                                    </p>
                                </li>
                                <li>
                                    <p><code>EventPublishingTestExecutionListener</code>: Publishes test execution events to the test&#8217;s
                                        <code>ApplicationContext</code> (see <a href="#testcontext-test-execution-events">Test Execution Events</a>).</p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tel-config-registering-tels"><a class="anchor" href="#testcontext-tel-config-registering-tels"></a>Registering <code>TestExecutionListener</code> Implementations</h5>
                            <div class="paragraph">
                                <p>You can register <code>TestExecutionListener</code> implementations for a test class and its subclasses by using the <code>@TestExecutionListeners</code> annotation. See
                                    <a href="#integration-testing-annotations">annotation support</a> and the javadoc for
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code></a> for details and examples.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tel-config-automatic-discovery"><a class="anchor" href="#testcontext-tel-config-automatic-discovery"></a>Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</h5>
                            <div class="paragraph">
                                <p>Registering <code>TestExecutionListener</code> implementations by using <code>@TestExecutionListeners</code> is suitable for custom listeners that are used in limited testing scenarios. However, it can become cumbersome
                                    if a custom listener needs to be used across an entire test suite. This issue is addressed through support for automatic discovery of default
                                    <code>TestExecutionListener</code> implementations through the <code>SpringFactoriesLoader</code> mechanism.</p>
                            </div>
                            <div class="paragraph">
                                <p>Specifically, the <code>spring-test</code> module declares all core default <code>TestExecutionListener</code> implementations under the <code>org.springframework.test.context.TestExecutionListener</code> key in its <code>META-INF/spring.factories</code>                                    properties file. Third-party frameworks and developers can contribute their own <code>TestExecutionListener</code> implementations to the list of default listeners in the same manner through their own <code>META-INF/spring.factories</code>                                    properties file.
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tel-config-ordering"><a class="anchor" href="#testcontext-tel-config-ordering"></a>Ordering <code>TestExecutionListener</code> Implementations</h5>
                            <div class="paragraph">
                                <p>When the TestContext framework discovers default <code>TestExecutionListener</code> implementations through the <a href="#testcontext-tel-config-automatic-discovery">aforementioned</a>
                                    <code>SpringFactoriesLoader</code> mechanism, the instantiated listeners are sorted by using Spring&#8217;s <code>AnnotationAwareOrderComparator</code>, which honors Spring&#8217;s <code>Ordered</code> interface and
                                    <code>@Order</code> annotation for ordering. <code>AbstractTestExecutionListener</code> and all default
                                    <code>TestExecutionListener</code> implementations provided by Spring implement <code>Ordered</code> with appropriate values. Third-party frameworks and developers should therefore make sure that their default <code>TestExecutionListener</code>                                    implementations are registered in the proper order by implementing <code>Ordered</code> or declaring <code>@Order</code>. See the javadoc for the <code>getOrder()</code> methods of the core default <code>TestExecutionListener</code>                                    implementations for details on what values are assigned to each core listener.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tel-config-merging"><a class="anchor" href="#testcontext-tel-config-merging"></a>Merging <code>TestExecutionListener</code> Implementations</h5>
                            <div class="paragraph">
                                <p>If a custom <code>TestExecutionListener</code> is registered via <code>@TestExecutionListeners</code>, the default listeners are not registered. In most common testing scenarios, this effectively forces the developer to
                                    manually declare all default listeners in addition to any custom listeners. The following listing demonstrates this style of configuration:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners(
    MyCustomTestExecutionListener::class,
    ServletTestExecutionListener::class,
    DirtiesContextBeforeModesTestExecutionListener::class,
    DependencyInjectionTestExecutionListener::class,
    DirtiesContextTestExecutionListener::class,
    TransactionalTestExecutionListener::class,
    SqlScriptsTestExecutionListener::class
)
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>The challenge with this approach is that it requires that the developer know exactly which listeners are registered by default. Moreover, the set of default listeners can change from release to release&#8201;&#8212;&#8201;for
                                    example, <code>SqlScriptsTestExecutionListener</code> was introduced in Spring Framework 4.1, and <code>DirtiesContextBeforeModesTestExecutionListener</code> was introduced in Spring Framework 4.2. Furthermore, third-party
                                    frameworks like Spring Boot and Spring Security register their own default <code>TestExecutionListener</code> implementations by using the aforementioned <a href="#testcontext-tel-config-automatic-discovery">automatic discovery mechanism</a>.</p>
                            </div>
                            <div class="paragraph">
                                <p>To avoid having to be aware of and re-declare all default listeners, you can set the
                                    <code>mergeMode</code> attribute of <code>@TestExecutionListeners</code> to <code>MergeMode.MERGE_WITH_DEFAULTS</code>.
                                    <code>MERGE_WITH_DEFAULTS</code> indicates that locally declared listeners should be merged with the default listeners. The merging algorithm ensures that duplicates are removed from the list and that the resulting
                                    set of merged listeners is sorted according to the semantics of <code>AnnotationAwareOrderComparator</code>, as described in <a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a>.
                                    If a listener implements <code>Ordered</code> or is annotated with <code>@Order</code>, it can influence the position in which it is merged with the defaults. Otherwise, locally declared listeners are appended to the
                                    list of default listeners when merged.</p>
                            </div>
                            <div class="paragraph">
                                <p>For example, if the <code>MyCustomTestExecutionListener</code> class in the previous example configures its <code>order</code> value (for example, <code>500</code>) to be less than the order of the
                                    <code>ServletTestExecutionListener</code> (which happens to be <code>1000</code>), the
                                    <code>MyCustomTestExecutionListener</code> can then be automatically merged with the list of defaults in front of the <code>ServletTestExecutionListener</code>, and the previous example could be replaced with the following:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestExecutionListeners(
        listeners = [MyCustomTestExecutionListener::class],
        mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-application-events"><a class="anchor" href="#testcontext-application-events"></a>3.5.4. Application Events</h4>
                        <div class="paragraph">
                            <p>Since Spring Framework 5.3.3, the TestContext framework provides support for recording
                                <a href="core.html#context-functionality-events">application events</a> published in the
                                <code>ApplicationContext</code> so that assertions can be performed against those events within tests. All events published during the execution of a single test are made available via the <code>ApplicationEvents</code>                                API which allows you to process the events as a
                                <code>java.util.Stream</code>.</p>
                        </div>
                        <div class="paragraph">
                            <p>To use <code>ApplicationEvents</code> in your tests, do the following.</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>Ensure that your test class is annotated or meta-annotated with
                                        <a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a>.</p>
                                </li>
                                <li>
                                    <p>Ensure that the <code>ApplicationEventsTestExecutionListener</code> is registered. Note, however, that <code>ApplicationEventsTestExecutionListener</code> is registered by default and only needs to be manually registered
                                        if you have custom configuration via
                                        <code>@TestExecutionListeners</code> that does not include the default listeners.</p>
                                </li>
                                <li>
                                    <p>Annotate a field of type <code>ApplicationEvents</code> with <code>@Autowired</code> and use that instance of
                                        <code>ApplicationEvents</code> in your test and lifecycle methods (such as <code>@BeforeEach</code> and
                                        <code>@AfterEach</code> methods in JUnit Jupiter).</p>
                                    <div class="ulist">
                                        <ul>
                                            <li>
                                                <p>When using the <a href="#testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</a>, you may declare a method parameter of type <code>ApplicationEvents</code> in a test or lifecycle method
                                                    as an alternative to an <code>@Autowired</code> field in the test class.</p>
                                            </li>
                                        </ul>
                                    </div>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>The following test class uses the <code>SpringExtension</code> for JUnit Jupiter and
                                <a href="https://assertj.github.io/doc/">AssertJ</a> to assert the types of application events published while invoking a method in a Spring-managed component:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(/* ... */)
@RecordApplicationEvents <i class="conum" data-value="1"></i><b>(1)</b>
class OrderServiceTests {

    @Autowired
    OrderService orderService;

    @Autowired
    ApplicationEvents events; <i class="conum" data-value="2"></i><b>(2)</b>

    @Test
    void submitOrder() {
        // Invoke method in OrderService that publishes an event
        orderService.submitOrder(new Order(/* ... */));
        // Verify that an OrderSubmitted event was published
        int numEvents = events.stream(OrderSubmitted.class).count(); <i class="conum" data-value="3"></i><b>(3)</b>
        assertThat(numEvents).isEqualTo(1);
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="colist arabic">
                            <table>
                                <tr>
                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                    <td>Annotate the test class with <code>@RecordApplicationEvents</code>.</td>
                                </tr>
                                <tr>
                                    <td><i class="conum" data-value="2"></i><b>2</b></td>
                                    <td>Inject the <code>ApplicationEvents</code> instance for the current test.</td>
                                </tr>
                                <tr>
                                    <td><i class="conum" data-value="3"></i><b>3</b></td>
                                    <td>Use the <code>ApplicationEvents</code> API to count how many <code>OrderSubmitted</code> events were published.</td>
                                </tr>
                            </table>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(/* ... */)
@RecordApplicationEvents <i class="conum" data-value="1"></i><b>(1)</b>
class OrderServiceTests {

    @Autowired
    lateinit var orderService: OrderService

    @Autowired
    lateinit var events: ApplicationEvents <i class="conum" data-value="2"></i><b>(2)</b>

    @Test
    fun submitOrder() {
        // Invoke method in OrderService that publishes an event
        orderService.submitOrder(Order(/* ... */))
        // Verify that an OrderSubmitted event was published
        val numEvents = events.stream(OrderSubmitted::class).count() <i class="conum" data-value="3"></i><b>(3)</b>
        assertThat(numEvents).isEqualTo(1)
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="colist arabic">
                            <table>
                                <tr>
                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                    <td>Annotate the test class with <code>@RecordApplicationEvents</code>.</td>
                                </tr>
                                <tr>
                                    <td><i class="conum" data-value="2"></i><b>2</b></td>
                                    <td>Inject the <code>ApplicationEvents</code> instance for the current test.</td>
                                </tr>
                                <tr>
                                    <td><i class="conum" data-value="3"></i><b>3</b></td>
                                    <td>Use the <code>ApplicationEvents</code> API to count how many <code>OrderSubmitted</code> events were published.</td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>See the
                                <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/event/ApplicationEvents.html"><code>ApplicationEvents</code>
javadoc</a> for further details regarding the <code>ApplicationEvents</code> API.</p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-test-execution-events"><a class="anchor" href="#testcontext-test-execution-events"></a>3.5.5. Test Execution Events</h4>
                        <div class="paragraph">
                            <p>The <code>EventPublishingTestExecutionListener</code> introduced in Spring Framework 5.2 offers an alternative approach to implementing a custom <code>TestExecutionListener</code>. Components in the test&#8217;s <code>ApplicationContext</code>                                can listen to the following events published by the
                                <code>EventPublishingTestExecutionListener</code>, each of which corresponds to a method in the
                                <code>TestExecutionListener</code> API.</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>BeforeTestClassEvent</code></p>
                                </li>
                                <li>
                                    <p><code>PrepareTestInstanceEvent</code></p>
                                </li>
                                <li>
                                    <p><code>BeforeTestMethodEvent</code></p>
                                </li>
                                <li>
                                    <p><code>BeforeTestExecutionEvent</code></p>
                                </li>
                                <li>
                                    <p><code>AfterTestExecutionEvent</code></p>
                                </li>
                                <li>
                                    <p><code>AfterTestMethodEvent</code></p>
                                </li>
                                <li>
                                    <p><code>AfterTestClassEvent</code></p>
                                </li>
                            </ul>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        These events are only published if the <code>ApplicationContext</code> has already been loaded.
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>These events may be consumed for various reasons, such as resetting mock beans or tracing test execution. One advantage of consuming test execution events rather than implementing a custom <code>TestExecutionListener</code>                                is that test execution events may be consumed by any Spring bean registered in the test <code>ApplicationContext</code>, and such beans may benefit directly from dependency injection and other features of the <code>ApplicationContext</code>.
                                In contrast, a <code>TestExecutionListener</code> is not a bean in the <code>ApplicationContext</code>.</p>
                        </div>
                        <div class="paragraph">
                            <p>In order to listen to test execution events, a Spring bean may choose to implement the
                                <code>org.springframework.context.ApplicationListener</code> interface. Alternatively, listener methods can be annotated with <code>@EventListener</code> and configured to listen to one of the particular event types listed
                                above (see
                                <a href="core.html#context-functionality-events-annotation">Annotation-based Event Listeners</a>). Due to the popularity of this approach, Spring provides the following dedicated
                                <code>@EventListener</code> annotations to simplify registration of test execution event listeners. These annotations reside in the <code>org.springframework.test.context.event.annotation</code> package.
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>@BeforeTestClass</code></p>
                                </li>
                                <li>
                                    <p><code>@PrepareTestInstance</code></p>
                                </li>
                                <li>
                                    <p><code>@BeforeTestMethod</code></p>
                                </li>
                                <li>
                                    <p><code>@BeforeTestExecution</code></p>
                                </li>
                                <li>
                                    <p><code>@AfterTestExecution</code></p>
                                </li>
                                <li>
                                    <p><code>@AfterTestMethod</code></p>
                                </li>
                                <li>
                                    <p><code>@AfterTestClass</code></p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-test-execution-events-exception-handling"><a class="anchor" href="#testcontext-test-execution-events-exception-handling"></a>Exception Handling</h5>
                            <div class="paragraph">
                                <p>By default, if a test execution event listener throws an exception while consuming an event, that exception will propagate to the underlying testing framework in use (such as JUnit or TestNG). For example, if the consumption
                                    of a <code>BeforeTestMethodEvent</code> results in an exception, the corresponding test method will fail as a result of the exception. In contrast, if an asynchronous test execution event listener throws an exception,
                                    the exception will not propagate to the underlying testing framework. For further details on asynchronous exception handling, consult the class-level javadoc for <code>@EventListener</code>.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-test-execution-events-async"><a class="anchor" href="#testcontext-test-execution-events-async"></a>Asynchronous Listeners</h5>
                            <div class="paragraph">
                                <p>If you want a particular test execution event listener to process events asynchronously, you can use Spring&#8217;s <a href="integration.html#scheduling-annotation-support-async">regular
<code>@Async</code> support</a>. For further details, consult the class-level javadoc for
                                    <code>@EventListener</code>.</p>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-ctx-management"><a class="anchor" href="#testcontext-ctx-management"></a>3.5.6. Context Management</h4>
                        <div class="paragraph">
                            <p>Each <code>TestContext</code> provides context management and caching support for the test instance for which it is responsible. Test instances do not automatically receive access to the configured <code>ApplicationContext</code>.
                                However, if a test class implements the
                                <code>ApplicationContextAware</code> interface, a reference to the <code>ApplicationContext</code> is supplied to the test instance. Note that <code>AbstractJUnit4SpringContextTests</code> and
                                <code>AbstractTestNGSpringContextTests</code> implement <code>ApplicationContextAware</code> and, therefore, provide access to the <code>ApplicationContext</code> automatically.</p>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        <div class="title">@Autowired ApplicationContext</div>
                                        <div class="paragraph">
                                            <p>As an alternative to implementing the <code>ApplicationContextAware</code> interface, you can inject the application context for your test class through the <code>@Autowired</code> annotation on either a field
                                                or setter method, as the following example shows:</p>
                                        </div>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    ApplicationContext applicationContext;

    // class body...
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Injecting the <code>ApplicationContext</code>.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    lateinit var applicationContext: ApplicationContext

    // class body...
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Injecting the <code>ApplicationContext</code>.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="paragraph">
                                            <p>Similarly, if your test is configured to load a <code>WebApplicationContext</code>, you can inject the web application context into your test, as follows:</p>
                                        </div>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    WebApplicationContext wac;

    // class body...
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Configuring the <code>WebApplicationContext</code>.</td>
                                                </tr>
                                                <tr>
                                                    <td><i class="conum" data-value="2"></i><b>2</b></td>
                                                    <td>Injecting the <code>WebApplicationContext</code>.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    lateinit var wac: WebApplicationContext
    // class body...
}</code></pre>
                                            </div>
                                        </div>
                                        <div class="colist arabic">
                                            <table>
                                                <tr>
                                                    <td><i class="conum" data-value="1"></i><b>1</b></td>
                                                    <td>Configuring the <code>WebApplicationContext</code>.</td>
                                                </tr>
                                                <tr>
                                                    <td><i class="conum" data-value="2"></i><b>2</b></td>
                                                    <td>Injecting the <code>WebApplicationContext</code>.</td>
                                                </tr>
                                            </table>
                                        </div>
                                        <div class="paragraph">
                                            <p>Dependency injection by using <code>@Autowired</code> is provided by the
                                                <code>DependencyInjectionTestExecutionListener</code>, which is configured by default (see <a href="#testcontext-fixture-di">Dependency Injection of Test Fixtures</a>).</p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>Test classes that use the TestContext framework do not need to extend any particular class or implement a specific interface to configure their application context. Instead, configuration is achieved by declaring the <code>@ContextConfiguration</code>                                annotation at the class level. If your test class does not explicitly declare application context resource locations or component classes, the configured <code>ContextLoader</code> determines how to load a context from
                                a default location or default configuration classes. In addition to context resource locations and component classes, an application context can also be configured through application context initializers.</p>
                        </div>
                        <div class="paragraph">
                            <p>The following sections explain how to use Spring&#8217;s <code>@ContextConfiguration</code> annotation to configure a test <code>ApplicationContext</code> by using XML configuration files, Groovy scripts, component classes
                                (typically <code>@Configuration</code> classes), or context initializers. Alternatively, you can implement and configure your own custom <code>SmartContextLoader</code> for advanced use cases.</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-caching">Context Caching</a></p>
                                </li>
                                <li>
                                    <p><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></p>
                                </li>
                            </ul>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-xml"><a class="anchor" href="#testcontext-ctx-management-xml"></a>Context Configuration with XML resources</h5>
                            <div class="paragraph">
                                <p>To load an <code>ApplicationContext</code> for your tests by using XML configuration files, annotate your test class with <code>@ContextConfiguration</code> and configure the <code>locations</code> attribute with an array
                                    that contains the resource locations of XML configuration metadata. A plain or relative path (for example, <code>context.xml</code>) is treated as a classpath resource that is relative to the package in which the test
                                    class is defined. A path starting with a slash is treated as an absolute classpath location (for example, <code>/org/example/config.xml</code>). A path that represents a resource URL (i.e., a path prefixed with <code>classpath:</code>,
                                    <code>file:</code>,
                                    <code>http:</code>, etc.) is used <em>as is</em>.</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Setting the locations attribute to a list of XML files.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Setting the locations attribute to a list of XML files.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p><code>@ContextConfiguration</code> supports an alias for the <code>locations</code> attribute through the standard Java <code>value</code> attribute. Thus, if you do not need to declare additional attributes in <code>@ContextConfiguration</code>,
                                    you can omit the declaration of the <code>locations</code> attribute name and declare the resource locations by using the shorthand format demonstrated in the following example:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying XML files without using the <code>location</code> attribute.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying XML files without using the <code>location</code> attribute.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>If you omit both the <code>locations</code> and the <code>value</code> attributes from the
                                    <code>@ContextConfiguration</code> annotation, the TestContext framework tries to detect a default XML resource location. Specifically, <code>GenericXmlContextLoader</code> and
                                    <code>GenericXmlWebContextLoader</code> detect a default location based on the name of the test class. If your class is named <code>com.example.MyTest</code>, <code>GenericXmlContextLoader</code> loads your application
                                    context from <code>"classpath:com/example/MyTest-context.xml"</code>. The following example shows how to do so:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration from the default location.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration from the default location.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-groovy"><a class="anchor" href="#testcontext-ctx-management-groovy"></a>Context Configuration with Groovy Scripts</h5>
                            <div class="paragraph">
                                <p>To load an <code>ApplicationContext</code> for your tests by using Groovy scripts that use the
                                    <a href="core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a>, you can annotate your test class with <code>@ContextConfiguration</code> and configure the <code>locations</code> or <code>value</code>                                    attribute with an array that contains the resource locations of Groovy scripts. Resource lookup semantics for Groovy scripts are the same as those described for
                                    <a href="#testcontext-ctx-management-xml">XML configuration files</a>.</p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Enabling Groovy script support</div>
                                            Support for using Groovy scripts to load an <code>ApplicationContext</code> in the Spring TestContext Framework is enabled automatically if Groovy is on the classpath.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to specify Groovy configuration files:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration("/AppConfig.groovy", "/TestConfig.Groovy") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying the location of Groovy configuration files.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>If you omit both the <code>locations</code> and <code>value</code> attributes from the <code>@ContextConfiguration</code> annotation, the TestContext framework tries to detect a default Groovy script. Specifically, <code>GenericGroovyXmlContextLoader</code>                                    and <code>GenericGroovyXmlWebContextLoader</code> detect a default location based on the name of the test class. If your class is named
                                    <code>com.example.MyTest</code>, the Groovy context loader loads your application context from
                                    <code>"classpath:com/example/MyTestContext.groovy"</code>. The following example shows how to use the default:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration from the default location.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration from the default location.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Declaring XML configuration and Groovy scripts simultaneously</div>
                                            <div class="paragraph">
                                                <p>You can declare both XML configuration files and Groovy scripts simultaneously by using the <code>locations</code> or <code>value</code> attribute of <code>@ContextConfiguration</code>. If the path to a
                                                    configured resource location ends with <code>.xml</code>, it is loaded by using an
                                                    <code>XmlBeanDefinitionReader</code>. Otherwise, it is loaded by using a
                                                    <code>GroovyBeanDefinitionReader</code>.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>The following listing shows how to combine both in an integration test:</p>
                                            </div>
                                            <div class="listingblock primary">
                                                <div class="title">Java</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
class MyTest {
    // class body...
}</code></pre>
                                                </div>
                                            </div>
                                            <div class="listingblock secondary">
                                                <div class="title">Kotlin</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration("/app-config.xml", "/TestConfig.groovy")
class MyTest {
    // class body...
}</code></pre>
                                                </div>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-javaconfig"><a class="anchor" href="#testcontext-ctx-management-javaconfig"></a>Context Configuration with Component Classes</h5>
                            <div class="paragraph">
                                <p>To load an <code>ApplicationContext</code> for your tests by using component classes (see
                                    <a href="core.html#beans-java">Java-based container configuration</a>), you can annotate your test class with <code>@ContextConfiguration</code> and configure the <code>classes</code> attribute with an array that contains
                                    references to component classes. The following example shows how to do so:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying component classes.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying component classes.</td>
                                    </tr>
                                </table>
                            </div>
                            <div id="testcontext-ctx-management-javaconfig-component-classes" class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Component Classes</div>
                                            <div class="paragraph">
                                                <p>The term &#8220;component class&#8221; can refer to any of the following:</p>
                                            </div>
                                            <div class="ulist">
                                                <ul>
                                                    <li>
                                                        <p>A class annotated with <code>@Configuration</code>.</p>
                                                    </li>
                                                    <li>
                                                        <p>A component (that is, a class annotated with <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, or other stereotype annotations).</p>
                                                    </li>
                                                    <li>
                                                        <p>A JSR-330 compliant class that is annotated with <code>javax.inject</code> annotations.</p>
                                                    </li>
                                                    <li>
                                                        <p>Any class that contains <code>@Bean</code>-methods.</p>
                                                    </li>
                                                    <li>
                                                        <p>Any other class that is intended to be registered as a Spring component (i.e., a Spring bean in the <code>ApplicationContext</code>), potentially taking advantage of automatic autowiring of a single
                                                            constructor without the use of Spring annotations.</p>
                                                    </li>
                                                </ul>
                                            </div>
                                            <div class="paragraph">
                                                <p>See the javadoc of
                                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> and
                                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a> for further information regarding the configuration and
                                                    semantics of component classes, paying special attention to the discussion of <code>@Bean</code> Lite Mode.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>If you omit the <code>classes</code> attribute from the <code>@ContextConfiguration</code> annotation, the TestContext framework tries to detect the presence of default configuration classes. Specifically, <code>AnnotationConfigContextLoader</code>                                    and <code>AnnotationConfigWebContextLoader</code> detect all <code>static</code> nested classes of the test class that meet the requirements for configuration class implementations, as specified in the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> javadoc. Note that the name of the configuration class
                                    is arbitrary. In addition, a test class can contain more than one <code>static</code> nested configuration class if desired. In the following example, the <code>OrderServiceTest</code> class declares a <code>static</code>                                    nested configuration class named <code>Config</code> that is automatically used to load the <code>ApplicationContext</code> for the test class:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration information from the nested <code>Config</code> class.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the nested Config class
class OrderServiceTest {

    @Autowired
    lateinit var orderService: OrderService

    @Configuration
    class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        fun orderService(): OrderService {
            // set properties, etc.
            return OrderServiceImpl()
        }
    }

    @Test
    fun testOrderService() {
        // test the orderService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Loading configuration information from the nested <code>Config</code> class.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-mixed-config"><a class="anchor" href="#testcontext-ctx-management-mixed-config"></a>Mixing XML, Groovy Scripts, and Component Classes</h5>
                            <div class="paragraph">
                                <p>It may sometimes be desirable to mix XML configuration files, Groovy scripts, and component classes (typically <code>@Configuration</code> classes) to configure an
                                    <code>ApplicationContext</code> for your tests. For example, if you use XML configuration in production, you may decide that you want to use <code>@Configuration</code> classes to configure specific Spring-managed components
                                    for your tests, or vice versa.</p>
                            </div>
                            <div class="paragraph">
                                <p>Furthermore, some third-party frameworks (such as Spring Boot) provide first-class support for loading an <code>ApplicationContext</code> from different types of resources simultaneously (for example, XML configuration
                                    files, Groovy scripts, and
                                    <code>@Configuration</code> classes). The Spring Framework, historically, has not supported this for standard deployments. Consequently, most of the <code>SmartContextLoader</code> implementations that the Spring Framework
                                    delivers in the <code>spring-test</code> module support only one resource type for each test context. However, this does not mean that you cannot use both. One exception to the general rule is that the <code>GenericGroovyXmlContextLoader</code>                                    and
                                    <code>GenericGroovyXmlWebContextLoader</code> support both XML configuration files and Groovy scripts simultaneously. Furthermore, third-party frameworks may choose to support the declaration of both <code>locations</code>                                    and <code>classes</code> through <code>@ContextConfiguration</code>, and, with the standard testing support in the TestContext framework, you have the following options.</p>
                            </div>
                            <div class="paragraph">
                                <p>If you want to use resource locations (for example, XML or Groovy) and <code>@Configuration</code> classes to configure your tests, you must pick one as the entry point, and that one must include or import the other. For
                                    example, in XML or Groovy scripts, you can include
                                    <code>@Configuration</code> classes by using component scanning or defining them as normal Spring beans, whereas, in a <code>@Configuration</code> class, you can use <code>@ImportResource</code> to import XML configuration
                                    files or Groovy scripts. Note that this behavior is semantically equivalent to how you configure your application in production: In production configuration, you define either a set of XML or Groovy resource locations
                                    or a set of <code>@Configuration</code> classes from which your production <code>ApplicationContext</code> is loaded, but you still have the freedom to include or import the other type of configuration.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-initializers"><a class="anchor" href="#testcontext-ctx-management-initializers"></a>Context Configuration with Context Initializers</h5>
                            <div class="paragraph">
                                <p>To configure an <code>ApplicationContext</code> for your tests by using context initializers, annotate your test class with <code>@ContextConfiguration</code> and configure the <code>initializers</code> attribute with an
                                    array that contains references to classes that implement
                                    <code>ApplicationContextInitializer</code>. The declared context initializers are then used to initialize the <code>ConfigurableApplicationContext</code> that is loaded for your tests. Note that the concrete <code>ConfigurableApplicationContext</code>                                    type supported by each declared initializer must be compatible with the type of <code>ApplicationContext</code> created by the
                                    <code>SmartContextLoader</code> in use (typically a <code>GenericApplicationContext</code>). Furthermore, the order in which the initializers are invoked depends on whether they implement Spring&#8217;s
                                    <code>Ordered</code> interface or are annotated with Spring&#8217;s <code>@Order</code> annotation or the standard
                                    <code>@Priority</code> annotation. The following example shows how to use initializers:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying configuration by using a configuration class and an initializer.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
        classes = [TestConfig::class],
        initializers = [TestAppCtxInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying configuration by using a configuration class and an initializer.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>You can also omit the declaration of XML configuration files, Groovy scripts, or component classes in <code>@ContextConfiguration</code> entirely and instead declare only
                                    <code>ApplicationContextInitializer</code> classes, which are then responsible for registering beans in the context&#8201;&#8212;&#8201;for example, by programmatically loading bean definitions from XML files or configuration
                                    classes. The following example shows how to do so:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying configuration by using only an initializer.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = [EntireAppInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specifying configuration by using only an initializer.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-inheritance"><a class="anchor" href="#testcontext-ctx-management-inheritance"></a>Context Configuration Inheritance</h5>
                            <div class="paragraph">
                                <p><code>@ContextConfiguration</code> supports boolean <code>inheritLocations</code> and <code>inheritInitializers</code> attributes that denote whether resource locations or component classes and context initializers declared
                                    by superclasses should be inherited. The default value for both flags is <code>true</code>. This means that a test class inherits the resource locations or component classes as well as the context initializers declared
                                    by any superclasses. Specifically, the resource locations or component classes for a test class are appended to the list of resource locations or annotated classes declared by superclasses. Similarly, the initializers
                                    for a given test class are added to the set of initializers defined by test superclasses. Thus, subclasses have the option of extending the resource locations, component classes, or context initializers.</p>
                            </div>
                            <div class="paragraph">
                                <p>If the <code>inheritLocations</code> or <code>inheritInitializers</code> attribute in <code>@ContextConfiguration</code> is set to <code>false</code>, the resource locations or component classes and the context initializers,
                                    respectively, for the test class shadow and effectively replace the configuration defined by superclasses.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>                                            for details.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>In the next example, which uses XML resource locations, the <code>ApplicationContext</code> for
                                    <code>ExtendedTest</code> is loaded from <code>base-config.xml</code> and <code>extended-config.xml</code>, in that order. Beans defined in <code>extended-config.xml</code> can, therefore, override (that is, replace)
                                    those defined in <code>base-config.xml</code>. The following example shows how one class can extend another and use both its own configuration file and the superclass&#8217;s configuration file:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuration file defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Configuration file defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuration file defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Configuration file defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>Similarly, in the next example, which uses component classes, the <code>ApplicationContext</code> for <code>ExtendedTest</code> is loaded from the <code>BaseConfig</code> and <code>ExtendedConfig</code> classes, in that
                                    order. Beans defined in <code>ExtendedConfig</code> can, therefore, override (that is, replace) those defined in <code>BaseConfig</code>. The following example shows how one class can extend another and use both its
                                    own configuration class and the superclass&#8217;s configuration class:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuration class defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Configuration class defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig::class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Configuration class defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Configuration class defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>In the next example, which uses context initializers, the <code>ApplicationContext</code> for
                                    <code>ExtendedTest</code> is initialized by using <code>BaseInitializer</code> and <code>ExtendedInitializer</code>. Note, however, that the order in which the initializers are invoked depends on whether they implement
                                    Spring&#8217;s <code>Ordered</code> interface or are annotated with Spring&#8217;s <code>@Order</code> annotation or the standard <code>@Priority</code> annotation. The following example shows how one class can extend
                                    another and use both its own initializer and the superclass&#8217;s initializer:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Initializer defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Initializer defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = [BaseInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Initializer defined in the superclass.</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Initializer defined in the subclass.</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-env-profiles"><a class="anchor" href="#testcontext-ctx-management-env-profiles"></a>Context Configuration with Environment Profiles</h5>
                            <div class="paragraph">
                                <p>The Spring Framework has first-class support for the notion of environments and profiles (AKA "bean definition profiles"), and integration tests can be configured to activate particular bean definition profiles for various
                                    testing scenarios. This is achieved by annotating a test class with the <code>@ActiveProfiles</code> annotation and supplying a list of profiles that should be activated when loading the <code>ApplicationContext</code>                                    for the test.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            You can use <code>@ActiveProfiles</code> with any implementation of the <code>SmartContextLoader</code> SPI, but <code>@ActiveProfiles</code> is not supported with implementations of the older
                                            <code>ContextLoader</code> SPI.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>Consider two examples with XML configuration and <code>@Configuration</code> classes:</p>
                            </div>
                            <div class="listingblock">
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- app-config.xml --&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;bean id="transferService"
            class="com.bank.service.internal.DefaultTransferService"&gt;
        &lt;constructor-arg ref="accountRepository"/&gt;
        &lt;constructor-arg ref="feePolicy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="accountRepository"
            class="com.bank.repository.internal.JdbcAccountRepository"&gt;
        &lt;constructor-arg ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="feePolicy"
        class="com.bank.service.internal.ZeroFeePolicy"/&gt;

    &lt;beans profile="dev"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;

    &lt;beans profile="default"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

&lt;/beans&gt;</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>When <code>TransferServiceTest</code> is run, its <code>ApplicationContext</code> is loaded from the
                                    <code>app-config.xml</code> configuration file in the root of the classpath. If you inspect
                                    <code>app-config.xml</code>, you can see that the <code>accountRepository</code> bean has a dependency on a
                                    <code>dataSource</code> bean. However, <code>dataSource</code> is not defined as a top-level bean. Instead,
                                    <code>dataSource</code> is defined three times: in the <code>production</code> profile, in the <code>dev</code> profile, and in the <code>default</code> profile.</p>
                            </div>
                            <div class="paragraph">
                                <p>By annotating <code>TransferServiceTest</code> with <code>@ActiveProfiles("dev")</code>, we instruct the Spring TestContext Framework to load the <code>ApplicationContext</code> with the active profiles set to
                                    <code>{"dev"}</code>. As a result, an embedded database is created and populated with test data, and the <code>accountRepository</code> bean is wired with a reference to the development <code>DataSource</code>. That
                                    is likely what we want in an integration test.</p>
                            </div>
                            <div class="paragraph">
                                <p>It is sometimes useful to assign beans to a <code>default</code> profile. Beans within the default profile are included only when no other profile is specifically activated. You can use this to define &#8220;fallback&#8221;
                                    beans to be used in the application&#8217;s default state. For example, you may explicitly provide a data source for <code>dev</code> and <code>production</code> profiles, but define an in-memory data source as a default
                                    when neither of these is active.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following code listings demonstrate how to implement the same configuration and integration test with <code>@Configuration</code> classes instead of XML:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("dev")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class TransferServiceConfig {

    @Autowired
    lateinit var dataSource: DataSource

    @Bean
    fun transferService(): TransferService {
        return DefaultTransferService(accountRepository(), feePolicy())
    }

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun feePolicy(): FeePolicy {
        return ZeroFeePolicy()
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>In this variation, we have split the XML configuration into four independent
                                    <code>@Configuration</code> classes:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>TransferServiceConfig</code>: Acquires a <code>dataSource</code> through dependency injection by using
                                            <code>@Autowired</code>.</p>
                                    </li>
                                    <li>
                                        <p><code>StandaloneDataConfig</code>: Defines a <code>dataSource</code> for an embedded database suitable for developer tests.</p>
                                    </li>
                                    <li>
                                        <p><code>JndiDataConfig</code>: Defines a <code>dataSource</code> that is retrieved from JNDI in a production environment.
                                        </p>
                                    </li>
                                    <li>
                                        <p><code>DefaultDataConfig</code>: Defines a <code>dataSource</code> for a default embedded database, in case no profile is active.</p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>As with the XML-based configuration example, we still annotate <code>TransferServiceTest</code> with
                                    <code>@ActiveProfiles("dev")</code>, but this time we specify all four configuration classes by using the <code>@ContextConfiguration</code> annotation. The body of the test class itself remains completely unchanged.</p>
                            </div>
                            <div class="paragraph">
                                <p>It is often the case that a single set of profiles is used across multiple test classes within a given project. Thus, to avoid duplicate declarations of the <code>@ActiveProfiles</code> annotation, you can declare <code>@ActiveProfiles</code>                                    once on a base class, and subclasses automatically inherit the <code>@ActiveProfiles</code> configuration from the base class. In the following example, the declaration of <code>@ActiveProfiles</code> (as well as other
                                    annotations) has been moved to an abstract superclass, <code>AbstractIntegrationTest</code>:</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>                                            for details.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile inherited from superclass
class TransferServiceTest : AbstractIntegrationTest() {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p><code>@ActiveProfiles</code> also supports an <code>inheritProfiles</code> attribute that can be used to disable the inheritance of active profiles, as the following example shows:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile overridden with "production"
@ActiveProfiles("production", inheritProfiles = false)
class ProductionTransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
                                </div>
                            </div>
                            <div id="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" class="paragraph">
                                <p>Furthermore, it is sometimes necessary to resolve active profiles for tests programmatically instead of declaratively&#8201;&#8212;&#8201;for example, based on:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>The current operating system.</p>
                                    </li>
                                    <li>
                                        <p>Whether tests are being run on a continuous integration build server.</p>
                                    </li>
                                    <li>
                                        <p>The presence of certain environment variables.</p>
                                    </li>
                                    <li>
                                        <p>The presence of custom class-level annotations.</p>
                                    </li>
                                    <li>
                                        <p>Other concerns.</p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>To resolve active bean definition profiles programmatically, you can implement a custom <code>ActiveProfilesResolver</code> and register it by using the <code>resolver</code> attribute of <code>@ActiveProfiles</code>. For
                                    further information, see the corresponding
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a>. The following example demonstrates how to implement and register a custom
                                    <code>OperatingSystemActiveProfilesResolver</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver::class,
        inheritProfiles = false)
class TransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {

    override fun resolve(testClass: Class&lt;*&gt;): Array&lt;String&gt; {
        val profile: String = ...
        // determine the value of profile based on the operating system
        return arrayOf(profile)
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-property-sources"><a class="anchor" href="#testcontext-ctx-management-property-sources"></a>Context Configuration with Test Property Sources</h5>
                            <div class="paragraph">
                                <p>The Spring Framework has first-class support for the notion of an environment with a hierarchy of property sources, and you can configure integration tests with test-specific property sources. In contrast to the <code>@PropertySource</code>                                    annotation used on
                                    <code>@Configuration</code> classes, you can declare the <code>@TestPropertySource</code> annotation on a test class to declare resource locations for test properties files or inlined properties. These test property
                                    sources are added to the set of <code>PropertySources</code> in the
                                    <code>Environment</code> for the <code>ApplicationContext</code> loaded for the annotated integration test.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <div class="paragraph">
                                                <p>You can use <code>@TestPropertySource</code> with any implementation of the <code>SmartContextLoader</code> SPI, but <code>@TestPropertySource</code> is not supported with implementations of the older
                                                    <code>ContextLoader</code> SPI.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>Implementations of <code>SmartContextLoader</code> gain access to merged test property source values through the <code>getPropertySourceLocations()</code> and <code>getPropertySourceProperties()</code> methods
                                                    in
                                                    <code>MergedContextConfiguration</code>.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="sect5">
                                <h6 id="declaring-test-property-sources"><a class="anchor" href="#declaring-test-property-sources"></a>Declaring Test Property Sources</h6>
                                <div class="paragraph">
                                    <p>You can configure test properties files by using the <code>locations</code> or <code>value</code> attribute of
                                        <code>@TestPropertySource</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Both traditional and XML-based properties file formats are supported&#8201;&#8212;&#8201;for example,
                                        <code>"classpath:/com/example/test.properties"</code> or <code>"file:///path/to/file.xml"</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Each path is interpreted as a Spring <code>Resource</code>. A plain path (for example,
                                        <code>"test.properties"</code>) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath resource (for
                                        example: <code>"/org/example/test.xml"</code>). A path that references a URL (for example, a path prefixed with <code>classpath:</code>, <code>file:</code>, or <code>http:</code>) is loaded by using the specified
                                        resource protocol. Resource location wildcards (such as
                                        <code><strong>*/</strong>.properties</code>) are not permitted: Each location must evaluate to exactly one
                                        <code>.properties</code> or <code>.xml</code> resource.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The following example uses a test properties file:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td>Specifying a properties file with an absolute path.</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td>Specifying a properties file with an absolute path.</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>You can configure inlined properties in the form of key-value pairs by using the
                                        <code>properties</code> attribute of <code>@TestPropertySource</code>, as shown in the next example. All key-value pairs are added to the enclosing <code>Environment</code> as a single test
                                        <code>PropertySource</code> with the highest precedence.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The supported syntax for key-value pairs is the same as the syntax defined for entries in a Java properties file:</p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p><code>key=value</code></p>
                                        </li>
                                        <li>
                                            <p><code>key:value</code></p>
                                        </li>
                                        <li>
                                            <p><code>key value</code></p>
                                        </li>
                                    </ul>
                                </div>
                                <div class="paragraph">
                                    <p>The following example sets two inlined properties:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td>Setting two properties by using two variations of the key-value syntax.</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td>Setting two properties by using two variations of the key-value syntax.</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                <div class="paragraph">
                                                    <p>As of Spring Framework 5.2, <code>@TestPropertySource</code> can be used as <em>repeatable annotation</em>. That means that you can have multiple declarations of <code>@TestPropertySource</code> on a
                                                        single test class, with the <code>locations</code> and <code>properties</code> from later <code>@TestPropertySource</code> annotations overriding those from previous <code>@TestPropertySource</code>                                                        annotations.</p>
                                                </div>
                                                <div class="paragraph">
                                                    <p>In addition, you may declare multiple composed annotations on a test class that are each meta-annotated with <code>@TestPropertySource</code>, and all of those <code>@TestPropertySource</code> declarations
                                                        will contribute to your test property sources.</p>
                                                </div>
                                                <div class="paragraph">
                                                    <p>Directly present <code>@TestPropertySource</code> annotations always take precedence over meta-present <code>@TestPropertySource</code> annotations. In other words, <code>locations</code> and
                                                        <code>properties</code> from a directly present <code>@TestPropertySource</code> annotation will override the
                                                        <code>locations</code> and <code>properties</code> from a <code>@TestPropertySource</code> annotation used as a meta-annotation.
                                                    </p>
                                                </div>
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="default-properties-file-detection"><a class="anchor" href="#default-properties-file-detection"></a>Default Properties File Detection</h6>
                                <div class="paragraph">
                                    <p>If <code>@TestPropertySource</code> is declared as an empty annotation (that is, without explicit values for the <code>locations</code> or <code>properties</code> attributes), an attempt is made to detect a default
                                        properties file relative to the class that declared the annotation. For example, if the annotated test class is <code>com.example.MyTest</code>, the corresponding default properties file is <code>classpath:com/example/MyTest.properties</code>.
                                        If the default cannot be detected, an
                                        <code>IllegalStateException</code> is thrown.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="precedence"><a class="anchor" href="#precedence"></a>Precedence</h6>
                                <div class="paragraph">
                                    <p>Test properties have higher precedence than those defined in the operating system&#8217;s environment, Java system properties, or property sources added by the application declaratively by using <code>@PropertySource</code>                                        or programmatically. Thus, test properties can be used to selectively override properties loaded from system and application property sources. Furthermore, inlined properties have higher precedence than properties
                                        loaded from resource locations. Note, however, that properties registered via
                                        <a href="#testcontext-ctx-management-dynamic-property-sources"><code>@DynamicPropertySource</code></a> have higher precedence than those loaded via <code>@TestPropertySource</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>In the next example, the <code>timezone</code> and <code>port</code> properties and any properties defined in
                                        <code>"/test.properties"</code> override any properties of the same name that are defined in system and application property sources. Furthermore, if the <code>"/test.properties"</code> file defines entries for
                                        the <code>timezone</code> and <code>port</code> properties those are overridden by the inlined properties declared by using the <code>properties</code> attribute. The following example shows how to specify properties
                                        both in a file and inline:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties",
        properties = ["timezone = GMT", "port: 4242"]
)
class MyIntegrationTests {
    // class body...
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="inheriting-and-overriding-test-property-sources"><a class="anchor" href="#inheriting-and-overriding-test-property-sources"></a>Inheriting and Overriding Test Property Sources</h6>
                                <div class="paragraph">
                                    <p><code>@TestPropertySource</code> supports boolean <code>inheritLocations</code> and <code>inheritProperties</code> attributes that denote whether resource locations for properties files and inlined properties declared
                                        by superclasses should be inherited. The default value for both flags is <code>true</code>. This means that a test class inherits the locations and inlined properties declared by any superclasses. Specifically,
                                        the locations and inlined properties for a test class are appended to the locations and inlined properties declared by superclasses. Thus, subclasses have the option of extending the locations and inlined properties.
                                        Note that properties that appear later shadow (that is, override) properties of the same name that appear earlier. In addition, the aforementioned precedence rules apply for inherited test property sources as well.</p>
                                </div>
                                <div class="paragraph">
                                    <p>If the <code>inheritLocations</code> or <code>inheritProperties</code> attribute in <code>@TestPropertySource</code> is set to <code>false</code>, the locations or inlined properties, respectively, for the test class
                                        shadow and effectively replace the configuration defined by superclasses.</p>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>                                                for details.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>In the next example, the <code>ApplicationContext</code> for <code>BaseTest</code> is loaded by using only the
                                        <code>base.properties</code> file as a test property source. In contrast, the <code>ApplicationContext</code> for <code>ExtendedTest</code> is loaded by using the <code>base.properties</code> and <code>extended.properties</code>                                        files as test property source locations. The following example shows how to define properties in both a subclass and its superclass by using <code>properties</code> files:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TestPropertySource("base.properties")
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>In the next example, the <code>ApplicationContext</code> for <code>BaseTest</code> is loaded by using only the inlined <code>key1</code> property. In contrast, the <code>ApplicationContext</code> for <code>ExtendedTest</code>                                        is loaded by using the inlined <code>key1</code> and <code>key2</code> properties. The following example shows how to define properties in both a subclass and its superclass by using inline properties:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TestPropertySource(properties = "key1 = value1")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = "key2 = value2")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TestPropertySource(properties = ["key1 = value1"])
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource(properties = ["key2 = value2"])
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-dynamic-property-sources"><a class="anchor" href="#testcontext-ctx-management-dynamic-property-sources"></a>Context Configuration with Dynamic Property Sources</h5>
                            <div class="paragraph">
                                <p>As of Spring Framework 5.2.5, the TestContext framework provides support for <em>dynamic</em> properties via the <code>@DynamicPropertySource</code> annotation. This annotation can be used in integration tests that need
                                    to add properties with dynamic values to the set of
                                    <code>PropertySources</code> in the <code>Environment</code> for the <code>ApplicationContext</code> loaded for the integration test.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <div class="paragraph">
                                                <p>The <code>@DynamicPropertySource</code> annotation and its supporting infrastructure were originally designed to allow properties from
                                                    <a href="https://www.testcontainers.org/">Testcontainers</a> based tests to be exposed easily to Spring integration tests. However, this feature may also be used with any form of external resource whose
                                                    lifecycle is maintained outside the test&#8217;s <code>ApplicationContext</code>.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>In contrast to the <a href="#testcontext-ctx-management-property-sources"><code>@TestPropertySource</code></a> annotation that is applied at the class level, <code>@DynamicPropertySource</code> must be applied to a <code>static</code>                                    method that accepts a single <code>DynamicPropertyRegistry</code> argument which is used to add <em>name-value</em> pairs to the <code>Environment</code>. Values are dynamic and provided via a <code>Supplier</code>                                    which is only invoked when the property is resolved. Typically, method references are used to supply values, as can be seen in the following example which uses the Testcontainers project to manage a Redis container
                                    outside of the Spring
                                    <code>ApplicationContext</code>. The IP address and port of the managed Redis container are made available to components within the test&#8217;s <code>ApplicationContext</code> via the <code>redis.host</code> and
                                    <code>redis.port</code> properties. These properties can be accessed via Spring&#8217;s <code>Environment</code> abstraction or injected directly into Spring-managed components – for example, via
                                    <code>@Value("${redis.host}")</code> and <code>@Value("${redis.port}")</code>, respectively.</p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="paragraph">
                                                <p>If you use <code>@DynamicPropertySource</code> in a base class and discover that tests in subclasses fail because the dynamic properties change between subclasses, you may need to annotate your base class
                                                    with <a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a> to ensure that each subclass gets its own <code>ApplicationContext</code> with the correct dynamic properties.
                                                </p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("redis.host", redis::getContainerIpAddress);
        registry.add("redis.port", redis::getMappedPort);
    }

    // tests ...

}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    companion object {

        @Container
        @JvmStatic
        val redis: RedisContainer = RedisContainer()

        @DynamicPropertySource
        @JvmStatic
        fun redisProperties(registry: DynamicPropertyRegistry) {
            registry.add("redis.host", redis::getContainerIpAddress)
            registry.add("redis.port", redis::getMappedPort)
        }
    }

    // tests ...

}</code></pre>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="precedence-2"><a class="anchor" href="#precedence-2"></a>Precedence</h6>
                                <div class="paragraph">
                                    <p>Dynamic properties have higher precedence than those loaded from <code>@TestPropertySource</code>, the operating system&#8217;s environment, Java system properties, or property sources added by the application declaratively
                                        by using <code>@PropertySource</code> or programmatically. Thus, dynamic properties can be used to selectively override properties loaded via
                                        <code>@TestPropertySource</code>, system property sources, and application property sources.</p>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-web"><a class="anchor" href="#testcontext-ctx-management-web"></a>Loading a <code>WebApplicationContext</code></h5>
                            <div class="paragraph">
                                <p>To instruct the TestContext framework to load a <code>WebApplicationContext</code> instead of a standard <code>ApplicationContext</code>, you can annotate the respective test class with
                                    <code>@WebAppConfiguration</code>.</p>
                            </div>
                            <div class="paragraph">
                                <p>The presence of <code>@WebAppConfiguration</code> on your test class instructs the TestContext framework (TCF) that a <code>WebApplicationContext</code> (WAC) should be loaded for your integration tests. In the background,
                                    the TCF makes sure that a <code>MockServletContext</code> is created and supplied to your test&#8217;s WAC. By default, the base resource path for your
                                    <code>MockServletContext</code> is set to <code>src/main/webapp</code>. This is interpreted as a path relative to the root of your JVM (normally the path to your project). If you are familiar with the directory structure
                                    of a web application in a Maven project, you know that
                                    <code>src/main/webapp</code> is the default location for the root of your WAR. If you need to override this default, you can provide an alternate path to the <code>@WebAppConfiguration</code> annotation (for example,
                                    <code>@WebAppConfiguration("src/test/webapp")</code>). If you wish to reference a base resource path from the classpath instead of the file system, you can use Spring&#8217;s <code>classpath:</code> prefix.</p>
                            </div>
                            <div class="paragraph">
                                <p>Note that Spring&#8217;s testing support for <code>WebApplicationContext</code> implementations is on par with its support for standard <code>ApplicationContext</code> implementations. When testing with a
                                    <code>WebApplicationContext</code>, you are free to declare XML configuration files, Groovy scripts, or <code>@Configuration</code> classes by using <code>@ContextConfiguration</code>. You are also free to use any other
                                    test annotations, such as <code>@ActiveProfiles</code>, <code>@TestExecutionListeners</code>, <code>@Sql</code>,
                                    <code>@Rollback</code>, and others.</p>
                            </div>
                            <div class="paragraph">
                                <p>The remaining examples in this section show some of the various configuration options for loading a <code>WebApplicationContext</code>. The following example shows the TestContext framework&#8217;s support for convention
                                    over configuration:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>If you annotate a test class with <code>@WebAppConfiguration</code> without specifying a resource base path, the resource path effectively defaults to <code>file:src/main/webapp</code>. Similarly, if you declare <code>@ContextConfiguration</code>                                    without specifying resource <code>locations</code>, component
                                    <code>classes</code>, or context <code>initializers</code>, Spring tries to detect the presence of your configuration by using conventions (that is, <code>WacTests-context.xml</code> in the same package as the <code>WacTests</code>                                    class or static nested <code>@Configuration</code> classes).</p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows how to explicitly declare a resource base path with
                                    <code>@WebAppConfiguration</code> and an XML resource location with <code>@ContextConfiguration</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>The important thing to note here is the different semantics for paths with these two annotations. By default, <code>@WebAppConfiguration</code> resource paths are file system based, whereas <code>@ContextConfiguration</code>                                    resource locations are classpath based.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following example shows that we can override the default resource semantics for both annotations by specifying a Spring resource prefix:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Contrast the comments in this example with the previous example.</p>
                            </div>
                            <div class="openblock">
                                <div class="title"><a id="testcontext-ctx-management-web-mocks"></a>Working with Web Mocks</div>
                                <div class="content">
                                    <div class="paragraph">
                                        <p>To provide comprehensive web testing support, the TestContext framework has a
                                            <code>ServletTestExecutionListener</code> that is enabled by default. When testing against a
                                            <code>WebApplicationContext</code>, this <a href="#testcontext-key-abstractions"><code>TestExecutionListener</code></a> sets up default thread-local state by using Spring Web&#8217;s <code>RequestContextHolder</code>                                            before each test method and creates a <code>MockHttpServletRequest</code>, a <code>MockHttpServletResponse</code>, and a <code>ServletWebRequest</code> based on the base resource path configured with
                                            <code>@WebAppConfiguration</code>. <code>ServletTestExecutionListener</code> also ensures that the
                                            <code>MockHttpServletResponse</code> and <code>ServletWebRequest</code> can be injected into the test instance, and, once the test is complete, it cleans up thread-local state.</p>
                                    </div>
                                    <div class="paragraph">
                                        <p>Once you have a <code>WebApplicationContext</code> loaded for your test, you might find that you need to interact with the web mocks&#8201;&#8212;&#8201;for example, to set up your test fixture or to perform assertions
                                            after invoking your web component. The following example shows which mocks can be autowired into your test instance. Note that the <code>WebApplicationContext</code> and
                                            <code>MockServletContext</code> are both cached across the test suite, whereas the other mocks are managed per test method by the <code>ServletTestExecutionListener</code>.</p>
                                    </div>
                                    <div class="listingblock primary">
                                        <div class="title">Java</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}</code></pre>
                                        </div>
                                    </div>
                                    <div class="listingblock secondary">
                                        <div class="title">Kotlin</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    lateinit var wac: WebApplicationContext // cached

    @Autowired
    lateinit var servletContext: MockServletContext // cached

    @Autowired
    lateinit var session: MockHttpSession

    @Autowired
    lateinit var request: MockHttpServletRequest

    @Autowired
    lateinit var response: MockHttpServletResponse

    @Autowired
    lateinit var webRequest: ServletWebRequest

    //...
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-caching"><a class="anchor" href="#testcontext-ctx-management-caching"></a>Context Caching</h5>
                            <div class="paragraph">
                                <p>Once the TestContext framework loads an <code>ApplicationContext</code> (or <code>WebApplicationContext</code>) for a test, that context is cached and reused for all subsequent tests that declare the same unique context
                                    configuration within the same test suite. To understand how caching works, it is important to understand what is meant by &#8220;unique&#8221; and &#8220;test suite.&#8221;</p>
                            </div>
                            <div class="paragraph">
                                <p>An <code>ApplicationContext</code> can be uniquely identified by the combination of configuration parameters that is used to load it. Consequently, the unique combination of configuration parameters is used to generate
                                    a key under which the context is cached. The TestContext framework uses the following configuration parameters to build the context cache key:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>locations</code> (from <code>@ContextConfiguration</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>classes</code> (from <code>@ContextConfiguration</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>contextInitializerClasses</code> (from <code>@ContextConfiguration</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>contextCustomizers</code> (from <code>ContextCustomizerFactory</code>) – this includes
                                            <code>@DynamicPropertySource</code> methods as well as various features from Spring Boot&#8217;s testing support such as <code>@MockBean</code> and <code>@SpyBean</code>.</p>
                                    </li>
                                    <li>
                                        <p><code>contextLoader</code> (from <code>@ContextConfiguration</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>parent</code> (from <code>@ContextHierarchy</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>activeProfiles</code> (from <code>@ActiveProfiles</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>propertySourceLocations</code> (from <code>@TestPropertySource</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>propertySourceProperties</code> (from <code>@TestPropertySource</code>)</p>
                                    </li>
                                    <li>
                                        <p><code>resourceBasePath</code> (from <code>@WebAppConfiguration</code>)</p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>For example, if <code>TestClassA</code> specifies <code>{"app-config.xml", "test-config.xml"}</code> for the
                                    <code>locations</code> (or <code>value</code>) attribute of <code>@ContextConfiguration</code>, the TestContext framework loads the corresponding <code>ApplicationContext</code> and stores it in a <code>static</code>                                    context cache under a key that is based solely on those locations. So, if <code>TestClassB</code> also defines
                                    <code>{"app-config.xml", "test-config.xml"}</code> for its locations (either explicitly or implicitly through inheritance) but does not define <code>@WebAppConfiguration</code>, a different
                                    <code>ContextLoader</code>, different active profiles, different context initializers, different test property sources, or a different parent context, then the same <code>ApplicationContext</code> is shared by both
                                    test classes. This means that the setup cost for loading an application context is incurred only once (per test suite), and subsequent test execution is much faster.
                                </p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Test suites and forked processes</div>
                                            <div class="paragraph">
                                                <p>The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a <code>static</code> variable. In other words, if tests run in separate
                                                    processes, the static cache is cleared between each test execution, which effectively disables the caching mechanism.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>To benefit from the caching mechanism, all tests must run within the same process or test suite. This can be achieved by executing all tests as a group within an IDE. Similarly, when executing tests with
                                                    a build framework such as Ant, Maven, or Gradle, it is important to make sure that the build framework does not fork between tests. For example, if the
                                                    <a href="https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode"><code>forkMode</code></a> for the Maven Surefire plug-in is set to <code>always</code> or <code>pertest</code>,
                                                    the TestContext framework cannot cache application contexts between test classes, and the build process runs significantly more slowly as a result.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>The size of the context cache is bounded with a default maximum size of 32. Whenever the maximum size is reached, a least recently used (LRU) eviction policy is used to evict and close stale contexts. You can configure
                                    the maximum size from the command line or a build script by setting a JVM system property named <code>spring.test.context.cache.maxSize</code>. As an alternative, you can set the same property via the
                                    <a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism.</p>
                            </div>
                            <div class="paragraph">
                                <p>Since having a large number of application contexts loaded within a given test suite can cause the suite to take an unnecessarily long time to run, it is often beneficial to know exactly how many contexts have been loaded
                                    and cached. To view the statistics for the underlying context cache, you can set the log level for the
                                    <code>org.springframework.test.context.cache</code> logging category to <code>DEBUG</code>.</p>
                            </div>
                            <div class="paragraph">
                                <p>In the unlikely case that a test corrupts the application context and requires reloading (for example, by modifying a bean definition or the state of an application object), you can annotate your test class or test method
                                    with <code>@DirtiesContext</code> (see the discussion of
                                    <code>@DirtiesContext</code> in <a href="#spring-testing-annotation-dirtiescontext">Spring Testing
Annotations</a>). This instructs Spring to remove the context from the cache and rebuild the application context before running the next test that requires the same application context. Note that support for the <code>@DirtiesContext</code> annotation
                                    is provided by the
                                    <code>DirtiesContextBeforeModesTestExecutionListener</code> and the
                                    <code>DirtiesContextTestExecutionListener</code>, which are enabled by default.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">ApplicationContext lifecycle and console logging</div>
                                            <div class="paragraph">
                                                <p>When you need to debug a test executed with the Spring TestContext Framework, it can be useful to analyze the console output (that is, output to the <code>SYSOUT</code> and <code>SYSERR</code> streams).
                                                    Some build tools and IDEs are able to associate console output with a given test; however, some console output cannot be easily associated with a given test.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>With regard to console logging triggered by the Spring Framework itself or by components registered in the <code>ApplicationContext</code>, it is important to understand the lifecycle of an
                                                    <code>ApplicationContext</code> that has been loaded by the Spring TestContext Framework within a test suite.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>The <code>ApplicationContext</code> for a test is typically loaded when an instance of the test class is being prepared&#8201;&#8212;&#8201;for example, to perform dependency injection into <code>@Autowired</code>                                                    fields of the test instance. This means that any console logging triggered during the initialization of the <code>ApplicationContext</code> typically cannot be associated with an individual test method.
                                                    However, if the context is closed immediately before the execution of a test method according to <a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a> semantics, a new
                                                    instance of the context will be loaded just prior to execution of the test method. In the latter scenario, an IDE or build tool may potentially associate console logging with the individual test method.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>The <code>ApplicationContext</code> for a test can be closed via one of the following scenarios.</p>
                                            </div>
                                            <div class="ulist">
                                                <ul>
                                                    <li>
                                                        <p>The context is closed according to <code>@DirtiesContext</code> semantics.</p>
                                                    </li>
                                                    <li>
                                                        <p>The context is closed because it has been automatically evicted from the cache according to the LRU eviction policy.</p>
                                                    </li>
                                                    <li>
                                                        <p>The context is closed via a JVM shutdown hook when the JVM for the test suite terminates.
                                                        </p>
                                                    </li>
                                                </ul>
                                            </div>
                                            <div class="paragraph">
                                                <p>If the context is closed according to <code>@DirtiesContext</code> semantics after a particular test method, an IDE or build tool may potentially associate console logging with the individual test method.
                                                    If the context is closed according to <code>@DirtiesContext</code> semantics after a test class, any console logging triggered during the shutdown of the
                                                    <code>ApplicationContext</code> cannot be associated with an individual test method. Similarly, any console logging triggered during the shutdown phase via a JVM shutdown hook cannot be associated with
                                                    an individual test method.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>When a Spring <code>ApplicationContext</code> is closed via a JVM shutdown hook, callbacks executed during the shutdown phase are executed on a thread named <code>SpringContextShutdownHook</code>. So, if
                                                    you wish to disable console logging triggered when the <code>ApplicationContext</code> is closed via a JVM shutdown hook, you may be able to register a custom filter with your logging framework that
                                                    allows you to ignore any logging initiated by that thread.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-ctx-management-ctx-hierarchies"><a class="anchor" href="#testcontext-ctx-management-ctx-hierarchies"></a>Context Hierarchies</h5>
                            <div class="paragraph">
                                <p>When writing integration tests that rely on a loaded Spring <code>ApplicationContext</code>, it is often sufficient to test against a single context. However, there are times when it is beneficial or even necessary to test
                                    against a hierarchy of <code>ApplicationContext</code> instances. For example, if you are developing a Spring MVC web application, you typically have a root <code>WebApplicationContext</code> loaded by Spring&#8217;s
                                    <code>ContextLoaderListener</code> and a child <code>WebApplicationContext</code> loaded by Spring&#8217;s <code>DispatcherServlet</code>. This results in a parent-child context hierarchy where shared components and
                                    infrastructure configuration are declared in the root context and consumed in the child context by web-specific components. Another use case can be found in Spring Batch applications, where you often have a parent context
                                    that provides configuration for shared batch infrastructure and a child context for the configuration of a specific batch job.</p>
                            </div>
                            <div class="paragraph">
                                <p>You can write integration tests that use context hierarchies by declaring context configuration with the <code>@ContextHierarchy</code> annotation, either on an individual test class or within a test class hierarchy. If
                                    a context hierarchy is declared on multiple classes within a test class hierarchy, you can also merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration
                                    for a given level in the hierarchy, the configuration resource type (that is, XML configuration files or component classes) must be consistent. Otherwise, it is perfectly acceptable to have different levels in a context
                                    hierarchy configured using different resource types.</p>
                            </div>
                            <div class="paragraph">
                                <p>The remaining JUnit Jupiter based examples in this section show common configuration scenarios for integration tests that require the use of context hierarchies.</p>
                            </div>
                            <div class="openblock">
                                <div class="title">Single test class with context hierarchy</div>
                                <div class="content">
                                    <div class="paragraph">
                                        <p><code>ControllerIntegrationTests</code> represents a typical integration testing scenario for a Spring MVC web application by declaring a context hierarchy that consists of two levels, one for the root <code>WebApplicationContext</code>                                            (loaded by using the <code>TestAppConfig</code>
                                            <code>@Configuration</code> class) and one for the dispatcher servlet <code>WebApplicationContext</code> (loaded by using the <code>WebConfig</code> <code>@Configuration</code> class). The <code>WebApplicationContext</code>                                            that is autowired into the test instance is the one for the child context (that is, the lowest context in the hierarchy). The following listing shows this configuration scenario:</p>
                                    </div>
                                    <div class="listingblock primary">
                                        <div class="title">Java</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}</code></pre>
                                        </div>
                                    </div>
                                    <div class="listingblock secondary">
                                        <div class="title">Kotlin</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextHierarchy(
    ContextConfiguration(classes = [TestAppConfig::class]),
    ContextConfiguration(classes = [WebConfig::class]))
class ControllerIntegrationTests {

    @Autowired
    lateinit var wac: WebApplicationContext

    // ...
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="openblock">
                                <div class="title">Class hierarchy with implicit parent context</div>
                                <div class="content">
                                    <div class="paragraph">
                                        <p>The test classes in this example define a context hierarchy within a test class hierarchy. <code>AbstractWebTests</code> declares the configuration for a root
                                            <code>WebApplicationContext</code> in a Spring-powered web application. Note, however, that
                                            <code>AbstractWebTests</code> does not declare <code>@ContextHierarchy</code>. Consequently, subclasses of
                                            <code>AbstractWebTests</code> can optionally participate in a context hierarchy or follow the standard semantics for <code>@ContextConfiguration</code>. <code>SoapWebServiceTests</code> and
                                            <code>RestWebServiceTests</code> both extend <code>AbstractWebTests</code> and define a context hierarchy by using <code>@ContextHierarchy</code>. The result is that three application contexts are loaded (one
                                            for each declaration of <code>@ContextConfiguration</code>), and the application context loaded based on the configuration in <code>AbstractWebTests</code> is set as the parent context for each of the contexts
                                            loaded for the concrete subclasses. The following listing shows this configuration scenario:</p>
                                    </div>
                                    <div class="listingblock primary">
                                        <div class="title">Java</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
public class RestWebServiceTests extends AbstractWebTests {}</code></pre>
                                        </div>
                                    </div>
                                    <div class="listingblock secondary">
                                        <div class="title">Kotlin</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
abstract class AbstractWebTests

@ContextHierarchy(ContextConfiguration("/spring/soap-ws-config.xml"))
class SoapWebServiceTests : AbstractWebTests()

@ContextHierarchy(ContextConfiguration("/spring/rest-ws-config.xml"))
class RestWebServiceTests : AbstractWebTests()</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="openblock">
                                <div class="title">Class hierarchy with merged context hierarchy configuration</div>
                                <div class="content">
                                    <div class="paragraph">
                                        <p>The classes in this example show the use of named hierarchy levels in order to merge the configuration for specific levels in a context hierarchy. <code>BaseTests</code> defines two levels in the hierarchy, <code>parent</code>                                            and <code>child</code>. <code>ExtendedTests</code> extends <code>BaseTests</code> and instructs the Spring TestContext Framework to merge the context configuration for the <code>child</code> hierarchy level,
                                            by ensuring that the names declared in the <code>name</code> attribute in
                                            <code>@ContextConfiguration</code> are both <code>child</code>. The result is that three application contexts are loaded: one for <code>/app-config.xml</code>, one for <code>/user-config.xml</code>, and one
                                            for
                                            <code>{"/user-config.xml", "/order-config.xml"}</code>. As with the previous example, the application context loaded from <code>/app-config.xml</code> is set as the parent context for the contexts loaded from
                                            <code>/user-config.xml</code> and <code>{"/user-config.xml", "/order-config.xml"}</code>. The following listing shows this configuration scenario:</p>
                                    </div>
                                    <div class="listingblock primary">
                                        <div class="title">Java</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
class ExtendedTests extends BaseTests {}</code></pre>
                                        </div>
                                    </div>
                                    <div class="listingblock secondary">
                                        <div class="title">Kotlin</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
    ContextConfiguration(name = "child", locations = ["/order-config.xml"])
)
class ExtendedTests : BaseTests() {}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="openblock">
                                <div class="title">Class hierarchy with overridden context hierarchy configuration</div>
                                <div class="content">
                                    <div class="paragraph">
                                        <p>In contrast to the previous example, this example demonstrates how to override the configuration for a given named level in a context hierarchy by setting the
                                            <code>inheritLocations</code> flag in <code>@ContextConfiguration</code> to <code>false</code>. Consequently, the application context for <code>ExtendedTests</code> is loaded only from <code>/test-user-config.xml</code>                                            and has its parent set to the context loaded from <code>/app-config.xml</code>. The following listing shows this configuration scenario:</p>
                                    </div>
                                    <div class="listingblock primary">
                                        <div class="title">Java</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}</code></pre>
                                        </div>
                                    </div>
                                    <div class="listingblock secondary">
                                        <div class="title">Kotlin</div>
                                        <div class="content">
                                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
        ContextConfiguration(
                name = "child",
                locations = ["/test-user-config.xml"],
                inheritLocations = false
        ))
class ExtendedTests : BaseTests() {}</code></pre>
                                        </div>
                                    </div>
                                    <div class="admonitionblock note">
                                        <table>
                                            <tr>
                                                <td class="icon">
                                                    <i class="fa icon-note" title="Note"></i>
                                                </td>
                                                <td class="content">
                                                    <div class="title">Dirtying a context within a context hierarchy</div>
                                                    If you use <code>@DirtiesContext</code> in a test whose context is configured as part of a context hierarchy, you can use the <code>hierarchyMode</code> flag to control how the context cache is cleared.
                                                    For further details, see the discussion of <code>@DirtiesContext</code> in
                                                    <a href="#spring-testing-annotation-dirtiescontext">Spring Testing Annotations</a> and the
                                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><code>@DirtiesContext</code></a> javadoc.
                                                </td>
                                            </tr>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-fixture-di"><a class="anchor" href="#testcontext-fixture-di"></a>3.5.7. Dependency Injection of Test Fixtures</h4>
                        <div class="paragraph">
                            <p>When you use the <code>DependencyInjectionTestExecutionListener</code> (which is configured by default), the dependencies of your test instances are injected from beans in the application context that you configured with <code>@ContextConfiguration</code>                                or related annotations. You may use setter injection, field injection, or both, depending on which annotations you choose and whether you place them on setter methods or fields. If you are using JUnit Jupiter you may also
                                optionally use constructor injection (see <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a>). For consistency with Spring&#8217;s annotation-based injection support, you
                                may also use Spring&#8217;s <code>@Autowired</code> annotation or the <code>@Inject</code> annotation from JSR-330 for field and setter injection.</p>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        For testing frameworks other than JUnit Jupiter, the TestContext framework does not participate in instantiation of the test class. Thus, the use of <code>@Autowired</code> or
                                        <code>@Inject</code> for constructors has no effect for test classes.
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        Although field injection is discouraged in production code, field injection is actually quite natural in test code. The rationale for the difference is that you will never instantiate your test class directly. Consequently, there is no need to be able
                                        to invoke a <code>public</code> constructor or setter method on your test class.
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>Because <code>@Autowired</code> is used to perform <a href="core.html#beans-factory-autowire">autowiring by
type</a>, if you have multiple bean definitions of the same type, you cannot rely on this approach for those particular beans. In that case, you can use <code>@Autowired</code> in conjunction with <code>@Qualifier</code>. You can also choose to use <code>@Inject</code>                                in conjunction with
                                <code>@Named</code>. Alternatively, if your test class has access to its <code>ApplicationContext</code>, you can perform an explicit lookup by using (for example) a call to
                                <code>applicationContext.getBean("titleRepository", TitleRepository.class)</code>.</p>
                        </div>
                        <div class="paragraph">
                            <p>If you do not want dependency injection applied to your test instances, do not annotate fields or setter methods with <code>@Autowired</code> or <code>@Inject</code>. Alternatively, you can disable dependency injection altogether
                                by explicitly configuring your class with
                                <code>@TestExecutionListeners</code> and omitting <code>DependencyInjectionTestExecutionListener.class</code> from the list of listeners.</p>
                        </div>
                        <div class="paragraph">
                            <p>Consider the scenario of testing a <code>HibernateTitleRepository</code> class, as outlined in the
                                <a href="#integration-testing-goals">Goals</a> section. The next two code listings demonstrate the use of <code>@Autowired</code> on fields and setter methods. The application context configuration is presented after all
                                sample code listings.</p>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        <div class="paragraph">
                                            <p>The dependency injection behavior in the following code listings is not specific to JUnit Jupiter. The same DI techniques can be used in conjunction with any supported testing framework.
                                            </p>
                                        </div>
                                        <div class="paragraph">
                                            <p>The following examples make calls to static assertion methods, such as <code>assertNotNull()</code>, but without prepending the call with <code>Assertions</code>. In such cases, assume that the method was properly
                                                imported through an <code>import static</code> declaration that is not shown in the example.
                                            </p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>The first code listing shows a JUnit Jupiter based implementation of the test class that uses <code>@Autowired</code> for field injection:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    lateinit var titleRepository: HibernateTitleRepository

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>Alternatively, you can configure the class to use <code>@Autowired</code> for setter injection, as follows:
                            </p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    lateinit var titleRepository: HibernateTitleRepository

    @Autowired
    fun setTitleRepository(titleRepository: HibernateTitleRepository) {
        this.titleRepository = titleRepository
    }

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>The preceding code listings use the same XML context file referenced by the
                                <code>@ContextConfiguration</code> annotation (that is, <code>repository-config.xml</code>). The following shows this configuration:</p>
                        </div>
                        <div class="listingblock">
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;
    &lt;bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;!-- configuration elided for brevity --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
                            </div>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        <div class="paragraph">
                                            <p>If you are extending from a Spring-provided test base class that happens to use
                                                <code>@Autowired</code> on one of its setter methods, you might have multiple beans of the affected type defined in your application context (for example, multiple <code>DataSource</code> beans). In such
                                                a case, you can override the setter method and use the <code>@Qualifier</code> annotation to indicate a specific target bean, as follows (but make sure to delegate to the overridden method in the superclass
                                                as well):</p>
                                        </div>
                                        <div class="listingblock primary">
                                            <div class="title">Java</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

// ...</code></pre>
                                            </div>
                                        </div>
                                        <div class="listingblock secondary">
                                            <div class="title">Kotlin</div>
                                            <div class="content">
                                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

    @Autowired
    override fun setDataSource(@Qualifier("myDataSource") dataSource: DataSource) {
        super.setDataSource(dataSource)
    }

// ...</code></pre>
                                            </div>
                                        </div>
                                        <div class="paragraph">
                                            <p>The specified qualifier value indicates the specific <code>DataSource</code> bean to inject, narrowing the set of type matches to a specific bean. Its value is matched against
                                                <code>&lt;qualifier&gt;</code> declarations within the corresponding <code>&lt;bean&gt;</code> definitions. The bean name is used as a fallback qualifier value, so you can effectively also point to a specific
                                                bean by name there (as shown earlier, assuming that <code>myDataSource</code> is the bean <code>id</code>).</p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-web-scoped-beans"><a class="anchor" href="#testcontext-web-scoped-beans"></a>3.5.8. Testing Request- and Session-scoped Beans</h4>
                        <div class="paragraph">
                            <p>Spring has supported <a href="core.html#beans-factory-scopes-other">Request- and session-scoped
beans</a> since the early years, and you can test your request-scoped and session-scoped beans by following these steps:</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>Ensure that a <code>WebApplicationContext</code> is loaded for your test by annotating your test class with <code>@WebAppConfiguration</code>.</p>
                                </li>
                                <li>
                                    <p>Inject the mock request or session into your test instance and prepare your test fixture as appropriate.</p>
                                </li>
                                <li>
                                    <p>Invoke your web component that you retrieved from the configured
                                        <code>WebApplicationContext</code> (with dependency injection).</p>
                                </li>
                                <li>
                                    <p>Perform assertions against the mocks.</p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>The next code snippet shows the XML configuration for a login use case. Note that the
                                <code>userService</code> bean has a dependency on a request-scoped <code>loginAction</code> bean. Also, the
                                <code>LoginAction</code> is instantiated by using <a href="core.html#expressions">SpEL expressions</a> that retrieve the username and password from the current HTTP request. In our test, we want to configure these request
                                parameters through the mock managed by the TestContext framework. The following listing shows the configuration for this use case:</p>
                        </div>
                        <div class="listingblock">
                            <div class="title">Request-scoped bean configuration</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/&gt;

    &lt;bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>In <code>RequestScopedBeanTests</code>, we inject both the <code>UserService</code> (that is, the subject under test) and the <code>MockHttpServletRequest</code> into our test instance. Within our
                                <code>requestScope()</code> test method, we set up our test fixture by setting request parameters in the provided <code>MockHttpServletRequest</code>. When the <code>loginUser()</code> method is invoked on our
                                <code>userService</code>, we are assured that the user service has access to the request-scoped
                                <code>loginAction</code> for the current <code>MockHttpServletRequest</code> (that is, the one in which we just set parameters). We can then perform assertions against the results based on the known inputs for the username
                                and password. The following listing shows how to do so:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var request: MockHttpServletRequest

    @Test
    fun requestScope() {
        request.setParameter("user", "enigma")
        request.setParameter("pswd", "\$pr!ng")

        val results = userService.loginUser()
        // assert results
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>The following code snippet is similar to the one we saw earlier for a request-scoped bean. However, this time, the <code>userService</code> bean has a dependency on a session-scoped
                                <code>userPreferences</code> bean. Note that the <code>UserPreferences</code> bean is instantiated by using a SpEL expression that retrieves the theme from the current HTTP session. In our test, we need to configure a theme
                                in the mock session managed by the TestContext framework. The following example shows how to do so:</p>
                        </div>
                        <div class="listingblock">
                            <div class="title">Session-scoped bean configuration</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" /&gt;

    &lt;bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>In <code>SessionScopedBeanTests</code>, we inject the <code>UserService</code> and the <code>MockHttpSession</code> into our test instance. Within our <code>sessionScope()</code> test method, we set up our test fixture by setting
                                the expected <code>theme</code> attribute in the provided <code>MockHttpSession</code>. When the
                                <code>processUserPreferences()</code> method is invoked on our <code>userService</code>, we are assured that the user service has access to the session-scoped <code>userPreferences</code> for the current
                                <code>MockHttpSession</code>, and we can perform assertions against the results based on the configured theme. The following example shows how to do so:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var session: MockHttpSession

    @Test
    fun sessionScope() {
        session.setAttribute("theme", "blue")

        val results = userService.processUserPreferences()
        // assert results
    }
}</code></pre>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-tx"><a class="anchor" href="#testcontext-tx"></a>3.5.9. Transaction Management</h4>
                        <div class="paragraph">
                            <p>In the TestContext framework, transactions are managed by the
                                <code>TransactionalTestExecutionListener</code>, which is configured by default, even if you do not explicitly declare <code>@TestExecutionListeners</code> on your test class. To enable support for transactions, however,
                                you must configure a <code>PlatformTransactionManager</code> bean in the
                                <code>ApplicationContext</code> that is loaded with <code>@ContextConfiguration</code> semantics (further details are provided later). In addition, you must declare Spring&#8217;s <code>@Transactional</code> annotation
                                either at the class or the method level for your tests.</p>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-test-managed-transactions"><a class="anchor" href="#testcontext-tx-test-managed-transactions"></a>Test-managed Transactions</h5>
                            <div class="paragraph">
                                <p>Test-managed transactions are transactions that are managed declaratively by using the
                                    <code>TransactionalTestExecutionListener</code> or programmatically by using <code>TestTransaction</code> (described later). You should not confuse such transactions with Spring-managed transactions (those managed directly
                                    by Spring within the <code>ApplicationContext</code> loaded for tests) or application-managed transactions (those managed programmatically within application code that is invoked by tests). Spring-managed and application-managed
                                    transactions typically participate in test-managed transactions. However, you should use caution if Spring-managed or application-managed transactions are configured with any propagation type other than <code>REQUIRED</code>                                    or <code>SUPPORTS</code> (see the discussion on
                                    <a href="data-access.html#tx-propagation">transaction propagation</a> for details).</p>
                            </div>
                            <div class="admonitionblock warning">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-warning" title="Warning"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Preemptive timeouts and test-managed transactions</div>
                                            <div class="paragraph">
                                                <p>Caution must be taken when using any form of preemptive timeouts from a testing framework in conjunction with Spring&#8217;s test-managed transactions.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>Specifically, Spring’s testing support binds transaction state to the current thread (via a <code>java.lang.ThreadLocal</code> variable) <em>before</em> the current test method is invoked. If a testing framework
                                                    invokes the current test method in a new thread in order to support a preemptive timeout, any actions performed within the current test method will <em>not</em> be invoked within the test-managed transaction.
                                                    Consequently, the result of any such actions will not be rolled back with the test-managed transaction. On the contrary, such actions will be committed to the persistent store&#8201;&#8212;&#8201;for
                                                    example, a relational database&#8201;&#8212;&#8201;even though the test-managed transaction is properly rolled back by Spring.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>Situations in which this can occur include but are not limited to the following.</p>
                                            </div>
                                            <div class="ulist">
                                                <ul>
                                                    <li>
                                                        <p>JUnit 4&#8217;s <code>@Test(timeout = &#8230;&#8203;)</code> support and <code>TimeOut</code> rule</p>
                                                    </li>
                                                    <li>
                                                        <p>JUnit Jupiter&#8217;s <code>assertTimeoutPreemptively(&#8230;&#8203;)</code> methods in the
                                                            <code>org.junit.jupiter.api.Assertions</code> class</p>
                                                    </li>
                                                    <li>
                                                        <p>TestNG&#8217;s <code>@Test(timeOut = &#8230;&#8203;)</code> support</p>
                                                    </li>
                                                </ul>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-enabling-transactions"><a class="anchor" href="#testcontext-tx-enabling-transactions"></a>Enabling and Disabling Transactions</h5>
                            <div class="paragraph">
                                <p>Annotating a test method with <code>@Transactional</code> causes the test to be run within a transaction that is, by default, automatically rolled back after completion of the test. If a test class is annotated with <code>@Transactional</code>,
                                    each test method within that class hierarchy runs within a transaction. Test methods that are not annotated with
                                    <code>@Transactional</code> (at the class or method level) are not run within a transaction. Note that <code>@Transactional</code> is not supported on test lifecycle methods — for example, methods annotated with JUnit
                                    Jupiter&#8217;s <code>@BeforeAll</code>, <code>@BeforeEach</code>, etc. Furthermore, tests that are annotated with <code>@Transactional</code> but have the <code>propagation</code> attribute set to
                                    <code>NOT_SUPPORTED</code> or <code>NEVER</code> are not run within a transaction.</p>
                            </div>
                            <table id="testcontext-tx-attribute-support" class="tableblock frame-all grid-all stretch">
                                <caption class="title">Table 1. <code>@Transactional</code> attribute support</caption>
                                <colgroup>
                                    <col style="width: 50%;">
                                    <col style="width: 50%;">
                                </colgroup>
                                <thead>
                                    <tr>
                                        <th class="tableblock halign-left valign-top">Attribute</th>
                                        <th class="tableblock halign-left valign-top">Supported for test-managed transactions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>value</code> and <code>transactionManager</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">yes</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>propagation</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">only <code>Propagation.NOT_SUPPORTED</code> and <code>Propagation.NEVER</code> are supported</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>isolation</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">no</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>timeout</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">no</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>readOnly</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">no</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>rollbackFor</code> and <code>rollbackForClassName</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">no: use <code>TestTransaction.flagForRollback()</code> instead</p>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock"><code>noRollbackFor</code> and <code>noRollbackForClassName</code></p>
                                        </td>
                                        <td class="tableblock halign-left valign-top">
                                            <p class="tableblock">no: use <code>TestTransaction.flagForCommit()</code> instead</p>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            <div class="paragraph">
                                                <p>Method-level lifecycle methods — for example, methods annotated with JUnit Jupiter&#8217;s
                                                    <code>@BeforeEach</code> or <code>@AfterEach</code> — are run within a test-managed transaction. On the other hand, suite-level and class-level lifecycle methods — for example, methods annotated with
                                                    JUnit Jupiter&#8217;s <code>@BeforeAll</code> or <code>@AfterAll</code> and methods annotated with TestNG&#8217;s
                                                    <code>@BeforeSuite</code>, <code>@AfterSuite</code>, <code>@BeforeClass</code>, or <code>@AfterClass</code> — are <em>not</em> run within a test-managed transaction.</p>
                                            </div>
                                            <div class="paragraph">
                                                <p>If you need to run code in a suite-level or class-level lifecycle method within a transaction, you may wish to inject a corresponding <code>PlatformTransactionManager</code> into your test class and then
                                                    use that with a <code>TransactionTemplate</code> for programmatic transaction management.</p>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>Note that <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> and
                                    <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a> are preconfigured for transactional support at the class level.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following example demonstrates a common scenario for writing an integration test for a Hibernate-based <code>UserRepository</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    lateinit var repository: HibernateUserRepository

    @Autowired
    lateinit var sessionFactory: SessionFactory

    lateinit var jdbcTemplate: JdbcTemplate

    @Autowired
    fun setDataSource(dataSource: DataSource) {
        this.jdbcTemplate = JdbcTemplate(dataSource)
    }

    @Test
    fun createUser() {
        // track initial state in test database:
        val count = countRowsInTable("user")

        val user = User()
        repository.save(user)

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush()
        assertNumUsers(count + 1)
    }

    private fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    private fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>As explained in <a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a>, there is no need to clean up the database after the <code>createUser()</code> method runs, since any changes
                                    made to the database are automatically rolled back by the <code>TransactionalTestExecutionListener</code>.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-rollback-and-commit-behavior"><a class="anchor" href="#testcontext-tx-rollback-and-commit-behavior"></a>Transaction Rollback and Commit Behavior</h5>
                            <div class="paragraph">
                                <p>By default, test transactions will be automatically rolled back after completion of the test; however, transactional commit and rollback behavior can be configured declaratively via the <code>@Commit</code> and <code>@Rollback</code>                                    annotations. See the corresponding entries in the
                                    <a href="#integration-testing-annotations">annotation support</a> section for further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-programmatic-tx-mgt"><a class="anchor" href="#testcontext-tx-programmatic-tx-mgt"></a>Programmatic Transaction Management</h5>
                            <div class="paragraph">
                                <p>You can interact with test-managed transactions programmatically by using the static methods in <code>TestTransaction</code>. For example, you can use <code>TestTransaction</code> within test methods, before methods, and
                                    after methods to start or end the current test-managed transaction or to configure the current test-managed transaction for rollback or commit. Support for <code>TestTransaction</code> is automatically available whenever
                                    the
                                    <code>TransactionalTestExecutionListener</code> is enabled.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following example demonstrates some of the features of <code>TestTransaction</code>. See the javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html"><code>TestTransaction</code></a>                                    for further details.</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables("user");

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(classes = [TestConfig::class])
class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {

    @Test
    fun transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2)

        deleteFromTables("user")

        // changes to the database will be committed!
        TestTransaction.flagForCommit()
        TestTransaction.end()
        assertFalse(TestTransaction.isActive())
        assertNumUsers(0)

        TestTransaction.start()
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-before-and-after-tx"><a class="anchor" href="#testcontext-tx-before-and-after-tx"></a>Running Code Outside of a Transaction</h5>
                            <div class="paragraph">
                                <p>Occasionally, you may need to run certain code before or after a transactional test method but outside the transactional context&#8201;&#8212;&#8201;for example, to verify the initial database state prior to running your
                                    test or to verify expected transactional commit behavior after your test runs (if the test was configured to commit the transaction).
                                    <code>TransactionalTestExecutionListener</code> supports the <code>@BeforeTransaction</code> and
                                    <code>@AfterTransaction</code> annotations for exactly such scenarios. You can annotate any <code>void</code> method in a test class or any <code>void</code> default method in a test interface with one of these annotations,
                                    and the <code>TransactionalTestExecutionListener</code> ensures that your before transaction method or after transaction method runs at the appropriate time.</p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            Any before methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@BeforeEach</code>) and any after methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@AfterEach</code>) are run
                                            within a transaction. In addition, methods annotated with <code>@BeforeTransaction</code> or
                                            <code>@AfterTransaction</code> are not run for test methods that are not configured to run within a transaction.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-mgr-config"><a class="anchor" href="#testcontext-tx-mgr-config"></a>Configuring a Transaction Manager</h5>
                            <div class="paragraph">
                                <p><code>TransactionalTestExecutionListener</code> expects a <code>PlatformTransactionManager</code> bean to be defined in the Spring <code>ApplicationContext</code> for the test. If there are multiple instances of <code>PlatformTransactionManager</code>                                    within the test&#8217;s <code>ApplicationContext</code>, you can declare a qualifier by using <code>@Transactional("myTxMgr")</code> or <code>@Transactional(transactionManager =
"myTxMgr")</code>, or <code>TransactionManagementConfigurer</code> can be implemented by an
                                    <code>@Configuration</code> class. Consult the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc
for <code>TestContextTransactionUtils.retrieveTransactionManager()</code></a> for details on the algorithm used to look up a transaction manager in the test&#8217;s <code>ApplicationContext</code>.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-tx-annotation-demo"><a class="anchor" href="#testcontext-tx-annotation-demo"></a>Demonstration of All Transaction-related Annotations</h5>
                            <div class="paragraph">
                                <p>The following JUnit Jupiter based example displays a fictitious integration testing scenario that highlights all transaction-related annotations. The example is not intended to demonstrate best practices but rather to demonstrate
                                    how these annotations can be used. See the <a href="#integration-testing-annotations">annotation support</a> section for further information and configuration examples. <a href="#testcontext-executing-sql-declaratively-tx">Transaction management for <code>@Sql</code></a>                                    contains an additional example that uses <code>@Sql</code> for declarative SQL script execution with default transaction rollback semantics. The following example shows the relevant annotations:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // run "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    fun verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    fun setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    fun modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    fun tearDownWithinTransaction() {
        // run "tear down" logic within the transaction
    }

    @AfterTransaction
    fun verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
                                </div>
                            </div>
                            <div id="testcontext-tx-false-positives" class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            <div class="title">Avoid false positives when testing ORM code</div>
                                            <div class="paragraph">
                                                <p>When you test application code that manipulates the state of a Hibernate session or JPA persistence context, make sure to flush the underlying unit of work within test methods that run that code. Failing
                                                    to flush the underlying unit of work can produce false positives: Your test passes, but the same code throws an exception in a live, production environment. Note that this applies to any ORM framework
                                                    that maintains an in-memory unit of work. In the following Hibernate-based example test case, one method demonstrates a false positive, and the other method correctly exposes the results of flushing
                                                    the session:
                                                </p>
                                            </div>
                                            <div class="listingblock primary">
                                                <div class="title">Java</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...</code></pre>
                                                </div>
                                            </div>
                                            <div class="listingblock secondary">
                                                <div class="title">Kotlin</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

@Autowired
lateinit var sessionFactory: SessionFactory

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInHibernateSession()
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
fun updateWithSessionFlush() {
    updateEntityInHibernateSession()
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush()
}

// ...</code></pre>
                                                </div>
                                            </div>
                                            <div class="paragraph">
                                                <p>The following example shows matching methods for JPA:</p>
                                            </div>
                                            <div class="listingblock primary">
                                                <div class="title">Java</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...</code></pre>
                                                </div>
                                            </div>
                                            <div class="listingblock secondary">
                                                <div class="title">Kotlin</div>
                                                <div class="content">
                                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

@PersistenceContext
lateinit var entityManager:EntityManager

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInJpaPersistenceContext()
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext()
    // Manual flush is required to avoid false positive in test
    entityManager.flush()
}

// ...</code></pre>
                                                </div>
                                            </div>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-executing-sql"><a class="anchor" href="#testcontext-executing-sql"></a>3.5.10. Executing SQL Scripts</h4>
                        <div class="paragraph">
                            <p>When writing integration tests against a relational database, it is often beneficial to run SQL scripts to modify the database schema or insert test data into tables. The
                                <code>spring-jdbc</code> module provides support for <em>initializing</em> an embedded or existing database by executing SQL scripts when the Spring <code>ApplicationContext</code> is loaded. See
                                <a href="data-access.html#jdbc-embedded-database-support">Embedded database support</a> and
                                <a href="data-access.html#jdbc-embedded-database-dao-testing">Testing data access logic with an
embedded database</a> for details.</p>
                        </div>
                        <div class="paragraph">
                            <p>Although it is very useful to initialize a database for testing <em>once</em> when the
                                <code>ApplicationContext</code> is loaded, sometimes it is essential to be able to modify the database <em>during</em> integration tests. The following sections explain how to run SQL scripts programmatically and declaratively
                                during integration tests.</p>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-executing-sql-programmatically"><a class="anchor" href="#testcontext-executing-sql-programmatically"></a>Executing SQL scripts programmatically</h5>
                            <div class="paragraph">
                                <p>Spring provides the following options for executing SQL scripts programmatically within integration test methods.</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>org.springframework.jdbc.datasource.init.ScriptUtils</code></p>
                                    </li>
                                    <li>
                                        <p><code>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code></p>
                                    </li>
                                    <li>
                                        <p><code>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code></p>
                                    </li>
                                    <li>
                                        <p><code>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p><code>ScriptUtils</code> provides a collection of static utility methods for working with SQL scripts and is mainly intended for internal use within the framework. However, if you require full control over how SQL scripts
                                    are parsed and run, <code>ScriptUtils</code> may suit your needs better than some of the other alternatives described later. See the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">javadoc</a> for individual methods in <code>ScriptUtils</code> for further details.</p>
                            </div>
                            <div class="paragraph">
                                <p><code>ResourceDatabasePopulator</code> provides an object-based API for programmatically populating, initializing, or cleaning up a database by using SQL scripts defined in external resources. <code>ResourceDatabasePopulator</code>                                    provides options for configuring the character encoding, statement separator, comment delimiters, and error handling flags used when parsing and running the scripts. Each of the configuration options has a reasonable
                                    default value. See the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a> for details on default values. To run the scripts configured
                                    in a
                                    <code>ResourceDatabasePopulator</code>, you can invoke either the <code>populate(Connection)</code> method to run the populator against a <code>java.sql.Connection</code> or the <code>execute(DataSource)</code> method
                                    to run the populator against a <code>javax.sql.DataSource</code>. The following example specifies SQL scripts for a test schema and test data, sets the statement separator to
                                    <code>@@</code>, and run the scripts against a <code>DataSource</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // run code that uses the test schema and data
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun databaseTest() {
    val populator = ResourceDatabasePopulator()
    populator.addScripts(
            ClassPathResource("test-schema.sql"),
            ClassPathResource("test-data.sql"))
    populator.setSeparator("@@")
    populator.execute(dataSource)
    // run code that uses the test schema and data
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Note that <code>ResourceDatabasePopulator</code> internally delegates to <code>ScriptUtils</code> for parsing and running SQL scripts. Similarly, the <code>executeSqlScript(..)</code> methods in
                                    <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> and <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>                                    internally use a <code>ResourceDatabasePopulator</code> to run SQL scripts. See the Javadoc for the various <code>executeSqlScript(..)</code> methods for further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-executing-sql-declaratively"><a class="anchor" href="#testcontext-executing-sql-declaratively"></a>Executing SQL scripts declaratively with @Sql</h5>
                            <div class="paragraph">
                                <p>In addition to the aforementioned mechanisms for running SQL scripts programmatically, you can declaratively configure SQL scripts in the Spring TestContext Framework. Specifically, you can declare the <code>@Sql</code>                                    annotation on a test class or test method to configure individual SQL statements or the resource paths to SQL scripts that should be run against a given database before or after an integration test method. Support for
                                    <code>@Sql</code> is provided by the <code>SqlScriptsTestExecutionListener</code>, which is enabled by default.</p>
                            </div>
                            <div class="admonitionblock note">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-note" title="Note"></i>
                                        </td>
                                        <td class="content">
                                            Method-level <code>@Sql</code> declarations override class-level declarations by default. As of Spring Framework 5.2, however, this behavior may be configured per test class or per test method via <code>@SqlMergeMode</code>.
                                            See
                                            <a href="#testcontext-executing-sql-declaratively-script-merging">Merging and Overriding Configuration with <code>@SqlMergeMode</code></a> for further details.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-script-resources"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-resources"></a>Path Resource Semantics</h6>
                                <div class="paragraph">
                                    <p>Each path is interpreted as a Spring <code>Resource</code>. A plain path (for example,
                                        <code>"schema.sql"</code>) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath resource (for example,
                                        <code>"/org/example/schema.sql"</code>). A path that references a URL (for example, a path prefixed with <code>classpath:</code>, <code>file:</code>, <code>http:</code>) is loaded by using the specified resource
                                        protocol.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The following example shows how to use <code>@Sql</code> at the class level and at the method level within a JUnit Jupiter based integration test class:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // run code that uses the test schema and test data
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    fun emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql("/test-schema.sql", "/test-user-data.sql")
    fun userTest() {
        // run code that uses the test schema and test data
    }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-script-detection"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-detection"></a>Default Script Detection</h6>
                                <div class="paragraph">
                                    <p>If no SQL scripts or statements are specified, an attempt is made to detect a <code>default</code> script, depending on where <code>@Sql</code> is declared. If a default cannot be detected, an
                                        <code>IllegalStateException</code> is thrown.</p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p>Class-level declaration: If the annotated test class is <code>com.example.MyTest</code>, the corresponding default script is <code>classpath:com/example/MyTest.sql</code>.</p>
                                        </li>
                                        <li>
                                            <p>Method-level declaration: If the annotated test method is named <code>testMethod()</code> and is defined in the class <code>com.example.MyTest</code>, the corresponding default script is
                                                <code>classpath:com/example/MyTest.testMethod.sql</code>.</p>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-multiple-annotations"><a class="anchor" href="#testcontext-executing-sql-declaratively-multiple-annotations"></a>Declaring Multiple <code>@Sql</code> Sets</h6>
                                <div class="paragraph">
                                    <p>If you need to configure multiple sets of SQL scripts for a given test class or test method but with different syntax configuration, different error handling rules, or different execution phases per set, you can declare
                                        multiple instances of <code>@Sql</code>. With Java 8, you can use <code>@Sql</code> as a repeatable annotation. Otherwise, you can use the
                                        <code>@SqlGroup</code> annotation as an explicit container for declaring multiple instances of
                                        <code>@Sql</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The following example shows how to use <code>@Sql</code> as a repeatable annotation with Java 8:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>In the scenario presented in the preceding example, the <code>test-schema.sql</code> script uses a different syntax for single-line comments.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The following example is identical to the preceding example, except that the <code>@Sql</code> declarations are grouped together within <code>@SqlGroup</code>. With Java 8 and above, the use of
                                        <code>@SqlGroup</code> is optional, but you may need to use <code>@SqlGroup</code> for compatibility with other JVM languages such as Kotlin.</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup(
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // Run code that uses the test schema and test data
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-script-execution-phases"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-execution-phases"></a>Script Execution Phases</h6>
                                <div class="paragraph">
                                    <p>By default, SQL scripts are run before the corresponding test method. However, if you need to run a particular set of scripts after the test method (for example, to clean up database state), you can use the <code>executionPhase</code>                                        attribute in <code>@Sql</code>, as the following example shows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup(
    Sql("create-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED)),
    Sql("delete-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED),
        executionPhase = AFTER_TEST_METHOD))
fun userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Note that <code>ISOLATED</code> and <code>AFTER_TEST_METHOD</code> are statically imported from
                                        <code>Sql.TransactionMode</code> and <code>Sql.ExecutionPhase</code>, respectively.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-script-configuration"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-configuration"></a>Script Configuration with <code>@SqlConfig</code></h6>
                                <div class="paragraph">
                                    <p>You can configure script parsing and error handling by using the <code>@SqlConfig</code> annotation. When declared as a class-level annotation on an integration test class, <code>@SqlConfig</code> serves as global configuration
                                        for all SQL scripts within the test class hierarchy. When declared directly by using the <code>config</code> attribute of the <code>@Sql</code> annotation, <code>@SqlConfig</code> serves as local configuration for
                                        the SQL scripts declared within the enclosing <code>@Sql</code> annotation. Every attribute in <code>@SqlConfig</code> has an implicit default value, which is documented in the javadoc of the corresponding attribute.
                                        Due to the rules defined for annotation attributes in the Java Language Specification, it is, unfortunately, not possible to assign a value of <code>null</code> to an annotation attribute. Thus, in order to support
                                        overrides of inherited global configuration, <code>@SqlConfig</code> attributes have an explicit default value of either <code>""</code> (for Strings), <code>{}</code> (for arrays), or <code>DEFAULT</code> (for
                                        enumerations). This approach lets local declarations of <code>@SqlConfig</code> selectively override individual attributes from global declarations of <code>@SqlConfig</code> by providing a value other than <code>""</code>,
                                        <code>{}</code>, or <code>DEFAULT</code>. Global <code>@SqlConfig</code> attributes are inherited whenever local <code>@SqlConfig</code> attributes do not supply an explicit value other than <code>""</code>, <code>{}</code>,
                                        or
                                        <code>DEFAULT</code>. Explicit local configuration, therefore, overrides global configuration.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The configuration options provided by <code>@Sql</code> and <code>@SqlConfig</code> are equivalent to those supported by <code>ScriptUtils</code> and <code>ResourceDatabasePopulator</code> but are a superset of those
                                        provided by the <code>&lt;jdbc:initialize-database/&gt;</code> XML namespace element. See the javadoc of individual attributes in <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/jdbc/Sql.html"><code>@Sql</code></a>                                        and
                                        <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> for details.</p>
                                </div>
                                <div id="testcontext-executing-sql-declaratively-tx" class="paragraph">
                                    <p><strong>Transaction management for <code>@Sql</code></strong></p>
                                </div>
                                <div class="paragraph">
                                    <p>By default, the <code>SqlScriptsTestExecutionListener</code> infers the desired transaction semantics for scripts configured by using <code>@Sql</code>. Specifically, SQL scripts are run without a transaction, within
                                        an existing Spring-managed transaction (for example, a transaction managed by the <code>TransactionalTestExecutionListener</code> for a test annotated with
                                        <code>@Transactional</code>), or within an isolated transaction, depending on the configured value of the <code>transactionMode</code> attribute in <code>@SqlConfig</code> and the presence of a
                                        <code>PlatformTransactionManager</code> in the test&#8217;s <code>ApplicationContext</code>. As a bare minimum, however, a <code>javax.sql.DataSource</code> must be present in the test&#8217;s <code>ApplicationContext</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>If the algorithms used by <code>SqlScriptsTestExecutionListener</code> to detect a <code>DataSource</code> and
                                        <code>PlatformTransactionManager</code> and infer the transaction semantics do not suit your needs, you can specify explicit names by setting the <code>dataSource</code> and <code>transactionManager</code> attributes
                                        of <code>@SqlConfig</code>. Furthermore, you can control the transaction propagation behavior by setting the <code>transactionMode</code> attribute of <code>@SqlConfig</code> (for example, whether scripts should
                                        be run in an isolated transaction). Although a thorough discussion of all supported options for transaction management with <code>@Sql</code> is beyond the scope of this reference manual, the javadoc for
                                        <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> and
                                        <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html"><code>SqlScriptsTestExecutionListener</code></a> provide detailed
                                        information, and the following example shows a typical testing scenario that uses JUnit Jupiter and transactional tests with <code>@Sql</code>:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // run code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestDatabaseConfig::class)
@Transactional
class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {

    val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)

    @Test
    @Sql("/test-data.sql")
    fun usersTest() {
        // verify state in test database:
        assertNumUsers(2)
        // run code that uses the test data...
    }

    fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    fun assertNumUsers(expected: Int) {
        assertEquals(expected, countRowsInTable("user"),
                "Number of rows in the [user] table.")
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Note that there is no need to clean up the database after the <code>usersTest()</code> method is run, since any changes made to the database (either within the test method or within the
                                        <code>/test-data.sql</code> script) are automatically rolled back by the
                                        <code>TransactionalTestExecutionListener</code> (see <a href="#testcontext-tx">transaction management</a> for details).
                                    </p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-executing-sql-declaratively-script-merging"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-merging"></a>Merging and Overriding Configuration with <code>@SqlMergeMode</code></h6>
                                <div class="paragraph">
                                    <p>As of Spring Framework 5.2, it is possible to merge method-level <code>@Sql</code> declarations with class-level declarations. For example, this allows you to provide the configuration for a database schema or some
                                        common test data once per test class and then provide additional, use case specific test data per test method. To enable <code>@Sql</code> merging, annotate either your test class or test method with <code>@SqlMergeMode(MERGE)</code>.
                                        To disable merging for a specific test method (or specific test subclass), you can switch back to the default mode via <code>@SqlMergeMode(OVERRIDE)</code>. Consult the <a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code> annotation documentation section</a>                                        for examples and further details.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-parallel-test-execution"><a class="anchor" href="#testcontext-parallel-test-execution"></a>3.5.11. Parallel Test Execution</h4>
                        <div class="paragraph">
                            <p>Spring Framework 5.0 introduced basic support for executing tests in parallel within a single JVM when using the Spring TestContext Framework. In general, this means that most test classes or test methods can be run in parallel
                                without any changes to test code or configuration.</p>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        For details on how to set up parallel test execution, see the documentation for your testing framework, build tool, or IDE.
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="paragraph">
                            <p>Keep in mind that the introduction of concurrency into your test suite can result in unexpected side effects, strange runtime behavior, and tests that fail intermittently or seemingly randomly. The Spring Team therefore provides
                                the following general guidelines for when not to run tests in parallel.</p>
                        </div>
                        <div class="paragraph">
                            <p>Do not run tests in parallel if the tests:</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>Use Spring Framework&#8217;s <code>@DirtiesContext</code> support.</p>
                                </li>
                                <li>
                                    <p>Use Spring Boot&#8217;s <code>@MockBean</code> or <code>@SpyBean</code> support.</p>
                                </li>
                                <li>
                                    <p>Use JUnit 4&#8217;s <code>@FixMethodOrder</code> support or any testing framework feature that is designed to ensure that test methods run in a particular order. Note, however, that this does not apply if entire test
                                        classes are run in parallel.</p>
                                </li>
                                <li>
                                    <p>Change the state of shared services or systems such as a database, message broker, filesystem, and others. This applies to both embedded and external systems.</p>
                                </li>
                            </ul>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        <div class="paragraph">
                                            <p>If parallel test execution fails with an exception stating that the <code>ApplicationContext</code> for the current test is no longer active, this typically means that the
                                                <code>ApplicationContext</code> was removed from the <code>ContextCache</code> in a different thread.</p>
                                        </div>
                                        <div class="paragraph">
                                            <p>This may be due to the use of <code>@DirtiesContext</code> or due to automatic eviction from the
                                                <code>ContextCache</code>. If <code>@DirtiesContext</code> is the culprit, you either need to find a way to avoid using <code>@DirtiesContext</code> or exclude such tests from parallel execution. If the
                                                maximum size of the <code>ContextCache</code> has been exceeded, you can increase the maximum size of the cache. See the discussion on <a href="#testcontext-ctx-management-caching">context caching</a> for
                                                details.</p>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="admonitionblock warning">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-warning" title="Warning"></i>
                                    </td>
                                    <td class="content">
                                        Parallel test execution in the Spring TestContext Framework is only possible if the underlying <code>TestContext</code> implementation provides a copy constructor, as explained in the javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/context/TestContext.html"><code>TestContext</code></a>.
                                        The
                                        <code>DefaultTestContext</code> used in Spring provides such a constructor. However, if you use a third-party library that provides a custom <code>TestContext</code> implementation, you need to verify that it is
                                        suitable for parallel test execution.
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="testcontext-support-classes"><a class="anchor" href="#testcontext-support-classes"></a>3.5.12. TestContext Framework Support Classes</h4>
                        <div class="paragraph">
                            <p>This section describes the various classes that support the Spring TestContext Framework.</p>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-junit4-runner"><a class="anchor" href="#testcontext-junit4-runner"></a>Spring JUnit 4 Runner</h5>
                            <div class="paragraph">
                                <p>The Spring TestContext Framework offers full integration with JUnit 4 through a custom runner (supported on JUnit 4.12 or higher). By annotating test classes with
                                    <code>@RunWith(SpringJUnit4ClassRunner.class)</code> or the shorter <code>@RunWith(SpringRunner.class)</code> variant, developers can implement standard JUnit 4-based unit and integration tests and simultaneously reap
                                    the benefits of the TestContext framework, such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on. If you want to use the Spring TestContext
                                    Framework with an alternative runner (such as JUnit 4&#8217;s <code>Parameterized</code> runner) or third-party runners (such as the <code>MockitoJUnitRunner</code>), you can, optionally, use
                                    <a href="#testcontext-junit4-rules">Spring&#8217;s support for JUnit rules</a> instead.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following code listing shows the minimal requirements for configuring a test class to run with the custom Spring <code>Runner</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@TestExecutionListeners
class SimpleTest {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>In the preceding example, <code>@TestExecutionListeners</code> is configured with an empty list, to disable the default listeners, which otherwise would require an <code>ApplicationContext</code> to be configured through
                                    <code>@ContextConfiguration</code>.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-junit4-rules"><a class="anchor" href="#testcontext-junit4-rules"></a>Spring JUnit 4 Rules</h5>
                            <div class="paragraph">
                                <p>The <code>org.springframework.test.context.junit4.rules</code> package provides the following JUnit 4 rules (supported on JUnit 4.12 or higher):</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>SpringClassRule</code></p>
                                    </li>
                                    <li>
                                        <p><code>SpringMethodRule</code></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p><code>SpringClassRule</code> is a JUnit <code>TestRule</code> that supports class-level features of the Spring TestContext Framework, whereas <code>SpringMethodRule</code> is a JUnit <code>MethodRule</code> that supports
                                    instance-level and method-level features of the Spring TestContext Framework.</p>
                            </div>
                            <div class="paragraph">
                                <p>In contrast to the <code>SpringRunner</code>, Spring&#8217;s rule-based JUnit support has the advantage of being independent of any <code>org.junit.runner.Runner</code> implementation and can, therefore, be combined with
                                    existing alternative runners (such as JUnit 4&#8217;s <code>Parameterized</code>) or third-party runners (such as the <code>MockitoJUnitRunner</code>).</p>
                            </div>
                            <div class="paragraph">
                                <p>To support the full functionality of the TestContext framework, you must combine a
                                    <code>SpringClassRule</code> with a <code>SpringMethodRule</code>. The following example shows the proper way to declare these rules in an integration test:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
class IntegrationTest {

    @Rule
    val springMethodRule = SpringMethodRule()

    @Test
    fun testMethod() {
        // test logic...
    }

    companion object {
        @ClassRule
        val springClassRule = SpringClassRule()
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-support-classes-junit4"><a class="anchor" href="#testcontext-support-classes-junit4"></a>JUnit 4 Support Classes</h5>
                            <div class="paragraph">
                                <p>The <code>org.springframework.test.context.junit4</code> package provides the following support classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher):</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>AbstractJUnit4SpringContextTests</code></p>
                                    </li>
                                    <li>
                                        <p><code>AbstractTransactionalJUnit4SpringContextTests</code></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p><code>AbstractJUnit4SpringContextTests</code> is an abstract base test class that integrates the Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a JUnit 4 environment. When
                                    you extend <code>AbstractJUnit4SpringContextTests</code>, you can access a
                                    <code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.</p>
                            </div>
                            <div class="paragraph">
                                <p><code>AbstractTransactionalJUnit4SpringContextTests</code> is an abstract transactional extension of
                                    <code>AbstractJUnit4SpringContextTests</code> that adds some convenience functionality for JDBC access. This class expects a <code>javax.sql.DataSource</code> bean and a
                                    <code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you extend <code>AbstractTransactionalJUnit4SpringContextTests</code>, you can access a <code>protected</code>
                                    <code>jdbcTemplate</code> instance variable that you can use to run SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application
                                    code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
                                    As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
                                    <code>AbstractTransactionalJUnit4SpringContextTests</code> also provides convenience methods that delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>. Furthermore,
                                    <code>AbstractTransactionalJUnit4SpringContextTests</code> provides an
                                    <code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using <code>@RunWith(SpringRunner.class)</code>                                            or <a href="#testcontext-junit4-rules">Spring&#8217;s
JUnit rules</a>.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-junit-jupiter-extension"><a class="anchor" href="#testcontext-junit-jupiter-extension"></a>SpringExtension for JUnit Jupiter</h5>
                            <div class="paragraph">
                                <p>The Spring TestContext Framework offers full integration with the JUnit Jupiter testing framework, introduced in JUnit 5. By annotating test classes with
                                    <code>@ExtendWith(SpringExtension.class)</code>, you can implement standard JUnit Jupiter-based unit and integration tests and simultaneously reap the benefits of the TestContext framework, such as support for loading
                                    application contexts, dependency injection of test instances, transactional test method execution, and so on.</p>
                            </div>
                            <div class="paragraph">
                                <p>Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the following features above and beyond the feature set that Spring supports for JUnit 4 and TestNG:
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>Dependency injection for test constructors, test methods, and test lifecycle callback methods. See <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a> for further details.</p>
                                    </li>
                                    <li>
                                        <p>Powerful support for <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-conditions">conditional
test execution</a> based on SpEL expressions, environment variables, system properties, and so on. See the documentation for <code>@EnabledIf</code> and <code>@DisabledIf</code> in
                                            <a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details and examples.</p>
                                    </li>
                                    <li>
                                        <p>Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See the <code>@TransactionalDevTestConfig</code> and <code>@TransactionalIntegrationTest</code> examples in
                                            <a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a> for further details.</p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>The following code listing shows how to configure a test class to use the
                                    <code>SpringExtension</code> in conjunction with <code>@ContextConfiguration</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension::class)
// Instructs Spring to load an ApplicationContext from TestConfig::class
@ContextConfiguration(classes = [TestConfig::class])
class SimpleTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the
                                    <code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> composed annotations to simplify the configuration of the test <code>ApplicationContext</code> and JUnit Jupiter.</p>
                            </div>
                            <div class="paragraph">
                                <p>The following example uses <code>@SpringJUnitConfig</code> to reduce the amount of configuration used in the previous example:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig::class)
class SimpleTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Similarly, the following example uses <code>@SpringJUnitWebConfig</code> to create a
                                    <code>WebApplicationContext</code> for use with JUnit Jupiter:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig::class
@SpringJUnitWebConfig(TestWebConfig::class)
class SimpleWebTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>See the documentation for <code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> in
                                    <a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-junit-jupiter-di"><a class="anchor" href="#testcontext-junit-jupiter-di"></a>Dependency Injection with <code>SpringExtension</code></h5>
                            <div class="paragraph">
                                <p><code>SpringExtension</code> implements the
                                    <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution"><code>ParameterResolver</code></a> extension API from JUnit Jupiter, which lets Spring provide dependency injection for test
                                    constructors, test methods, and test lifecycle callback methods.</p>
                            </div>
                            <div class="paragraph">
                                <p>Specifically, <code>SpringExtension</code> can inject dependencies from the test&#8217;s
                                    <code>ApplicationContext</code> into test constructors and methods that are annotated with
                                    <code>@BeforeAll</code>, <code>@AfterAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@Test</code>, <code>@RepeatedTest</code>,
                                    <code>@ParameterizedTest</code>, and others.</p>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-junit-jupiter-di-constructor"><a class="anchor" href="#testcontext-junit-jupiter-di-constructor"></a>Constructor Injection</h6>
                                <div class="paragraph">
                                    <p>If a specific parameter in a constructor for a JUnit Jupiter test class is of type
                                        <code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
                                        <code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific parameter with the corresponding bean or value from the test&#8217;s <code>ApplicationContext</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Spring can also be configured to autowire all arguments for a test class constructor if the constructor is considered to be <em>autowirable</em>. A constructor is considered to be autowirable if one of the following
                                        conditions is met (in order of precedence).</p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p>The constructor is annotated with <code>@Autowired</code>.</p>
                                        </li>
                                        <li>
                                            <p><code>@TestConstructor</code> is present or meta-present on the test class with the <code>autowireMode</code> attribute set to <code>ALL</code>.</p>
                                        </li>
                                        <li>
                                            <p>The default <em>test constructor autowire mode</em> has been changed to <code>ALL</code>.</p>
                                        </li>
                                    </ul>
                                </div>
                                <div class="paragraph">
                                    <p>See <a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a> for details on the use of
                                        <code>@TestConstructor</code> and how to change the global <em>test constructor autowire mode</em>.</p>
                                </div>
                                <div class="admonitionblock warning">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-warning" title="Warning"></i>
                                            </td>
                                            <td class="content">
                                                If the constructor for a test class is considered to be <em>autowirable</em>, Spring assumes the responsibility for resolving arguments for all parameters in the constructor. Consequently, no other <code>ParameterResolver</code>                                                registered with JUnit Jupiter can resolve parameters for such a constructor.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="admonitionblock warning">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-warning" title="Warning"></i>
                                            </td>
                                            <td class="content">
                                                <div class="paragraph">
                                                    <p>Constructor injection for test classes must not be used in conjunction with JUnit Jupiter&#8217;s <code>@TestInstance(PER_CLASS)</code> support if <code>@DirtiesContext</code> is used to close the test&#8217;s
                                                        <code>ApplicationContext</code> before or after test methods.</p>
                                                </div>
                                                <div class="paragraph">
                                                    <p>The reason is that <code>@TestInstance(PER_CLASS)</code> instructs JUnit Jupiter to cache the test instance between test method invocations. Consequently, the test instance will retain references to
                                                        beans that were originally injected from an <code>ApplicationContext</code> that has been subsequently closed. Since the constructor for the test class will only be invoked once in such scenarios,
                                                        dependency injection will not occur again, and subsequent tests will interact with beans from the closed <code>ApplicationContext</code> which may result in errors.</p>
                                                </div>
                                                <div class="paragraph">
                                                    <p>To use <code>@DirtiesContext</code> with "before test method" or "after test method" modes in conjunction with <code>@TestInstance(PER_CLASS)</code>, one must configure dependencies from Spring to be
                                                        supplied via field or setter injection so that they can be re-injected between test method invocations.</p>
                                                </div>
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>In the following example, Spring injects the <code>OrderService</code> bean from the
                                        <code>ApplicationContext</code> loaded from <code>TestConfig.class</code> into the
                                        <code>OrderServiceIntegrationTests</code> constructor.</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){
    // tests that use the injected OrderService
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Note that this feature lets test dependencies be <code>final</code> and therefore immutable.</p>
                                </div>
                                <div class="paragraph">
                                    <p>If the <code>spring.test.constructor.autowire.mode</code> property is to <code>all</code> (see
                                        <a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a>), we can omit the declaration of
                                        <code>@Autowired</code> on the constructor in the previous example, resulting in the following.</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests(val orderService:OrderService) {
    // tests that use the injected OrderService
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="testcontext-junit-jupiter-di-method"><a class="anchor" href="#testcontext-junit-jupiter-di-method"></a>Method Injection</h6>
                                <div class="paragraph">
                                    <p>If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of type <code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
                                        <code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific parameter with the corresponding bean from the test&#8217;s <code>ApplicationContext</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>In the following example, Spring injects the <code>OrderService</code> from the <code>ApplicationContext</code> loaded from <code>TestConfig.class</code> into the <code>deleteOrder()</code> test method:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @Test
    fun deleteOrder(@Autowired orderService: OrderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Due to the robustness of the <code>ParameterResolver</code> support in JUnit Jupiter, you can also have multiple dependencies injected into a single method, not only from Spring but also from JUnit Jupiter itself or
                                        other third-party extensions.</p>
                                </div>
                                <div class="paragraph">
                                    <p>The following example shows how to have both Spring and JUnit Jupiter inject dependencies into the <code>placeOrderRepeatedly()</code> test method simultaneously.</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Note that the use of <code>@RepeatedTest</code> from JUnit Jupiter lets the test method gain access to the <code>RepetitionInfo</code>.</p>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-junit-jupiter-nested-test-configuration"><a class="anchor" href="#testcontext-junit-jupiter-nested-test-configuration"></a><code>@Nested</code> test class configuration</h5>
                            <div class="paragraph">
                                <p>The <em>Spring TestContext Framework</em> has supported the use of test-related annotations on
                                    <code>@Nested</code> test classes in JUnit Jupiter since Spring Framework 5.0; however, until Spring Framework 5.3 class-level test configuration annotations were not <em>inherited</em> from enclosing classes like they
                                    are from superclasses.</p>
                            </div>
                            <div class="paragraph">
                                <p>Spring Framework 5.3 introduces first-class support for inheriting test class configuration from enclosing classes, and such configuration will be inherited by default. To change from the default <code>INHERIT</code> mode
                                    to <code>OVERRIDE</code> mode, you may annotate an individual <code>@Nested</code> test class with
                                    <code>@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)</code>. An explicit
                                    <code>@NestedTestConfiguration</code> declaration will apply to the annotated test class as well as any of its subclasses and nested classes. Thus, you may annotate a top-level test class with <code>@NestedTestConfiguration</code>,
                                    and that will apply to all of its nested test classes recursively.
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>In order to allow development teams to change the default to <code>OVERRIDE</code> – for example, for compatibility with Spring Framework 5.0 through 5.2 – the default mode can be changed globally via a JVM system property
                                    or a <code>spring.properties</code> file in the root of the classpath. See the <a href="#integration-testing-annotations-nestedtestconfiguration">"Changing
the default enclosing configuration inheritance mode"</a> note for details.</p>
                            </div>
                            <div class="paragraph">
                                <p>Although the following "Hello World" example is very simplistic, it shows how to declare common configuration on a top-level class that is inherited by its <code>@Nested</code> test classes. In this particular example,
                                    only the <code>TestConfig</code> configuration class is inherited. Each nested test class provides its own set of active profiles, resulting in a distinct <code>ApplicationContext</code> for each nested test class (see
                                    <a href="#testcontext-ctx-management-caching">Context Caching</a> for details). Consult the list of
                                    <a href="#integration-testing-annotations-nestedtestconfiguration">supported annotations</a> to see which annotations can be inherited in <code>@Nested</code> test classes.</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles("lang_en")
    class EnglishGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hello World");
        }
    }

    @Nested
    @ActiveProfiles("lang_de")
    class GermanGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hallo Welt");
        }
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles("lang_en")
    inner class EnglishGreetings {

        @Test
        fun hello(@Autowired service:GreetingService) {
            assertThat(service.greetWorld()).isEqualTo("Hello World")
        }
    }

    @Nested
    @ActiveProfiles("lang_de")
    inner class GermanGreetings {

        @Test
        fun hello(@Autowired service:GreetingService) {
            assertThat(service.greetWorld()).isEqualTo("Hallo Welt")
        }
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="testcontext-support-classes-testng"><a class="anchor" href="#testcontext-support-classes-testng"></a>TestNG Support Classes</h5>
                            <div class="paragraph">
                                <p>The <code>org.springframework.test.context.testng</code> package provides the following support classes for TestNG based test cases:</p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>AbstractTestNGSpringContextTests</code></p>
                                    </li>
                                    <li>
                                        <p><code>AbstractTransactionalTestNGSpringContextTests</code></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p><code>AbstractTestNGSpringContextTests</code> is an abstract base test class that integrates the Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a TestNG environment. When you
                                    extend <code>AbstractTestNGSpringContextTests</code>, you can access a
                                    <code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.</p>
                            </div>
                            <div class="paragraph">
                                <p><code>AbstractTransactionalTestNGSpringContextTests</code> is an abstract transactional extension of
                                    <code>AbstractTestNGSpringContextTests</code> that adds some convenience functionality for JDBC access. This class expects a <code>javax.sql.DataSource</code> bean and a
                                    <code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you extend <code>AbstractTransactionalTestNGSpringContextTests</code>, you can access a <code>protected</code>
                                    <code>jdbcTemplate</code> instance variable that you can use to run SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application
                                    code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
                                    As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
                                    <code>AbstractTransactionalTestNGSpringContextTests</code> also provides convenience methods that delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>. Furthermore,
                                    <code>AbstractTransactionalTestNGSpringContextTests</code> provides an
                                    <code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
                            </div>
                            <div class="admonitionblock tip">
                                <table>
                                    <tr>
                                        <td class="icon">
                                            <i class="fa icon-tip" title="Tip"></i>
                                        </td>
                                        <td class="content">
                                            These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using <code>@ContextConfiguration</code>,
                                            <code>@TestExecutionListeners</code>, and so on and by manually instrumenting your test class with a <code>TestContextManager</code>. See the source code of <code>AbstractTestNGSpringContextTests</code> for
                                            an example of how to instrument your test class.
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="webtestclient"><a class="anchor" href="#webtestclient"></a>3.6. WebTestClient</h3>
                    <div class="paragraph">
                        <p><code>WebTestClient</code> is an HTTP client designed for testing server applications. It wraps Spring&#8217;s <a href="web-reactive.html#webflux-client">WebClient</a> and uses it to perform requests but exposes a testing facade
                            for verifying responses. <code>WebTestClient</code> can be used to perform end-to-end HTTP tests. It can also be used to test Spring MVC and Spring WebFlux applications without a running server via mock server request and response
                            objects.</p>
                    </div>
                    <div class="admonitionblock tip">
                        <table>
                            <tr>
                                <td class="icon">
                                    <i class="fa icon-tip" title="Tip"></i>
                                </td>
                                <td class="content">
                                    Kotlin users: See <a href="languages.html#kotlin-webtestclient-issue">this section</a> related to use of the <code>WebTestClient</code>.
                                </td>
                            </tr>
                        </table>
                    </div>
                    <div class="sect3">
                        <h4 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a>3.6.1. Setup</h4>
                        <div class="paragraph">
                            <p>To set up a <code>WebTestClient</code> you need to choose a server setup to bind to. This can be one of several mock server setup choices or a connection to a live server.</p>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a>Bind to Controller</h5>
                            <div class="paragraph">
                                <p>This setup allows you to test specific controller(s) via mock request and response objects, without a running server.</p>
                            </div>
                            <div class="paragraph">
                                <p>For WebFlux applications, use the following which loads infrastructure equivalent to the
                                    <a href="web-reactive.html#webflux-config">WebFlux Java config</a>, registers the given controller(s), and creates a <a href="web-reactive.html#webflux-web-handler-api">WebHandler chain</a> to handle requests:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebTestClient client =
        WebTestClient.bindToController(new TestController()).build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val client = WebTestClient.bindToController(TestController()).build()</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>For Spring MVC, use the following which delegates to the
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/setup/StandaloneMockMvcBuilder.html">StandaloneMockMvcBuilder</a>                                    to load infrastructure equivalent to the <a href="web.html#mvc-config">WebMvc Java config</a>, registers the given controller(s), and creates an instance of
                                    <a href="#spring-mvc-test-framework">MockMvc</a> to handle requests:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebTestClient client =
        MockMvcWebTestClient.bindToController(new TestController()).build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val client = MockMvcWebTestClient.bindToController(TestController()).build()</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a>Bind to <code>ApplicationContext</code></h5>
                            <div class="paragraph">
                                <p>This setup allows you to load Spring configuration with Spring MVC or Spring WebFlux infrastructure and controller declarations and use it to handle requests via mock request and response objects, without a running server.</p>
                            </div>
                            <div class="paragraph">
                                <p>For WebFlux, use the following where the Spring <code>ApplicationContext</code> is passed to
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html#applicationContext-org.springframework.context.ApplicationContext-">WebHttpHandlerBuilder</a>                                    to create the <a href="web-reactive.html#webflux-web-handler-api">WebHandler chain</a> to handle requests:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(WebConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    WebTestClient client;

    @BeforeEach
    void setUp(ApplicationContext context) {  <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration to load</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Inject the configuration</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Create the <code>WebTestClient</code></td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(WebConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    lateinit var client: WebTestClient

    @BeforeEach
    fun setUp(context: ApplicationContext) { <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration to load</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Inject the configuration</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Create the <code>WebTestClient</code></td>
                                    </tr>
                                </table>
                            </div>
                            <div class="paragraph">
                                <p>For Spring MVC, use the following where the Spring <code>ApplicationContext</code> is passed to
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/web/servlet/setup/MockMvcBuilders.html#webAppContextSetup-org.springframework.web.context.WebApplicationContext-">MockMvcBuilders.webAppContextSetup</a>                                    to create a <a href="#spring-mvc-test-framework">MockMvc</a> instance to handle requests:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration("classpath:META-INF/web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
@ContextHierarchy({
    @ContextConfiguration(classes = RootConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class MyTests {

    @Autowired
    WebApplicationContext wac; <i class="conum" data-value="2"></i><b>(2)</b>

    WebTestClient client;

    @BeforeEach
    void setUp() {
        client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration to load</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Inject the configuration</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Create the <code>WebTestClient</code></td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration("classpath:META-INF/web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
@ContextHierarchy({
    @ContextConfiguration(classes = RootConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class MyTests {

    @Autowired
    lateinit var wac: WebApplicationContext; <i class="conum" data-value="2"></i><b>(2)</b>

    lateinit var client: WebTestClient

    @BeforeEach
    fun setUp() { <i class="conum" data-value="2"></i><b>(2)</b>
        client = MockMvcWebTestClient.bindToApplicationContext(wac).build() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Specify the configuration to load</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Inject the configuration</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Create the <code>WebTestClient</code></td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a>Bind to Router Function</h5>
                            <div class="paragraph">
                                <p>This setup allows you to test <a href="web-reactive.html#webflux-fn">functional endpoints</a> via mock request and response objects, without a running server.</p>
                            </div>
                            <div class="paragraph">
                                <p>For WebFlux, use the following which delegates to <code>RouterFunctions.toWebHandler</code> to create a server setup to handle requests:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RouterFunction&lt;?&gt; route = ...
client = WebTestClient.bindToRouterFunction(route).build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val route: RouterFunction&lt;*&gt; = ...
val client = WebTestClient.bindToRouterFunction(route).build()</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>For Spring MVC there are currently no options to test
                                    <a href="web.html#webmvc-fn">WebMvc functional endpoints</a>.</p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a>Bind to Server</h5>
                            <div class="paragraph">
                                <p>This setup connects to a running server to perform full, end-to-end HTTP tests:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build()</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a>Client Config</h5>
                            <div class="paragraph">
                                <p>In addition to the server setup options described earlier, you can also configure client options, including base URL, default headers, client filters, and others. These options are readily available following <code>bindToServer()</code>.
                                    For all other configuration options, you need to use <code>configureClient()</code> to transition from server to client configuration, as follows:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client = WebTestClient.bindToController(new TestController())
        .configureClient()
        .baseUrl("/test")
        .build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client = WebTestClient.bindToController(TestController())
        .configureClient()
        .baseUrl("/test")
        .build()</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a>3.6.2. Writing Tests</h4>
                        <div class="paragraph">
                            <p><code>WebTestClient</code> provides an API identical to <a href="web-reactive.html#webflux-client">WebClient</a> up to the point of performing a request by using <code>exchange()</code>. See the
                                <a href="web-reactive.html#webflux-client-body">WebClient</a> documentation for examples on how to prepare a request with any content including form data, multipart data, and more.</p>
                        </div>
                        <div class="paragraph">
                            <p>After the call to <code>exchange()</code>, <code>WebTestClient</code> diverges from the <code>WebClient</code> and instead continues with a workflow to verify responses.</p>
                        </div>
                        <div class="paragraph">
                            <p>To assert the response status and headers, use the following:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.get().uri("/persons/1")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.get().uri("/persons/1")
        .accept(MediaType.APPLICATION_JSON)
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>You can then choose to decode the response body through one of the following:</p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p><code>expectBody(Class&lt;T&gt;)</code>: Decode to single object.</p>
                                </li>
                                <li>
                                    <p><code>expectBodyList(Class&lt;T&gt;)</code>: Decode and collect objects to <code>List&lt;T&gt;</code>.</p>
                                </li>
                                <li>
                                    <p><code>expectBody()</code>: Decode to <code>byte[]</code> for <a href="#webtestclient-json">JSON Content</a> or an empty body.</p>
                                </li>
                            </ul>
                        </div>
                        <div class="paragraph">
                            <p>And perform assertions on the resulting higher level Object(s):</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList(Person.class).hasSize(3).contains(person);</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.reactive.server.expectBodyList

client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList&lt;Person&gt;().hasSize(3).contains(person)</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>If the built-in assertions are insufficient, you can consume the object instead and perform any other assertions:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.test.web.reactive.server.expectBody

client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .consumeWith(result -&gt; {
            // custom assertions (e.g. AssertJ)...
        });</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody&lt;Person&gt;()
        .consumeWith {
            // custom assertions (e.g. AssertJ)...
        }</code></pre>
                            </div>
                        </div>
                        <div class="paragraph">
                            <p>Or you can exit the workflow and obtain an <code>EntityExchangeResult</code>:</p>
                        </div>
                        <div class="listingblock primary">
                            <div class="title">Java</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">EntityExchangeResult&lt;Person&gt; result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();</code></pre>
                            </div>
                        </div>
                        <div class="listingblock secondary">
                            <div class="title">Kotlin</div>
                            <div class="content">
                                <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.reactive.server.expectBody

val result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk
        .expectBody&lt;Person&gt;()
        .returnResult()</code></pre>
                            </div>
                        </div>
                        <div class="admonitionblock tip">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-tip" title="Tip"></i>
                                    </td>
                                    <td class="content">
                                        When you need to decode to a target type with generics, look for the overloaded methods that accept
                                        <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/core/ParameterizedTypeReference.html"><code>ParameterizedTypeReference</code></a> instead of <code>Class&lt;T&gt;</code>.
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a>No Content</h5>
                            <div class="paragraph">
                                <p>If the response is not expected to have content, you can assert that as follows:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.post().uri("/persons")
        .body(personMono, Person.class)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.post().uri("/persons")
        .bodyValue(person)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty()</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>If you want to ignore the response content, the following releases the content without any assertions:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound()
        .expectBody(Void.class);</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound
        .expectBody&lt;Unit&gt;()</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a>JSON Content</h5>
                            <div class="paragraph">
                                <p>You can use <code>expectBody()</code> without a target type to perform assertions on the raw content rather than through higher level Object(s).</p>
                            </div>
                            <div class="paragraph">
                                <p>To verify the full JSON content with <a href="https://jsonassert.skyscreamer.org">JSONAssert</a>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>To verify JSON content with <a href="https://github.com/jayway/JsonPath">JSONPath</a>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason");</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason")</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a>Streaming Responses</h5>
                            <div class="paragraph">
                                <p>To test potentially infinite streams such as <code>"text/event-stream"</code> or
                                    <code>"application/x-ndjson"</code>, start by verifying the response status and headers, and then obtain a <code>FluxExchangeResult</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult(MyEvent.class);</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.reactive.server.returnResult

val result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult&lt;MyEvent&gt;()</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Now you&#8217;re ready to consume the response stream with <code>StepVerifier</code> from <code>reactor-test</code>:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Event&gt; eventFlux = result.getResponseBody();

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith(p -&gt; ...)
        .thenCancel()
        .verify();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val eventFlux = result.getResponseBody()

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith { p -&gt; ... }
        .thenCancel()
        .verify()</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="webtestclient-mockmvc"><a class="anchor" href="#webtestclient-mockmvc"></a>MockMvc Assertions</h5>
                            <div class="paragraph">
                                <p><code>WebTestClient</code> is an HTTP client and as such it can only verify what is in the client response including status, headers, and body.</p>
                            </div>
                            <div class="paragraph">
                                <p>When testing a Spring MVC application with a MockMvc server setup, you have the extra choice to perform further assertions on the server response. To do that start by obtaining an <code>ExchangeResult</code> after asserting
                                    the body:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// For a response with a body
EntityExchangeResult&lt;Person&gt; result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();

// For a response without a body
EntityExchangeResult&lt;Void&gt; result = client.get().uri("/path")
        .exchange()
        .expectBody().isEmpty();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// For a response with a body
val result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();

// For a response without a body
val result = client.get().uri("/path")
        .exchange()
        .expectBody().isEmpty();</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>Then switch to MockMvc server response assertions:</p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvcWebTestClient.resultActionsFor(result)
        .andExpect(model().attribute("integer", 3))
        .andExpect(model().attribute("string", "a string value"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">MockMvcWebTestClient.resultActionsFor(result)
        .andExpect(model().attribute("integer", 3))
        .andExpect(model().attribute("string", "a string value"));</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="spring-mvc-test-framework"><a class="anchor" href="#spring-mvc-test-framework"></a>3.7. MockMvc</h3>
                    <div class="paragraph">
                        <p>
                            The Spring MVC Test framework, also known as MockMvc, provides support for testing Spring MVC applications. It performs full Spring MVC request handling but via mock request and response objects instead of a running server.</br>
                            <span class="translate">
                            Spring MVC测试框架，也称为MockMvc，提供了对Spring MVC应用程序测试的支持。它执行完整的Spring MVC请求处理，但是是通过模拟请求和响应对象，而不是运行的服务器。
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>
                            MockMvc can be used on its own to perform requests and verify responses. It can also be used through the <a href="#webtestclient">WebTestClient</a> where MockMvc is plugged in as the server to handle requests with. The advantage
                            of <code>WebTestClient</code> is the option to work with higher level objects instead of raw data as well as the ability to switch to full, end-to-end HTTP tests against a live server and use the same test API.</br>
                            <span class="translate">
                            MockMvc可以单独用于执行请求和验证响应。它也可以通过WebTestClient使用，在这里MockMvc作为服务器被插入来处理请求。
                            WebTestClient的优点是可以选择使用更高级别的对象，而不是原始数据，并且能够针对活动服务器切换到完整的端到端HTTP测试，并使用相同的测试API。
                        </p>
                    </div>
                    <div class="sect3">
                        <h4 id="spring-mvc-test-server"><a class="anchor" href="#spring-mvc-test-server"></a>3.7.1. Overview</h4>
                        <span>3.7.1 概述</span>
                        <div class="paragraph">
                            <p>
                                You can write plain unit tests for Spring MVC by instantiating a controller, injecting it with dependencies, and calling its methods. However such tests do not verify request mappings, data binding, message conversion, type
                                conversion, validation, and nor do they involve any of the supporting <code>@InitBinder</code>, <code>@ModelAttribute</code>, or
                                <code>@ExceptionHandler</code> methods.</br>
                                <span class="translate">
                                您可以为Spring MVC编写简单的单元测试，方法是实例化一个控制器，向它注入依赖项，并调用它的方法。
                                但是，这些测试不验证请求映射、数据绑定、消息转换、类型转换、验证，也不涉及任何支持的@InitBinder、@ModelAttribute或@ExceptionHandler方法。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                The Spring MVC Test framework, also known as <code>MockMvc</code>, aims to provide more complete testing for Spring MVC controllers without a running server. It does that by invoking the <code>DispacherServlet</code> and passing
                                <a href="#mock-objects-servlet">&#8220;mock&#8221; implementations of the Servlet API</a> from the
                                <code>spring-test</code> module which replicates the full Spring MVC request handling without a running server.</br>
                                Spring MVC测试框架，也称为MockMvc，旨在为Spring MVC控制器提供更完整的测试，而无需运行服务器。
                                它通过调用DispacherServlet，并从Spring -test模块传递Servlet API的“模拟”实现，该模块复制了完整的Spring MVC请求处理，而没有运行服务器。
                            </p>
                        </div>
                        <div class="paragraph">
                            <p>
                                MockMvc is a server side test framework that lets you verify most of the functionality of a Spring MVC application using lightweight and targeted tests. You can use it on its own to perform requests and to verify responses,
                                or you can also use it through the <a href="#webtestclient">WebTestClient</a> API with MockMvc plugged in as the server to handle requests with.</br>
                                <span class="translate">
                                MockMvc是一个服务器端测试框架，它允许您使用轻量级和目标测试来验证Spring MVC应用程序的大部分功能。
                                您可以单独使用它来执行请求和验证响应，或者您也可以通过插入MockMvc的WebTestClient API使用它作为服务器来处理请求。
                            </p>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-static-imports"><a class="anchor" href="#spring-mvc-test-server-static-imports"></a>Static Imports</h5>
                            <div class="paragraph">
                                <p>When using MockMvc directly to perform requests, you&#8217;ll need static imports for:</br>
                                    <span class="translate">
                                    当使用MockMvc直接执行请求时，你将需要以下静态导入:
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p><code>MockMvcBuilders.*</code></p>
                                    </li>
                                    <li>
                                        <p><code>MockMvcRequestBuilders.*</code></p>
                                    </li>
                                    <li>
                                        <p><code>MockMvcResultMatchers.*</code></p>
                                    </li>
                                    <li>
                                        <p><code>MockMvcResultHandlers.*</code></p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>
                                    An easy way to remember that is search for <code>MockMvc*</code>. If using Eclipse be sure to also add the above as &#8220;favorite static members&#8221; in the Eclipse preferences.</br>
                                    <span class="translate">
                                    记住这一点的一个简单方法是搜索MockMvc*。如果使用Eclipse，请确保在Eclipse首选项中也将上述内容添加为“喜爱的静态成员”。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    When using MockMvc through the <a href="#webtestclient">WebTestClient</a> you do not need static imports. The <code>WebTestClient</code> provides a fluent API without static imports.
                                    <span class="translate">
                                    当通过WebTestClient使用MockMvc时，你不需要静态导入。WebTestClient提供了一个流畅的API，无需静态导入。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-setup-options"><a class="anchor" href="#spring-mvc-test-server-setup-options"></a>Setup Choices</h5>
                            <span class="translate">设置选择</span>
                            <div class="paragraph">
                                <p>
                                    MockMvc can be setup in one of two ways. One is to point directly to the controllers you want to test and programmatically configure Spring MVC infrastructure. The second is to point to Spring configuration with Spring
                                    MVC and controller infrastructure in it.</br>
                                    <span class="translate">
                                    可以通过两种方式之一来设置MockMvc。一种方法是直接指向您想要测试和以编程方式配置Spring MVC基础设施的控制器。
                                    第二点是指向包含Spring MVC和控制器基础设施的Spring配置。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    To set up MockMvc for testing a specific controller, use the following:</br>
                                    <span class="translate">
                                    要设置MockMvc来测试一个特定的控制器，请使用以下方法:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyWebTests {

    lateinit var mockMvc : MockMvc

    @BeforeEach
    fun setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Or you can also use this setup when testing through the
                                    <a href="#webtestclient-controller-config">WebTestClient</a> which delegates to the same builder as shown above.</br>
                                    <span class="translate">
                                    或者，您也可以在通过WebTestClient进行测试时使用此设置，后者委托给如上所示的相同的构建器。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>To set up MockMvc through Spring configuration, use the following:</br>
                                    <span class="translate">
                                    通过Spring配置来设置MockMvc，使用以下方法:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["my-servlet-context.xml"])
class MyWebTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Or you can also use this setup when testing through the
                                    <a href="#webtestclient-context-config">WebTestClient</a> which delegates to the same builder as shown above.</br>
                                    <span class="translate">
                                    或者，您也可以在通过WebTestClient进行测试时使用此设置，后者委托给如上所示的相同的构建器。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>Which setup option should you use?</br>
                                    <span class="translate">
                                    应该使用哪个设置选项?
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The <code>webAppContextSetup</code> loads your actual Spring MVC configuration, resulting in a more complete integration test. Since the TestContext framework caches the loaded Spring configuration, it helps keep tests
                                    running fast, even as you introduce more tests in your test suite. Furthermore, you can inject mock services into controllers through Spring configuration to remain focused on testing the web layer. The following example
                                    declares a mock service with Mockito:</br>
                                    <span class="translate">
                                    webAppContextSetup会加载你实际的Spring MVC配置，从而产生一个更完整的集成测试。由于TestContext框架缓存加载的Spring配置，因此它有助于保持测试快速运行，即使您在测试套件中引入更多测试。
                                    此外，您可以通过Spring配置将模拟服务注入到控制器中，以保持专注于测试web层。下面的例子用Mockito声明了一个模拟服务:
                                </p>
                            </div>
                            <div class="listingblock">
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="org.example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>You can then inject the mock service into the test to set up and verify your expectations, as the following example shows:</br>
                                    <span class="translate">
                                    然后，您可以将模拟服务注入到测试中，以设置和验证您的期望，如下面的示例所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class AccountTests {

    @Autowired
    lateinit var accountService: AccountService

    lateinit mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The <code>standaloneSetup</code>, on the other hand, is a little closer to a unit test. It tests one controller at a time. You can manually inject the controller with mock dependencies, and it does not involve loading Spring
                                    configuration. Such tests are more focused on style and make it easier to see which controller is being tested, whether any specific Spring MVC configuration is required to work, and so on. The <code>standaloneSetup</code> is also a very convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.</br>
                                    <span class="translate">
                                    另一方面，独立设置更接近单元测试。它一次测试一个控制器。您可以用模拟依赖项手动注入控制器，而且它不涉及加载Spring配置。这类测试更关注于样式，更容易查看正在测试的控制器，是否需要任何特定的Spring MVC配置，等等。
                                    独立设置也是编写特别测试来验证特定行为或调试问题的一种非常方便的方式。
                                </p>

                            </div>
                            <div class="paragraph">
                                <p>
                                    As with most &#8220;integration versus unit testing&#8221; debates, there is no right or wrong answer. However, using the <code>standaloneSetup</code> does imply the need for additional
                                    <code>webAppContextSetup</code> tests in order to verify your Spring MVC configuration. Alternatively, you can write all your tests with <code>webAppContextSetup</code>, in order to always test against your actual Spring
                                    MVC configuration.</br>
                                    <span class="translate">
                                    就像大多数关于“集成还是单元测试”的争论一样，没有正确或错误的答案。然而，使用独立设置意味着需要额外的webAppContextSetup测试来验证您的Spring MVC配置。
                                    或者，你也可以用webAppContextSetup编写所有的测试，以便始终针对你实际的Spring MVC配置进行测试。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-setup-steps"><a class="anchor" href="#spring-mvc-test-server-setup-steps"></a>Setup Features</h5>
                            <span>设置功能</span>
                            <div class="paragraph">
                                <p>
                                    No matter which MockMvc builder you use, all <code>MockMvcBuilder</code> implementations provide some common and very useful features. For example, you can declare an <code>Accept</code> header for all requests and expect
                                    a status of 200 as well as a <code>Content-Type</code> header in all responses, as follows:</br>
                                    <span class="translate">
                                    不管你使用哪个MockMvc构建器，所有的MockMvcBuilder实现都提供了一些通用且非常有用的特性。
                                    例如，您可以为所有请求声明一个Accept头，并期望状态为200，以及在所有响应中声明一个Content-Type头，如下所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    In addition, third-party frameworks (and applications) can pre-package setup instructions, such as those in a <code>MockMvcConfigurer</code>. The Spring Framework has one such built-in implementation that helps to save
                                    and re-use the HTTP session across requests. You can use it as follows:</br>
                                    <span class="translate">
                                    此外，第三方框架(和应用程序)可以预先打包设置指令，比如MockMvcConfigurer中的指令。Spring框架有一个这样的内置实现，它有助于跨请求保存和重用HTTP会话。你可以这样使用它:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    See the javadoc for
                                    <a href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html"><code>ConfigurableMockMvcBuilder</code></a> for a list of all MockMvc
                                    builder features or use the IDE to explore the available options.</br>
                                    <span class="translate">
                                    请参阅javadoc中的ConfigurableMockMvcBuilder，以获得所有MockMvc构建器特性的列表，或者使用IDE来探索可用的选项。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-performing-requests"><a class="anchor" href="#spring-mvc-test-server-performing-requests"></a>Performing Requests</h5>
                            <span>执行请求</span>
                            <div class="paragraph">
                                <p>
                                    This section shows how to use MockMvc on its own to perform requests and verify responses. If using MockMvc through the <code>WebTestClient</code> please see the corresponding section on
                                    <a href="#webtestclient-tests">Writing Tests</a> instead.</br>
                                    <span class="translate">
                                    本节将展示如何单独使用MockMvc来执行请求和验证响应。如果通过WebTestClient使用MockMvc，请参阅相应的编写测试部分。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>To perform requests that use any HTTP method, as the following example shows:</br>
                                    <span class="translate">
                                    执行使用任何HTTP方法的请求，如下所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.*

mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/hotels/{id}", 42) {
    accept = MediaType.APPLICATION_JSON
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can also perform file upload requests that internally use
                                    <code>MockMultipartHttpServletRequest</code> so that there is no actual parsing of a multipart request. Rather, you have to set it up to be similar to the following example:<br>
                                    <span class="translate">
                                    您还可以执行内部使用MockMultipartHttpServletRequest的文件上传请求，这样就不会对多部分请求进行实际的解析。相反，你必须像下面的例子那样设置它:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.multipart

mockMvc.multipart("/doc") {
    file("a1", "ABC".toByteArray(charset("UTF8")))
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can specify query parameters in URI template style, as the following example shows:</br>
                                    <span class="translate">
                                    您可以使用URI模板样式指定查询参数，示例如下:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/hotels?thing={thing}", "somewhere")</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    You can also add Servlet request parameters that represent either query or form parameters, as the following example shows:</br>
                                    <span class="translate">
                                    您还可以添加表示查询或表单参数的Servlet请求参数，如下面的示例所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/hotels").param("thing", "somewhere"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/hotels") {
    param("thing", "somewhere")
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If application code relies on Servlet request parameters and does not check the query string explicitly (as is most often the case), it does not matter which option you use. Keep in mind, however, that query parameters
                                    provided with the URI template are decoded while request parameters provided through the <code>param(&#8230;&#8203;)</code> method are expected to already be decoded.</br>
                                    <span class="translate">
                                    如果应用程序代码依赖于Servlet请求参数，并且不显式地检查查询字符串(这是最常见的情况)，那么使用哪个选项并不重要。但是，请记住，通过URI模板提供的查询参数已经被解码，而通过param(…)方法提供的请求参数预计已经被解码。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    In most cases, it is preferable to leave the context path and the Servlet path out of the request URI. If you must test with the full request URI, be sure to set the <code>contextPath</code> and <code>servletPath</code> accordingly so that request mappings work, as the following example shows:</br>
                                    <span class="translate">
                                    在大多数情况下，最好在请求URI之外保留上下文路径和Servlet路径。如果你必须使用完整的请求URI进行测试，请确保相应地设置contextPath和servletPath以便请求映射工作，如下面的例子所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/app/main/hotels/{id}") {
    contextPath = "/app"
    servletPath = "/main"
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    In the preceding example, it would be cumbersome to set the <code>contextPath</code> and
                                    <code>servletPath</code> with every performed request. Instead, you can set up default request properties, as the following example shows:</br>
                                    <span class="translate">
                                    在前面的示例中，为每个执行的请求设置contextPath和servletPath会很麻烦。相反，你可以设置默认的请求属性，如下面的例子所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get("/")
            .contextPath("/app").servletPath("/main")
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The preceding properties affect every request performed through the <code>MockMvc</code> instance.
                                    If the same property is also specified on a given request, it overrides the default value. That is why the HTTP method and
                                    URI in the default request do not matter, since they must be specified on every request.</br>
                                    <span class="translate">
                                    上述属性影响通过MockMvc实例执行的每个请求。如果在给定的请求上也指定了相同的属性，它将覆盖默认值。这就是为什么默认请求中的HTTP方法和URI不重要的原因，因为它们必须在每个请求上指定。
                                </p>

                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-defining-expectations"><a class="anchor" href="#spring-mvc-test-server-defining-expectations"></a>Defining Expectations</h5>
                            <span class="translate">定义预期的结果</span>
                            <div class="paragraph">
                                <p>
                                    You can define expectations by appending one or more <code>.andExpect(..)</code> calls after performing a request, as the following example shows:</br>
                                    <span class="translate">
                                    您可以通过在执行请求后附加一个或多个.andExpect(..)调用来定义期望，如下面的示例所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*

mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/accounts/1").andExpect {
    status().isOk()
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    <code>MockMvcResultMatchers.*</code> provides a number of expectations, some of which are further nested with more detailed expectations.</br>
                                    <span class="translate">
                                    MockMvcResultMatchers。*提供了许多期望，其中一些与更详细的期望进一步嵌套。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Expectations fall in two general categories. The first category of assertions verifies properties of the response (for example, the response status, headers, and content). These are the most important results to assert.</br>
                                    <span class="translate">
                                    期望值一般分为两类。第一类断言验证响应的属性(例如，响应状态、头和内容)。这些是要断言的最重要的结果。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The second category of assertions goes beyond the response. These assertions let you inspect Spring MVC specific aspects, such as which controller method processed the request, whether an exception was raised and handled,
                                    what the content of the model is, what view was selected, what flash attributes were added, and so on. They also let you inspect Servlet specific aspects, such as request and session attributes.</br>
                                    <span class="translate">
                                    第二类断言超出了响应。这些断言让您可以检查Spring MVC特定的方面，比如哪个控制器方法处理了请求，是否引发并处理了异常，模型的内容是什么，选择了什么视图，添加了什么flash属性，等等。
                                    它们还允许您检查Servlet特定的方面，如请求和会话属性。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The following test asserts that binding or validation failed:</br>
                                    <span class="translate">
                                    以下测试断言绑定或验证失败:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(post("/persons"))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andExpect {
    status().isOk()
    model {
        attributeHasErrors("person")
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Many times, when writing tests, it is useful to dump the results of the performed request. You can do so as follows, where <code>print()</code> is a static import from
                                    <code>MockMvcResultHandlers</code>:</br>
                                    <span class="translate">
                                    很多时候，在编写测试时，转储执行请求的结果是有用的。你可以这样做，其中print()是从MockMvcResultHandlers静态导入的:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(post("/persons"))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andDo {
        print()
    }.andExpect {
        status().isOk()
        model {
            attributeHasErrors("person")
        }
    }</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    As long as request processing does not cause an unhandled exception, the <code>print()</code> method prints all the available result data to <code>System.out</code>. There is also a <code>log()</code> method and two additional
                                    variants of the <code>print()</code> method, one that accepts an <code>OutputStream</code> and one that accepts a <code>Writer</code>. For example, invoking <code>print(System.err)</code> prints the result data to <code>System.err</code>,
                                    while invoking <code>print(myWriter)</code> prints the result data to a custom writer. If you want to have the result data logged instead of printed, you can invoke the
                                    <code>log()</code> method, which logs the result data as a single <code>DEBUG</code> message under the
                                    <code>org.springframework.test.web.servlet.result</code> logging category.</br>
                                    <span class="translate">
                                    只要请求处理不会导致未处理的异常，print()方法将所有可用的结果数据打印到System.out。还有一个log()方法和print()方法的另外两个变体，一个接受OutputStream，另一个接受Writer。
                                    例如，调用print(System.err)将结果数据打印到System。err时调用print(myWriter)将结果数据打印到自定义写入器。
                                    如果希望记录结果数据而不是打印出来，可以调用log()方法，该方法将结果数据作为单个DEBUG消息记录在org.springframework.test.web.servlet.result logging类别下。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    In some cases, you may want to get direct access to the result and verify something that cannot be verified otherwise. This can be achieved by appending <code>.andReturn()</code> after all other expectations, as the following
                                    example shows:</br>
                                    <span class="translate">
                                    在某些情况下，您可能希望直接访问结果，并验证无法通过其他方式验证的内容。这可以通过在所有其他期望之后添加.andReturn()来实现，如下面的例子所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
// ...</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">var mvcResult = mockMvc.post("/persons").andExpect { status().isOk() }.andReturn()
// ...</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    If all tests repeat the same expectations, you can set up common expectations once when building the <code>MockMvc</code> instance,
                                    as the following example shows:</br>
                                    <span class="translate">
                                    如果所有的测试重复相同的期望，您可以在构建MockMvc实例时设置一次公共期望，如下面的例子所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build()</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Note that common expectations are always applied and cannot be overridden without creating a separate <code>MockMvc</code> instance.</br>
                                    <span class="translate">
                                    请注意，公共期望总是被应用，并且不能在没有创建单独的MockMvc实例的情况下被重写。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    When a JSON response content contains hypermedia links created with
                                    <a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the resulting links by using JsonPath expressions,
                                    as the following example shows:</br>
                                    <span class="translate">
                                    当JSON响应内容包含使用Spring HATEOAS创建的超媒体链接时，您可以使用JsonPath表达式验证生成的链接，如下面的示例所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/people") {
    accept(MediaType.APPLICATION_JSON)
}.andExpect {
    jsonPath("$.links[?(@.rel == 'self')].href") {
        value("http://localhost:8080/people")
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    When XML response content contains hypermedia links created with
                                    <a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the resulting links by using XPath expressions:</br>
                                    <span class="translate">
                                    当XML响应内容包含使用Spring HATEOAS创建的超媒体链接时，可以使用XPath表达式验证产生的链接:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Map&lt;String, String&gt; ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
    .andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ns = mapOf("ns" to "http://www.w3.org/2005/Atom")
mockMvc.get("/handle") {
    accept(MediaType.APPLICATION_XML)
}.andExpect {
    xpath("/person/ns:link[@rel='self']/@href", ns) {
        string("http://localhost:8080/people")
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-async-requests"><a class="anchor" href="#spring-mvc-test-async-requests"></a>Async Requests</h5>
                            <span>异步请求</span>
                            <div class="paragraph">
                                <p>
                                    This section shows how to use MockMvc on its own to test asynchronous request handling. If using MockMvc through the <a href="#webtestclient">WebTestClient</a>, there is nothing special to do to make asynchronous requests
                                    work as the <code>WebTestClient</code> automatically does what is described in this section.</br>
                                    <span class="translate">
                                    本节将展示如何单独使用MockMvc来测试异步请求处理。如果通过WebTestClient使用MockMvc，就没有什么特别的事情可以让异步请求工作，因为WebTestClient会自动执行本节中描述的操作。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Servlet 3.0 asynchronous requests,
                                    <a href="web.html#mvc-ann-async">supported in Spring MVC</a>, work by exiting the Servlet container thread and allowing the application to compute the response asynchronously, after which an async dispatch is made to
                                    complete processing on a Servlet container thread.</br>
                                    <span class="translate">
                                    Spring MVC支持的Servlet 3.0异步请求通过退出Servlet容器线程并允许应用程序异步计算响应来工作，然后进行异步调度以完成对Servlet容器线程的处理。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    In Spring MVC Test, async requests can be tested by asserting the produced async value first, then manually performing the async dispatch, and finally verifying the response. Below is an example test for controller methods
                                    that return <code>DeferredResult</code>, <code>Callable</code>, or reactive type such as Reactor <code>Mono</code>:</br>
                                    <span class="translate">
                                    在Spring MVC测试中，可以通过先断言生成的异步值，然后手动执行异步分派，最后验证响应来测试异步请求。下面是一个返回DeferredResult、Callable或reactive类型(如Reactor Mono)的控制器方法的测试示例:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*

@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get("/path"))
            .andExpect(status().isOk()) <i class="conum" data-value="1"></i><b>(1)</b>
            .andExpect(request().asyncStarted()) <i class="conum" data-value="2"></i><b>(2)</b>
            .andExpect(request().asyncResult("body")) <i class="conum" data-value="3"></i><b>(3)</b>
            .andReturn();

    this.mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect(status().isOk()) <i class="conum" data-value="5"></i><b>(5)</b>
            .andExpect(content().string("body"));
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Check response status is still unchanged<span class="translate">[检查响应状态仍未改变]</span></td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Async processing must have started<span class="translate">[异步处理必须已启动]</span></td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Wait and assert the async result[等待并断言异步结果]</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="4"></i><b>4</b></td>
                                        <td>Manually perform an ASYNC dispatch (as there is no running container)<span class="translate">[手动执行ASYNC dispatch(因为没有正在运行的容器)]</span></td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="5"></i><b>5</b></td>
                                        <td>Verify the final response<span class="translate">[验证最终响应]</span></td>
                                    </tr>
                                </table>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun test() {
    var mvcResult = mockMvc.get("/path").andExpect {
        status().isOk() <i class="conum" data-value="1"></i><b>(1)</b>
        request { asyncStarted() } <i class="conum" data-value="2"></i><b>(2)</b>
        // TODO Remove unused generic parameter
        request { asyncResult&lt;Nothing&gt;("body") } <i class="conum" data-value="3"></i><b>(3)</b>
    }.andReturn()


    mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect {
                status().isOk() <i class="conum" data-value="5"></i><b>(5)</b>
                content().string("body")
            }
}</code></pre>
                                </div>
                            </div>
                            <div class="colist arabic">
                                <table>
                                    <tr>
                                        <td><i class="conum" data-value="1"></i><b>1</b></td>
                                        <td>Check response status is still unchanged</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="2"></i><b>2</b></td>
                                        <td>Async processing must have started</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="3"></i><b>3</b></td>
                                        <td>Wait and assert the async result</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="4"></i><b>4</b></td>
                                        <td>Manually perform an ASYNC dispatch (as there is no running container)</td>
                                    </tr>
                                    <tr>
                                        <td><i class="conum" data-value="5"></i><b>5</b></td>
                                        <td>Verify the final response</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-vs-streaming-response"><a class="anchor" href="#spring-mvc-test-vs-streaming-response"></a>Streaming Responses</h5>
                            <span>流媒体的响应</span>
                            <div class="paragraph">
                                <p>
                                    The best way to test streaming responses such as Server-Sent Events is through the
                                    <a href="#webtestclient">WebTestClient</a> which can be used as a test client to connect to a <code>MockMvc</code> instance to
                                    perform tests on Spring MVC controllers without a running server. For example:</br>
                                    <span class="translate">
                                    测试流响应(如server - sent Events)的最佳方法是通过WebTestClient，它可以作为测试客户端连接到MockMvc实例，在没有运行服务器的情况下在Spring MVC控制器上执行测试。例如:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebTestClient client = MockMvcWebTestClient.bindToController(new SseController()).build();

FluxExchangeResult&lt;Person&gt; exchangeResult = client.get()
        .uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType("text/event-stream")
        .returnResult(Person.class);

// Use StepVerifier from Project Reactor to test the streaming response

StepVerifier.create(exchangeResult.getResponseBody())
        .expectNext(new Person("N0"), new Person("N1"), new Person("N2"))
        .expectNextCount(4)
        .consumeNextWith(person -&gt; assertThat(person.getName()).endsWith("7"))
        .thenCancel()
        .verify();</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    <code>WebTestClient</code> can also connect to a live server and perform full end-to-end integration tests. This is also supported in Spring Boot where you can
                                    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server">test a running server</a>.</br>
                                    <span class="translate">
                                    WebTestClient也可以连接到一个活动服务器并执行完整的端到端集成测试。Spring Boot也支持这一点，您可以在那里测试正在运行的服务器。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-filters"><a class="anchor" href="#spring-mvc-test-server-filters"></a>Filter Registrations</h5>
                            <span>过滤器注册</span>
                            <div class="paragraph">
                                <p>
                                    When setting up a <code>MockMvc</code> instance, you can register one or more Servlet <code>Filter</code> instances, as the following example shows:</br>
                                    <span class="translate">
                                    当设置MockMvc实例时，你可以注册一个或多个Servlet Filter实例，如下面的例子所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Registered filters are invoked through the <code>MockFilterChain</code> from <code>spring-test</code>,
                                    and the last filter delegates to the <code>DispatcherServlet</code>.</br>
                                    <span class="translate">
                                    已注册的过滤器通过spring-test中的MockFilterChain调用，最后一个过滤器委托给DispatcherServlet。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-vs-end-to-end-integration-tests"><a class="anchor" href="#spring-mvc-test-vs-end-to-end-integration-tests"></a>MockMvc vs End-to-End Tests</h5>
                            <span>MockMvc与端到端的测试</span>
                            <div class="paragraph">
                                <p>
                                    MockMVc is built on Servlet API mock implementations from the
                                    <code>spring-test</code> module and does not rely on a running container. Therefore, there are some differences when
                                    compared to full end-to-end integration tests with an actual client and a live server running.</br>
                                    <span class="translate">
                                    MockMVc构建在spring-test模块的Servlet API模拟实现上，不依赖于运行的容器。因此，与使用实际客户机和活动服务器运行的完整的端到端集成测试相比，存在一些差异。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The easiest way to think about this is by starting with a blank <code>MockHttpServletRequest</code>.
                                    Whatever you add to it is what the request becomes. Things that may catch you by surprise are that there is no context
                                    path by default; no <code>jsessionid</code> cookie; no forwarding, error, or async dispatches; and, therefore,
                                    no actual JSP rendering. Instead, &#8220;forwarded&#8221; and &#8220;redirected&#8221; URLs are saved in
                                    the <code>MockHttpServletResponse</code> and can be asserted with expectations.</br>
                                    <span class="translate">
                                    考虑这个问题的最简单方法是从一个空白的MockHttpServletRequest开始。无论您向它添加什么，请求都会变成什么。
                                    可能会让你惊讶的是，默认情况下没有上下文路径;没有jsessionid饼干;没有转发，错误，或异步分派;
                                    因此，没有实际的JSP呈现。相反， &#8220;forwarded&#8221; 和&#8220;redirected&#8221;的url保存在MockHttpServletResponse中，并可以预期地断言。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    This means that, if you use JSPs, you can verify the JSP page to which the request was forwarded, but no HTML is rendered.
                                    In other words, the JSP is not invoked. Note, however, that all other rendering technologies that
                                    do not rely on forwarding, such as Thymeleaf and Freemarker, render HTML to the response body as expected.
                                    The same is true for rendering JSON, XML, and other formats through <code>@ResponseBody</code> methods.</br>
                                    <span class="translate">
                                    这意味着，如果您使用JSP，您可以验证请求被转发到的JSP页面，但是不会呈现HTML。换句话说，JSP不会被调用。
                                    但是，请注意，所有其他不依赖于转发的呈现技术，如Thymeleaf和Freemarker，都按照预期将HTML呈现到响应体。通过@ResponseBody方法呈现JSON、XML和其他格式也是如此。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Alternatively, you may consider the full end-to-end integration testing support from Spring Boot with <code>@SpringBootTest</code>. See the
                                    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot Reference Guide</a>.</br>
                                    <span class="translate">
                                    或者，您可以考虑使用@SpringBootTest提供SpringBoot的完整的端到端集成测试支持。参见Spring Boot参考指南。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    There are pros and cons for each approach. The options provided in Spring MVC Test are different stops on the scale from classic unit testing to full integration testing. To be certain, none of the options in Spring MVC
                                    Test fall under the category of classic unit testing, but they are a little closer to it. For example, you can isolate the web layer by injecting mocked services into controllers, in which case you are testing the web
                                    layer only through the <code>DispatcherServlet</code> but with actual Spring configuration, as you might test the data access layer in isolation from the layers above it. Also, you can use the stand-alone setup, focusing
                                    on one controller at a time and manually providing the configuration required to make it work.</br>
                                    <span class="translate">
                                    每种方法都有优缺点。Spring MVC测试提供的选项是不同的站点，从经典的单元测试到完全集成测试。可以肯定的是，Spring MVC Test中的任何选项都不属于经典单元测试的范畴，但是它们更接近经典单元测试。
                                    例如，您可以通过将mock服务注入到控制器中来隔离web层，在这种情况下，您只能通过DispatcherServlet来测试web层，但需要使用实际的Spring配置，正如您可能会测试数据访问层与它上面的层隔离一样。
                                    此外，您还可以使用独立的设置，每次只关注一个控制器，并手动提供使其工作所需的配置。
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    Another important distinction when using Spring MVC Test is that, conceptually, such tests are the server-side, so you can check what handler was used, if an exception was handled with a HandlerExceptionResolver, what the
                                    content of the model is, what binding errors there were, and other details. That means that it is easier to write expectations, since the server is not an opaque box, as it is when testing it through an actual HTTP
                                    client. This is generally an advantage of classic unit testing: It is easier to write, reason about, and debug but does not replace the need for full integration tests. At the same time, it is important not to lose
                                    sight of the fact that the response is the most important thing to check. In short, there is room here for multiple styles and strategies of testing even within the same project.</br>
                                    <span class="translate">
                                    使用Spring MVC测试时的另一个重要区别是，从概念上讲，这样的测试是服务器端测试，因此您可以检查使用了什么处理程序，是否用HandlerExceptionResolver处理了异常，模型的内容是什么，有什么绑定错误，以及其他细节。
                                    这意味着更容易编写期望，因为服务器不是一个不透明的盒子(通过实际的HTTP客户机测试时是这样的)。这通常是经典单元测试的一个优势:它更容易编写、推理和调试，但不能取代完全集成测试的需要。
                                    与此同时，重要的是不要忽视这样一个事实，即响应是最重要的检查。简而言之，即使在同一个项目中，这里也有多种测试风格和策略的空间。
                                </p>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-resources"><a class="anchor" href="#spring-mvc-test-server-resources"></a>Further Examples</h5>
                            <span>进一步的例子</span>
                            <div class="paragraph">
                                <p>
                                    The framework&#8217;s own tests include
                                    <a href="https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/test/java/org/springframework/test/web/servlet/samples">
                                    many sample tests</a> intended to show how to use MockMvc on its own or through the
                                    <a href="https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/test/java/org/springframework/test/web/servlet/samples/client">
                                    WebTestClient</a>. Browse these examples for further ideas.</br>
                                    <span class="translate">
                                    该框架自己的测试包括许多示例测试，旨在展示如何单独或通过WebTestClient使用MockMvc。浏览这些示例以获得更多的想法。
                                </p>
                            </div>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="spring-mvc-test-server-htmlunit"><a class="anchor" href="#spring-mvc-test-server-htmlunit"></a>3.7.2. HtmlUnit Integration</h4>
                        <span class="translate">3.7.2 Html单元集成</span>
                        <div class="paragraph">
                            <p>
                                Spring provides integration between <a href="#spring-mvc-test-server">MockMvc</a> and
                                <a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>. This simplifies performing end-to-end testing when using HTML-based views. This integration lets you:</br>
                                <span class="translate">
                                Spring提供了MockMvc和Html单元之间的集成。这简化了在使用基于html的视图时执行端到端测试。这个集成可以让你:
                            </p>
                        </div>
                        <div class="ulist">
                            <ul>
                                <li>
                                    <p>
                                        Easily test HTML pages by using tools such as
                                        <a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>,
                                        <a href="https://www.seleniumhq.org">WebDriver</a>, and
                                        <a href="http://www.gebish.org/manual/current/#spock-junit-testng">Geb</a> without the need to deploy to a Servlet container.</br>
                                        <span class="translate">
                                        通过使用HtmlUnit、WebDriver和Geb等工具轻松测试HTML页面，而不需要部署到Servlet容器。
                                    </p>
                                </li>
                                <li>
                                    <p>Test JavaScript within pages.</br>
                                    <span class="translate">
                                        在页面中测试JavaScript。
                                    </p>
                                </li>
                                <li>
                                    <p>Optionally, test using mock services to speed up testing.</br>
                                    <span class="translate">
                                        可以选择使用模拟服务进行测试，以加速测试。
                                    </p>
                                </li>
                                <li>
                                    <p>Share logic between in-container end-to-end tests and out-of-container integration tests.</br>
                                    <span class="translate">
                                        在容器内端到端测试和容器外集成测试之间共享逻辑。
                                    </p>
                                </li>
                            </ul>
                        </div>
                        <div class="admonitionblock note">
                            <table>
                                <tr>
                                    <td class="icon">
                                        <i class="fa icon-note" title="Note"></i>
                                    </td>
                                    <td class="content">
                                        MockMvc works with templating technologies that do not rely on a Servlet Container (for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since they rely on the Servlet container.</br>
                                        <span class="translate">
                                        MockMvc使用不依赖于Servlet容器的模板技术(例如Thymeleaf、FreeMarker等)，但是它不使用jsp，因为它们依赖于Servlet容器。
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-htmlunit-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why"></a>Why HtmlUnit Integration?</h5>
                            <span class="translate">为什么HtmlUnit集成?</span>
                            <div class="paragraph">
                                <p>
                                    The most obvious question that comes to mind is &#8220;Why do I need this?&#8221; The answer is best found by exploring a very basic sample application.
                                    Assume you have a Spring MVC web application that supports CRUD operations
                                    on a <code>Message</code> object. The application also supports paging through all messages. How would you go about testing it?</br>
                                    <span class="translate">
                                    脑海中出现的最明显的问题是&#8220;我为什么需要这个&#8221;最好通过研究一个非常基本的示例应用程序来找到答案。假设您有一个Spring MVC web应用程序，它支持Message对象上的CRUD操作。
                                    该应用程序还支持对所有消息进行分页。你会如何测试它?
                                </p>
                            </div>
                            <div class="paragraph">
                                <p>
                                    With Spring MVC Test, we can easily test if we are able to create a <code>Message</code>, as follows:</br>
                                    <span class="translate">
                                    使用Spring MVC测试，我们可以很容易地测试我们是否能够创建一个消息，如下所示:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param("summary", "Spring Rocks")
        .param("text", "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun test() {
    mockMvc.post("/messages/") {
        param("summary", "Spring Rocks")
        param("text", "In case you didn't know, Spring Rocks!")
    }.andExpect {
        status().is3xxRedirection()
        redirectedUrl("/messages/123")
    }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    What if we want to test the form view that lets us create the message? For example, assume our form looks like the following snippet:</br>
                                    <span class="translate">
                                    如果我们想测试允许我们创建消息的表单视图呢?例如，假设我们的表单看起来像下面的代码片段:
                                </p>
                            </div>
                            <div class="listingblock">
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;form id="messageForm" action="/messages/" method="post"&gt;
    &lt;div class="pull-right"&gt;&lt;a href="/messages/"&gt;Messages&lt;/a&gt;&lt;/div&gt;

    &lt;label for="summary"&gt;Summary&lt;/label&gt;
    &lt;input type="text" class="required" id="summary" name="summary" value="" /&gt;

    &lt;label for="text"&gt;Message&lt;/label&gt;
    &lt;textarea id="text" name="text"&gt;&lt;/textarea&gt;

    &lt;div class="form-actions"&gt;
        &lt;input type="submit" value="Create" /&gt;
    &lt;/div&gt;
&lt;/form&gt;</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    How do we ensure that our form produce the correct request to create a new message? A naive attempt might resemble the following:</br>
                                    <span class="translate">
                                    如何确保表单生成创建新消息的正确请求?一个幼稚的尝试可能类似如下:
                                </p>
                            </div>
                            <div class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='summary']").exists())
        .andExpect(xpath("//textarea[@name='text']").exists());</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='summary']") { exists() }
    xpath("//textarea[@name='text']") { exists() }
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    This test has some obvious drawbacks. If we update our controller to use the parameter
                                    <code>message</code> instead of <code>text</code>, our form test continues to pass, even though the HTML form is out of synch with the controller. To resolve this we can combine our two tests, as follows:</br>
                                    <span class="translate">
                                    这个测试有一些明显的缺陷。如果我们更新控制器以使用参数消息而不是文本，那么表单测试将继续通过，即使HTML表单与控制器不同步。为了解决这个问题，我们可以结合我们的两个测试，如下所示:
                                </p>
                            </div>
                            <div id="spring-mvc-test-server-htmlunit-mock-mvc-test" class="listingblock primary">
                                <div class="title">Java</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String summaryParamName = "summary";
String textParamName = "text";
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
        .andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param(summaryParamName, "Spring Rocks")
        .param(textParamName, "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
                                </div>
                            </div>
                            <div class="listingblock secondary">
                                <div class="title">Kotlin</div>
                                <div class="content">
                                    <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val summaryParamName = "summary";
val textParamName = "text";
mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='$summaryParamName']") { exists() }
    xpath("//textarea[@name='$textParamName']") { exists() }
}
mockMvc.post("/messages/") {
    param(summaryParamName, "Spring Rocks")
    param(textParamName, "In case you didn't know, Spring Rocks!")
}.andExpect {
    status().is3xxRedirection()
    redirectedUrl("/messages/123")
}</code></pre>
                                </div>
                            </div>
                            <div class="paragraph">
                                <p>
                                    This would reduce the risk of our test incorrectly passing, but there are still some problems:</br>
                                    <span class="translate">
                                    这将降低我们的测试不正确通过的风险，但仍然存在一些问题:
                                </p>
                            </div>
                            <div class="ulist">
                                <ul>
                                    <li>
                                        <p>
                                            What if we have multiple forms on our page? Admittedly, we could update our XPath expressions, but they get more complicated as we take more factors into account: Are the fields the correct type? Are the fields
                                            enabled? And so on.</br>
                                            <span class="translate">
                                            如果页面上有多个表单怎么办?无可否认，我们可以更新XPath表达式，但随着我们考虑更多因素，它们会变得更加复杂:字段的类型是正确的吗?字段是否已启用?等等。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Another issue is that we are doing double the work we would expect. We must first verify the view, and then we submit the view with the same parameters we just verified. Ideally, this could be done all at once.</br>
                                            <span class="translate">
                                            另一个问题是，我们所做的工作是预期的两倍。我们必须首先验证视图，然后提交带有刚才验证过的相同参数的视图。理想情况下，这可以一次完成。
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Finally, we still cannot account for some things. For example, what if the form has JavaScript validation that we wish to test as well?</br>
                                            <span class="translate">
                                            最后，我们仍然不能解释一些事情。例如，如果表单也有我们想要测试的JavaScript验证，该怎么办?
                                        </p>
                                    </li>
                                </ul>
                            </div>
                            <div class="paragraph">
                                <p>
                                    The overall problem is that testing a web page does not involve a single interaction. Instead, it is a combination of how the user interacts with a web page and how that web page interacts with other resources. For example,
                                    the result of a form view is used as the input to a user for creating a message. In addition, our form view can potentially use additional resources that impact the behavior of the page, such as JavaScript validation.</br>
                                    <span class="translate">
                                    总体的问题是，测试一个网页并不涉及单一的交互。相反，它是用户如何与网页交互以及该网页如何与其他资源交互的组合。例如，表单视图的结果被用作用户创建消息的输入。此外，我们的表单视图可能会使用其他影响页面行为的资源，比如JavaScript验证。
                                </p>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-why-integration"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-integration"></a>Integration Testing to the Rescue?</h6>
                                <span class="translate">集成测试来拯救?</span>
                                <div class="paragraph">
                                    <p>
                                        To resolve the issues mentioned earlier, we could perform end-to-end integration testing, but this has some drawbacks. Consider testing the view that lets us page through the messages. We might need the following tests:</br>
                                        <span class="translate">
                                        为了解决前面提到的问题，我们可以执行端到端集成测试，但这有一些缺点。考虑测试允许我们对消息进行分页的视图。我们可能需要以下测试:
                                    </p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p>Does our page display a notification to the user to indicate that no results are available when the messages are empty?</br>
                                            <span class="translate">
                                                当消息为空时，我们的页面是否会向用户显示通知，表明没有可用的结果?
                                            </p>
                                        </li>
                                        <li>
                                            <p>Does our page properly display a single message?</br>
                                            <span class="translate">
                                                我们的页面是否正确地显示单个消息?
                                            </p>
                                        </li>
                                        <li>
                                            <p>Does our page properly support paging?</br>
                                            <span class="translate">
                                                我们的页面是否正确地支持分页?
                                            </p>
                                        </li>
                                    </ul>
                                </div>
                                <div class="paragraph">
                                    <p>To set up these tests, we need to ensure our database contains the proper messages. This leads to a number of additional challenges:</br>
                                    <span class="translate">
                                        要设置这些测试，我们需要确保数据库包含正确的消息。这就带来了一些额外的挑战:
                                    </p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p>
                                                Ensuring the proper messages are in the database can be tedious. (Consider foreign key constraints.)</br>
                                                <span class="translate">确保数据库中有适当的消息是很繁琐的。(考虑外键约束。)
                                            </p>
                                        </li>
                                        <li>
                                            <p>
                                                Testing can become slow, since each test would need to ensure that the database is in the correct state.</br>
                                                <span class="translate">测试可能会变慢，因为每个测试都需要确保数据库处于正确的状态。
                                            </p>
                                        </li>
                                        <li>
                                            <p>
                                                Since our database needs to be in a specific state, we cannot run tests in parallel.</br>
                                                <span class="translate">因为我们的数据库需要处于特定的状态，所以我们不能并行运行测试。
                                            </p>
                                        </li>
                                        <li>
                                            <p>
                                                Performing assertions on such items as auto-generated ids, timestamps, and others can be difficult.</br>
                                                <span class="translate">对自动生成的id、时间戳等项执行断言可能很困难。
                                            </p>
                                        </li>
                                    </ul>
                                </div>
                                <div class="paragraph">
                                    <p>
                                        These challenges do not mean that we should abandon end-to-end integration testing altogether. Instead, we can reduce the number of end-to-end integration tests by refactoring our detailed tests to use mock services
                                        that run much faster, more reliably, and without side effects. We can then implement a small number of true end-to-end integration tests that validate simple workflows to ensure that everything works together properly.</br>
                                        <span class="translate">
                                        这些挑战并不意味着我们应该完全放弃端到端集成测试。相反，我们可以通过重构详细的测试来使用运行得更快、更可靠、没有副作用的模拟服务，从而减少端到端集成测试的数量。
                                        然后，我们可以实现少量真正的端到端集成测试，这些测试验证简单的工作流，以确保一切都能正常工作。
                                    </p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-why-mockmvc"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-mockmvc"></a>Enter HtmlUnit Integration</h6>
                                <span>进入HtmlUnit集成</sapn>
                                <div class="paragraph">
                                    <p>
                                        So how can we achieve a balance between testing the interactions of our pages and still retain good performance within our test suite?
                                        The answer is: &#8220;By integrating MockMvc with HtmlUnit.&#8221;</br>
                                        <span class="translate">
                                        那么，我们如何在测试页面的交互和仍然在测试套件中保持良好的性能之间取得平衡呢?答案是：&#8220;通过将MockMvc与HtmlUnit集成。&#8221;
                                    </p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-options"><a class="anchor" href="#spring-mvc-test-server-htmlunit-options"></a>HtmlUnit Integration Options</h6>
                                <span class="translate">HtmlUnit集成选项</span>
                                <div class="paragraph">
                                    <p>
                                        You have a number of options when you want to integrate MockMvc with HtmlUnit:</br>
                                        <span class="translate">
                                        当你想要将MockMvc与HtmlUnit集成时，你有许多选项:
                                    </p>
                                </div>
                                <div class="ulist">
                                    <ul>
                                        <li>
                                            <p>
                                                <a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a>: Use this option if you want to use the raw HtmlUnit libraries.</br>
                                                <span class="translate">
                                                MockMvc和HtmlUnit:如果你想使用原始的HtmlUnit库，请使用此选项。
                                            </p>
                                        </li>
                                        <li>
                                            <p><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a>: Use this option to ease development and reuse code between integration and end-to-end testing.</p>
                                        </li>
                                        <li>
                                            <p><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a>: Use this option if you want to use Groovy for testing, ease development, and reuse code between integration and end-to-end testing.</p>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-htmlunit-mah"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah"></a>MockMvc and HtmlUnit</h5>
                            <div class="paragraph">
                                <p>This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want to use the raw HtmlUnit libraries.</p>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-mah-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-setup"></a>MockMvc and HtmlUnit Setup</h6>
                                <div class="paragraph">
                                    <p>First, make sure that you have included a test dependency on
                                        <code>net.sourceforge.htmlunit:htmlunit</code>. In order to use HtmlUnit with Apache HttpComponents 4.5+, you need to use HtmlUnit 2.18 or higher.</p>
                                </div>
                                <div class="paragraph">
                                    <p>We can easily create an HtmlUnit <code>WebClient</code> that integrates with MockMvc by using the
                                        <code>MockMvcWebClientBuilder</code>, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                This is a simple example of using <code>MockMvcWebClientBuilder</code>. For advanced usage, see <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>This ensures that any URL that references <code>localhost</code> as the server is directed to our
                                        <code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is requested by using a network connection, as normal. This lets us easily test the use of CDNs.
                                    </p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-mah-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-usage"></a>MockMvc and HtmlUnit Usage</h6>
                                <div class="paragraph">
                                    <p>Now we can use HtmlUnit as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val createMsgFormPage = webClient.getPage("http://localhost/messages/form")</code></pre>
                                    </div>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                The default context path is <code>""</code>. Alternatively, we can specify the context path, as described in <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>Once we have a reference to the <code>HtmlPage</code>, we can then fill out the form and submit it to create a message, as the following example shows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val form = createMsgFormPage.getHtmlElementById("messageForm")
val summaryInput = createMsgFormPage.getHtmlElementById("summary")
summaryInput.setValueAttribute("Spring Rocks")
val textInput = createMsgFormPage.getHtmlElementById("text")
textInput.setText("In case you didn't know, Spring Rocks!")
val submit = form.getOneHtmlElementByAttribute("input", "type", "submit")
val newMessagePage = submit.click()</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Finally, we can verify that a new message was created successfully. The following assertions use the <a href="https://assertj.github.io/doc/">AssertJ</a> library:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123")
val id = newMessagePage.getHtmlElementById("id").getTextContent()
assertThat(id).isEqualTo("123")
val summary = newMessagePage.getHtmlElementById("summary").getTextContent()
assertThat(summary).isEqualTo("Spring Rocks")
val text = newMessagePage.getHtmlElementById("text").getTextContent()
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!")</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>The preceding code improves on our
                                        <a href="#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc test</a> in a number of ways. First, we no longer have to explicitly verify our form and then create a request that looks like the form. Instead,
                                        we request the form, fill it out, and submit it, thereby significantly reducing the overhead.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Another important factor is that <a href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit
uses the Mozilla Rhino engine</a> to evaluate JavaScript. This means that we can also test the behavior of JavaScript within our pages.</p>
                                </div>
                                <div class="paragraph">
                                    <p>See the <a href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit documentation</a> for additional information about using HtmlUnit.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-mah-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-advanced-builder"></a>Advanced <code>MockMvcWebClientBuilder</code></h6>
                                <div class="paragraph">
                                    <p>In the examples so far, we have used <code>MockMvcWebClientBuilder</code> in the simplest way possible, by building a <code>WebClient</code> based on the <code>WebApplicationContext</code> loaded for us by the Spring
                                        TestContext Framework. This approach is repeated in the following example:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can also specify additional configuration options, as the following example shows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code> instance separately and supplying it to the <code>MockMvcWebClientBuilder</code>, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>This is more verbose, but, by building the <code>WebClient</code> with a <code>MockMvc</code> instance, we have the full power of MockMvc at our fingertips.</p>
                                </div>
                                <div class="admonitionblock tip">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-tip" title="Tip"></i>
                                            </td>
                                            <td class="content">
                                                For additional information on creating a <code>MockMvc</code> instance, see
                                                <a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-htmlunit-webdriver"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver"></a>MockMvc and WebDriver</h5>
                            <div class="paragraph">
                                <p>In the previous sections, we have seen how to use MockMvc in conjunction with the raw HtmlUnit APIs. In this section, we use additional abstractions within the Selenium
                                    <a href="https://docs.seleniumhq.org/projects/webdriver/">WebDriver</a> to make things even easier.</p>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-webdriver-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-why"></a>Why WebDriver and MockMvc?</h6>
                                <div class="paragraph">
                                    <p>We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The Selenium WebDriver provides a very elegant API that lets us easily organize our code. To better show how it works, we explore an example
                                        in this section.</p>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                Despite being a part of <a href="https://docs.seleniumhq.org/">Selenium</a>, WebDriver does not require a Selenium Server to run your tests.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>Suppose we need to ensure that a message is created properly. The tests involve finding the HTML form input elements, filling them out, and making various assertions.</p>
                                </div>
                                <div class="paragraph">
                                    <p>This approach results in numerous separate tests because we want to test error conditions as well. For example, we want to ensure that we get an error if we fill out only part of the form. If we fill out the entire
                                        form, the newly created message should be displayed afterwards.
                                    </p>
                                </div>
                                <div class="paragraph">
                                    <p>If one of the fields were named &#8220;summary&#8221;, we might have something that resembles the following repeated in multiple places within our tests:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
summaryInput.setValueAttribute(summary);</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val summaryInput = currentPage.getHtmlElementById("summary")
summaryInput.setValueAttribute(summary)</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>So what happens if we change the <code>id</code> to <code>smmry</code>? Doing so would force us to update all of our tests to incorporate this change. This violates the DRY principle, so we should ideally extract this
                                        code into its own method, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
    setSummary(currentPage, summary);
    // ...
}

public void setSummary(HtmlPage currentPage, String summary) {
    HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
    summaryInput.setValueAttribute(summary);
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{
    setSummary(currentPage, summary);
    // ...
}

fun setSummary(currentPage:HtmlPage , summary: String) {
    val summaryInput = currentPage.getHtmlElementById("summary")
    summaryInput.setValueAttribute(summary)
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Doing so ensures that we do not have to update all of our tests if we change the UI.</p>
                                </div>
                                <div class="paragraph">
                                    <p>We might even take this a step further and place this logic within an <code>Object</code> that represents the <code>HtmlPage</code> we are currently on, as the following example shows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CreateMessagePage {

    final HtmlPage currentPage;

    final HtmlTextInput summaryInput;

    final HtmlSubmitInput submit;

    public CreateMessagePage(HtmlPage currentPage) {
        this.currentPage = currentPage;
        this.summaryInput = currentPage.getHtmlElementById("summary");
        this.submit = currentPage.getHtmlElementById("submit");
    }

    public &lt;T&gt; T createMessage(String summary, String text) throws Exception {
        setSummary(summary);

        HtmlPage result = submit.click();
        boolean error = CreateMessagePage.at(result);

        return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
    }

    public void setSummary(String summary) throws Exception {
        summaryInput.setValueAttribute(summary);
    }

    public static boolean at(HtmlPage page) {
        return "Create Message".equals(page.getTitleText());
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">    class CreateMessagePage(private val currentPage: HtmlPage) {

        val summaryInput: HtmlTextInput = currentPage.getHtmlElementById("summary")

        val submit: HtmlSubmitInput = currentPage.getHtmlElementById("submit")

        fun &lt;T&gt; createMessage(summary: String, text: String): T {
            setSummary(summary)

            val result = submit.click()
            val error = at(result)

            return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T
        }

        fun setSummary(summary: String) {
            summaryInput.setValueAttribute(summary)
        }

        fun at(page: HtmlPage): Boolean {
            return "Create Message" == page.getTitleText()
        }
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Formerly, this pattern was known as the
                                        <a href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">Page Object Pattern</a>. While we can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the following sections to
                                        make this pattern much easier to implement.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-webdriver-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-setup"></a>MockMvc and WebDriver Setup</h6>
                                <div class="paragraph">
                                    <p>To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project includes a test dependency on <code>org.seleniumhq.selenium:selenium-htmlunit-driver</code>.</p>
                                </div>
                                <div class="paragraph">
                                    <p>We can easily create a Selenium WebDriver that integrates with MockMvc by using the
                                        <code>MockMvcHtmlUnitDriverBuilder</code> as the following example shows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>The preceding example ensures that any URL that references <code>localhost</code> as the server is directed to our <code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is requested
                                        by using a network connection, as normal. This lets us easily test the use of CDNs.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-webdriver-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-usage"></a>MockMvc and WebDriver Usage</h6>
                                <div class="paragraph">
                                    <p>Now we can use WebDriver as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">CreateMessagePage page = CreateMessagePage.to(driver);</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val page = CreateMessagePage.to(driver)</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can then fill out the form and submit it to create a message, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ViewMessagePage viewMessagePage =
        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val viewMessagePage =
    page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>This improves on the design of our <a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a> by leveraging the Page Object Pattern. As we mentioned in
                                        <a href="#spring-mvc-test-server-htmlunit-webdriver-why">Why WebDriver and MockMvc?</a>, we can use the Page Object Pattern with HtmlUnit, but it is much easier with WebDriver. Consider the following
                                        <code>CreateMessagePage</code> implementation:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CreateMessagePage
        extends AbstractPage { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private WebElement summary;
    private WebElement text;

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private WebElement submit;

    public CreateMessagePage(WebDriver driver) {
        super(driver);
    }

    public &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) {
        this.summary.sendKeys(summary);
        this.text.sendKeys(details);
        this.submit.click();
        return PageFactory.initElements(driver, resultPage);
    }

    public static CreateMessagePage to(WebDriver driver) {
        driver.get("http://localhost:9990/mail/messages/form");
        return PageFactory.initElements(driver, CreateMessagePage.class);
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
                                                <code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages. For example, if our application has a navigational bar, global error messages, and other features, we can
                                                place this logic in a shared location.</td>
                                        </tr>
                                        <tr>
                                            <td><i class="conum" data-value="2"></i><b>2</b></td>
                                            <td>We have a member variable for each of the parts of the HTML page in which we are interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
                                                <a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
                                                each <code>WebElement</code>. The
                                                <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>                                                method automatically resolves each <code>WebElement</code> by using the field name and looking it up by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
                                        </tr>
                                        <tr>
                                            <td><i class="conum" data-value="3"></i><b>3</b></td>
                                            <td>We can use the
                                                <a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a> to override the default lookup behavior. Our example shows
                                                how to use the <code>@FindBy</code> annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private lateinit var summary: WebElement
    private lateinit var text: WebElement

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private lateinit var submit: WebElement

    fun &lt;T&gt; createMessage(resultPage: Class&lt;T&gt;, summary: String, details: String): T {
        this.summary.sendKeys(summary)
        text.sendKeys(details)
        submit.click()
        return PageFactory.initElements(driver, resultPage)
    }
    companion object {
        fun to(driver: WebDriver): CreateMessagePage {
            driver.get("http://localhost:9990/mail/messages/form")
            return PageFactory.initElements(driver, CreateMessagePage::class.java)
        }
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="colist arabic">
                                    <table>
                                        <tr>
                                            <td><i class="conum" data-value="1"></i><b>1</b></td>
                                            <td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
                                                <code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages. For example, if our application has a navigational bar, global error messages, and other features, we can
                                                place this logic in a shared location.</td>
                                        </tr>
                                        <tr>
                                            <td><i class="conum" data-value="2"></i><b>2</b></td>
                                            <td>We have a member variable for each of the parts of the HTML page in which we are interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
                                                <a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
                                                each <code>WebElement</code>. The
                                                <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>                                                method automatically resolves each <code>WebElement</code> by using the field name and looking it up by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
                                        </tr>
                                        <tr>
                                            <td><i class="conum" data-value="3"></i><b>3</b></td>
                                            <td>We can use the
                                                <a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a> to override the default lookup behavior. Our example shows
                                                how to use the <code>@FindBy</code> annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>Finally, we can verify that a new message was created successfully. The following assertions use the <a href="https://assertj.github.io/doc/">AssertJ</a> assertion library:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">assertThat(viewMessagePage.message).isEqualTo(expectedMessage)
assertThat(viewMessagePage.success).isEqualTo("Successfully created a new message")</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can see that our <code>ViewMessagePage</code> lets us interact with our custom domain model. For example, it exposes a method that returns a <code>Message</code> object:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Message getMessage() throws ParseException {
    Message message = new Message();
    message.setId(getId());
    message.setCreated(getCreated());
    message.setSummary(getSummary());
    message.setText(getText());
    return message;
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun getMessage() = Message(getId(), getCreated(), getSummary(), getText())</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can then use the rich domain objects in our assertions.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Lastly, we must not forget to close the <code>WebDriver</code> instance when the test is complete, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@AfterEach
void destroy() {
    if (driver != null) {
        driver.close();
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@AfterEach
fun destroy() {
    if (driver != null) {
        driver.close()
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>For additional information on using WebDriver, see the Selenium
                                        <a href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver documentation</a>.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-webdriver-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder"></a>Advanced <code>MockMvcHtmlUnitDriverBuilder</code></h6>
                                <div class="paragraph">
                                    <p>In the examples so far, we have used <code>MockMvcHtmlUnitDriverBuilder</code> in the simplest way possible, by building a <code>WebDriver</code> based on the <code>WebApplicationContext</code> loaded for us by the
                                        Spring TestContext Framework. This approach is repeated here, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can also specify additional configuration options, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build();
}</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code> instance separately and supplying it to the <code>MockMvcHtmlUnitDriverBuilder</code>, as follows:</p>
                                </div>
                                <div class="listingblock primary">
                                    <div class="title">Java</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

driver = MockMvcHtmlUnitDriverBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
                                    </div>
                                </div>
                                <div class="listingblock secondary">
                                    <div class="title">Kotlin</div>
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>This is more verbose, but, by building the <code>WebDriver</code> with a <code>MockMvc</code> instance, we have the full power of MockMvc at our fingertips.</p>
                                </div>
                                <div class="admonitionblock tip">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-tip" title="Tip"></i>
                                            </td>
                                            <td class="content">
                                                For additional information on creating a <code>MockMvc</code> instance, see
                                                <a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <div class="sect4">
                            <h5 id="spring-mvc-test-server-htmlunit-geb"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb"></a>MockMvc and Geb</h5>
                            <div class="paragraph">
                                <p>In the previous section, we saw how to use MockMvc with WebDriver. In this section, we use <a href="http://www.gebish.org/">Geb</a> to make our tests even Groovy-er.</p>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-geb-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-why"></a>Why Geb and MockMvc?</h6>
                                <div class="paragraph">
                                    <p>Geb is backed by WebDriver, so it offers many of the
                                        <a href="#spring-mvc-test-server-htmlunit-webdriver-why">same benefits</a> that we get from WebDriver. However, Geb makes things even easier by taking care of some of the boilerplate code for us.</p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-geb-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-setup"></a>MockMvc and Geb Setup</h6>
                                <div class="paragraph">
                                    <p>We can easily initialize a Geb <code>Browser</code> with a Selenium WebDriver that uses MockMvc, as follows:
                                    </p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">def setup() {
    browser.driver = MockMvcHtmlUnitDriverBuilder
        .webAppContextSetup(context)
        .build()
}</code></pre>
                                    </div>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>This ensures that any URL referencing <code>localhost</code> as the server is directed to our
                                        <code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is requested by using a network connection as normal. This lets us easily test the use of CDNs.
                                    </p>
                                </div>
                            </div>
                            <div class="sect5">
                                <h6 id="spring-mvc-test-server-htmlunit-geb-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-usage"></a>MockMvc and Geb Usage</h6>
                                <div class="paragraph">
                                    <p>Now we can use Geb as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:
                                    </p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">to CreateMessagePage</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We can then fill out the form and submit it to create a message, as follows:</p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Any unrecognized method calls or property accesses or references that are not found are forwarded to the current page object. This removes a lot of the boilerplate code we needed when using WebDriver directly.</p>
                                </div>
                                <div class="paragraph">
                                    <p>As with direct WebDriver usage, this improves on the design of our
                                        <a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a> by using the Page Object Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and WebDriver, but it is even easier
                                        with Geb. Consider our new Groovy-based
                                        <code>CreateMessagePage</code> implementation:</p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">class CreateMessagePage extends Page {
    static url = 'messages/form'
    static at = { assert title == 'Messages : Create'; true }
    static content =  {
        submit { $('input[type=submit]') }
        form { $('form') }
        errors(required:false) { $('label.error, .alert-error')?.text() }
    }
}</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>Our <code>CreateMessagePage</code> extends <code>Page</code>. We do not go over the details of <code>Page</code>, but, in summary, it contains common functionality for all of our pages. We define a URL in which this
                                        page can be found. This lets us navigate to the page, as follows:</p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">to CreateMessagePage</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>We also have an <code>at</code> closure that determines if we are at the specified page. It should return <code>true</code> if we are on the correct page. This is why we can assert that we are on the correct page, as
                                        follows:</p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">then:
at CreateMessagePage
errors.contains('This field is required.')</code></pre>
                                    </div>
                                </div>
                                <div class="admonitionblock note">
                                    <table>
                                        <tr>
                                            <td class="icon">
                                                <i class="fa icon-note" title="Note"></i>
                                            </td>
                                            <td class="content">
                                                We use an assertion in the closure so that we can determine where things went wrong if we were at the wrong page.
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="paragraph">
                                    <p>Next, we create a <code>content</code> closure that specifies all the areas of interest within the page. We can use a
                                        <a href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator
API</a> to select the content in which we are interested.</p>
                                </div>
                                <div class="paragraph">
                                    <p>Finally, we can verify that a new message was created successfully, as follows:</p>
                                </div>
                                <div class="listingblock">
                                    <div class="content">
                                        <pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage</code></pre>
                                    </div>
                                </div>
                                <div class="paragraph">
                                    <p>For further details on how to get the most out of Geb, see
                                        <a href="http://www.gebish.org/manual/current/">The Book of Geb</a> user&#8217;s manual.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sect2">
                    <h3 id="spring-mvc-test-client"><a class="anchor" href="#spring-mvc-test-client"></a>3.8. Testing Client Applications</h3>
                    <span>3.8. 测试客户端应用程序</span>
                    <div class="paragraph">
                        <p>
                            You can use client-side tests to test code that internally uses the <code>RestTemplate</code>. The idea is to declare expected requests and to provide &#8220;stub&#8221; responses so that you can focus on testing the code in isolation
                            (that is, without running a server). The following example shows how to do so:</br>
                            您可以使用客户端测试来测试内部使用RestTemplate的代码。其思想是声明预期的请求并提供“存根”响应，这样您就可以专注于独立测试代码(也就是说，无需运行服务器)。
                            下面的例子展示了如何做到这一点:
                        </p>
                    </div>
                    <div class="listingblock primary">
                        <div class="title">Java</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();</code></pre>
                        </div>
                    </div>
                    <div class="listingblock secondary">
                        <div class="title">Kotlin</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

// Test code that uses the above RestTemplate ...

mockServer.verify()</code></pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>
                            In the preceding example, <code>MockRestServiceServer</code> (the central class for client-side REST tests) configures
                            the <code>RestTemplate</code> with a custom <code>ClientHttpRequestFactory</code> that asserts actual requests
                            against expectations and returns &#8220;stub&#8221; responses. In this case, we expect a request to <code>/greeting</code> and want to return a 200 response with
                            <code>text/plain</code> content. We can define additional expected requests and stub responses as needed. When we define expected requests and stub responses,
                             the <code>RestTemplate</code> can be used in client-side code as
                            usual. At the end of testing, <code>mockServer.verify()</code> can be used to verify that all expectations have been satisfied.</br>
                            在前面的示例中，MockRestServiceServer(客户端REST测试的中心类)使用自定义的ClientHttpRequestFactory配置RestTemplate，该factory根据预期断言实际请求并返回&#8220;stub&#8221;响应。
                            在本例中，我们期望收到一个to /greeting请求，并希望返回一个带有文本/纯内容的200响应。
                            我们可以根据需要定义额外的预期请求和存根响应。当我们定义期望的请求和存根响应时，可以像往常一样在客户端代码中使用RestTemplate。在测试结束时，可以使用mockServer.verify()来验证是否满足了所有的期望。
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>
                            By default, requests are expected in the order in which expectations were declared. You can set the <code>ignoreExpectOrder</code> option when building the server,
                            in which case all expectations are checked (in order) to find a
                            match for a given request. That means requests are allowed to come in any order. The following example uses <code>ignoreExpectOrder</code>:</br>
                            默认情况下，请求的预期顺序与预期声明的顺序一致。您可以在构建服务器时设置ignoreExpectOrder选项，在这种情况下，所有期望都将被检查(以便)找到给定请求的匹配。
                            这意味着请求可以以任何顺序来。下面的例子使用了ignoreExpectOrder:
                        </p>
                    </div>
                    <div class="listingblock primary">
                        <div class="title">Java</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();</code></pre>
                        </div>
                    </div>
                    <div class="listingblock secondary">
                        <div class="title">Kotlin</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()</code></pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>
                            Even with unordered requests by default, each request is allowed to run once only.
                            The <code>expect</code> method provides an overloaded variant that accepts an <code>ExpectedCount</code> argument that specifies a count range (for
                            example, <code>once</code>, <code>manyTimes</code>, <code>max</code>, <code>min</code>,
                            <code>between</code>, and so on). The following example uses <code>times</code>:</br>
                            默认情况下，即使是无序请求，每个请求也只允许运行一次。expect方法提供了一个重载变量，该变量接受一个ExpectedCount参数，该参数指定一个计数范围(例如，once、manyTimes、max、min、between等)。
                            下面的例子使用了时间:
                        </p>
                    </div>
                    <div class="listingblock primary">
                        <div class="title">Java</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

// ...

mockServer.verify();</code></pre>
                        </div>
                    </div>
                    <div class="listingblock secondary">
                        <div class="title">Kotlin</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

// ...

mockServer.verify()</code></pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>
                            Note that, when <code>ignoreExpectOrder</code> is not set (the default), and, therefore, requests are expected in order of declaration,
                            then that order applies only to the first of any expected request. For example if "/something"
                            is expected two times followed by "/somewhere" three times, then there should be a request to "/something" before there is a request
                            to "/somewhere", but, aside from that subsequent "/something" and "/somewhere", requests can
                            come at any time.</br>
                            注意，如果没有设置ignoreExpectOrder(默认值)，那么请求是按照声明的顺序进行的，那么这个顺序只适用于任何预期请求的第一个。
                            例如，如果“/something”被期望两次，然后是“/somewhere”三次，那么在“/somewhere”之前应该有一个对“/something”的请求，
                            但是，除了后面的“/something”和“/somewhere”，请求可以在任何时间来。
                        </p>
                    </div>
                    <div class="paragraph">
                        <p>
                            As an alternative to all of the above, the client-side test support also provides a
                            <code>ClientHttpRequestFactory</code> implementation that you can configure into a
                            <code>RestTemplate</code> to bind it to a <code>MockMvc</code> instance. That allows processing requests using actual server-side logic but
                            without running a server. The following example shows how to do so:</br>
                            作为上述所有的替代方案，客户端测试支持还提供了一个ClientHttpRequestFactory实现，您可以将其配置到RestTemplate中，以将其绑定到MockMvc实例。
                            这允许使用实际的服务器端逻辑处理请求，而无需运行服务器。下面的例子展示了如何做到这一点:
                        </p>
                    </div>
                    <div class="listingblock primary">
                        <div class="title">Java</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...</code></pre>
                        </div>
                    </div>
                    <div class="listingblock secondary">
                        <div class="title">Kotlin</div>
                        <div class="content">
                            <pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

// Test code that uses the above RestTemplate ...</code></pre>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="spring-mvc-test-client-static-imports"><a class="anchor" href="#spring-mvc-test-client-static-imports"></a>3.8.1. Static Imports</h4>
                        <div class="paragraph">
                            <p>
                                As with server-side tests, the fluent API for client-side tests requires a few static imports.
                                Those are easy to find by searching for <code>MockRest*</code>. Eclipse users should add
                                <code>MockRestRequestMatchers.*</code> and <code>MockRestResponseCreators.*</code> as &#8220;favorite static members&#8221;
                                in the Eclipse preferences under Java &#8594; Editor &#8594; Content Assist &#8594; Favorites.
                                That allows using content assist after typing the first character of the static method name.
                                Other IDEs (such IntelliJ) may not require any additional configuration. Check for the support for code completion on static members.</br>
                                与服务器端测试一样，用于客户端测试的流畅API需要一些静态导入。这些很容易通过搜索MockRest*找到。Eclipse用户应该添加mockrerequestmatchers。
                                *和MockRestResponseCreators。*在Java→编辑器→内容辅助→收藏夹的Eclipse首选项中作为“收藏静态成员”。这允许在输入静态方法名的第一个字符后使用内容辅助。
                                其他ide(如IntelliJ)可能不需要任何额外的配置。检查对静态成员代码完成的支持。
                            </p>
                        </div>
                    </div>
                    <div class="sect3">
                        <h4 id="spring-mvc-test-client-resources"><a class="anchor" href="#spring-mvc-test-client-resources"></a>3.8.2. Further Examples of Client-side REST Tests</h4>
                        <span>3.8.2. 客户端REST测试的进一步示例</span>
                        <div class="paragraph">
                            <p>
                                Spring MVC Test&#8217;s own tests include
                                <a href="https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/test/java/org/springframework/test/web/client/samples">example
                                tests</a> of client-side REST tests.</br>
                                Spring MVC Test自己的测试包括客户端REST测试的示例测试。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="sect1">
            <h2 id="testing-resources"><a class="anchor" href="#testing-resources"></a>4. Further Resources</h2>
            <span>4. 进一步的资源</span>
            <div class="sectionbody">
                <div class="paragraph">
                    <p>See the following resources for more information about testing:</br>
                        有关测试的更多信息，请参阅以下参考资料:
                    </p>
                </div>
                <div class="ulist">
                    <ul>
                        <li>
                            <p>
                                <a href="https://www.junit.org/">JUnit</a>: &#8220;A programmer-friendly testing framework for Java&#8221;. Used by the Spring Framework in its test suite and supported in the
                                <a href="#testcontext-framework">Spring TestContext Framework</a>.</br>
                                JUnit:&#8220;程序员友好的Java测试框架&#8221;。Spring框架在其测试套件中使用，并在Spring TestContext框架中得到支持。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://testng.org/">TestNG</a>: A testing framework inspired by JUnit with added support for test groups,
                                data-driven testing, distributed testing, and other features. Supported in the <a href="#testcontext-framework">Spring TestContext Framework</a></br>
                                TestNG:一个受JUnit启发的测试框架，增加了对测试组、数据驱动测试、分布式测试和其他特性的支持。Spring TestContext框架支持
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://assertj.github.io/doc/">AssertJ</a>: &#8220;Fluent assertions for Java&#8221;,
                                including support for Java 8 lambdas, streams, and other features.</br>
                                AssertJ:&#8220;Java的流利断言&#8221;，包括对Java 8 lambdas、流和其他特性的支持。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://en.wikipedia.org/wiki/Mock_Object">Mock Objects</a>: Article in Wikipedia.</br>
                                    模拟对象:维基百科中的文章。
                                </p>
                        </li>
                        <li>
                            <p>
                                <a href="http://www.mockobjects.com/">MockObjects.com</a>: Web site dedicated to mock objects,
                                 a technique for improving the design of code within test-driven development.</br>
                                 MockObjects.com:专门用于模拟对象的网站，这是一种在测试驱动开发中改进代码设计的技术。
                             </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://mockito.github.io">Mockito</a>: Java mock library based on the
                                <a href="http://xunitpatterns.com/Test%20Spy.html">Test Spy</a> pattern. Used by the Spring Framework in its test suite.</br>
                                Mockito:基于Test Spy模式的Java模拟库。Spring框架在其测试套件中使用。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://easymock.org/">EasyMock</a>: Java library &#8220;that provides Mock Objects for interfaces
                                (and objects through the class extension) by generating them on the fly using Java&#8217;s proxy mechanism.&#8221;</br>
                                EasyMock: Java库&#8220;通过使用Java的代理机制动态生成接口(以及通过类扩展生成的对象)，从而为接口提供模拟对象。&#8221;
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://jmock.org/">JMock</a>: Library that supports test-driven development of Java code with mock objects.</br>
                                JMock:支持使用模拟对象对Java代码进行测试驱动开发的库。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://www.dbunit.org/">DbUnit</a>: JUnit extension (also usable with Ant and Maven)
                                that is targeted at database-driven projects and, among other things, puts your database into a known state between test runs.</br>
                                DbUnit: JUnit扩展(也可用于Ant和Maven)，它针对数据库驱动的项目，并且在测试运行之间将数据库置于已知状态。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://www.testcontainers.org/">Testcontainers</a>: Java library that supports JUnit tests,
                                providing lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a
                                Docker container.</br>
                                测试容器:支持JUnit测试的Java库，提供了通用数据库、Selenium web浏览器或其他可以在Docker容器中运行的任何东西的轻量级一次性实例。
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://sourceforge.net/projects/grinder/">The Grinder</a>: Java load testing framework.</br>
                                <span class="translate">
                                Grinder: Java负载测试框架。
                                </span>
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="https://github.com/Ninja-Squad/springmockk">SpringMockK</a>: Support for Spring Boot
                                integration tests written in Kotlin using <a href="https://mockk.io/">MockK</a> instead of Mockito.</br>
                                <span class="translate">
                                SpringMockK:支持在Kotlin中使用MockK而不是mockto编写的Spring Boot集成测试。
                                </span>
                            </p>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div id="footer">
        <div id="footer-text">
            Version 5.3.8<br> Last updated 2021-06-09 07:38:19 UTC
        </div>
    </div>
    <link rel="stylesheet" href="js/highlight/styles/googlecode.min.css">
    <script src="js/highlight/highlight.min.js"></script>
    <script>
        hljs.initHighlighting()
    </script>
    <script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
    <script type="text/javascript" src="js/toc.js"></script>
    <script>
        if (window.parent == window) {
            (function(i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o), m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'UA-2728886-23', 'auto', {
                'siteSpeedSampleRate': 100
            });
            ga('send', 'pageview');
        }
    </script>
    <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"rayId":"66267b2c4ea4282e","token":"bffcb8a918ae4755926f76178bfbd26b","version":"2021.5.2","si":10}'></script>
    <script>
    !function () {
        function n(n, e, t) {
            return n.getAttribute(e) || t
        }

        function e(n) {
            return document.getElementsByTagName(n)
        }

        function t() {
            var t = e("script"), o = t.length,
                i = t[o - 1];
            return {
                l: o, z: n(i, "zIndex", -1),
                o: n(i, "opacity", 1),
                c: n(i, "color", "0,0,0"),
                n: n(i, "count", 150)
            }

        }

        function o() {
            a = m.width = window.innerWidth ||
                document.documentElement.clientWidth ||
                document.body.clientWidth,
                c = m.height = window.innerHeight ||
                    document.documentElement.clientHeight ||
                    document.body.clientHeight
        }

        function i() {
            r.clearRect(0, 0, a, c);
            var n, e, t, o, m, l;
            s.forEach(
                function (i, x) {
                    for (i.x += i.xa,
                             i.y += i.ya,
                             i.xa *= i.x > a || i.x < 0 ? -1 : 1,
                             i.ya *= i.y > c || i.y < 0 ? -1 : 1,
                             r.fillRect(i.x - .5, i.y - .5, 1, 1),
                             e = x + 1; e < u.length; e++
                    ) n = u[e],
                    null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y, l = o * o + m * m,
                    l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o, i.y -= .03 * m),
                        t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2,
                        r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")",
                        r.moveTo(i.x, i.y),
                        r.lineTo(n.x, n.y),
                        r.stroke()))
                }
            ), x(i)
        }

        var a, c, u, m = document.createElement("canvas"),
            d = t(),
            l = "c_n" + d.l,
            r = m.getContext("2d"),
            x = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame
                || function (n) {
                    window.setTimeout(n, 1e3 / 45)
                },
            w = Math.random,
            y = {x: null, y: null, max: 2e4};
        m.id = l,
            m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z + ";opacity:" + d.o,
            e("body")[0].appendChild(m),
            o(),
            window.onresize = o,
            window.onmousemove = function (n) {
                n = n || window.event, y.x = n.clientX, y.y = n.clientY
            },
            window.onmouseout = function () {
                y.x = null, y.y = null
            };
        for (var s = [], f = 0; d.n > f; f++) {
            var h = w() * a,
                g = w() * c,
                v = 2 * w() - 1,
                p = 2 * w() - 1;
            s.push({x: h, y: g, xa: v, ya: p, max: 6e3})
        }
        u = s.concat([y]),
            setTimeout(function () {
                i()
            }, 100)
    }();
</script>
</body>

</html>